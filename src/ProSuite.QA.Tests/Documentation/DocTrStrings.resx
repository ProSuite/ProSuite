<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TrDissolve_0" xml:space="preserve">
    <value>Transforms line feature class 'featureClass' by dissolving connected features</value>
  </data>
  <data name="TrDissolve_Attributes" xml:space="preserve">
    <value>Attributes to be transfered to transformed feature class. Must be used with alias and group expression, i.e. 'MAX(LAUF_NR) AS MAX_LAUF_NR'.
In the resulting feature class, only attributes defined in 'Attributes' or 'GroupBy' can be used.</value>
  </data>
  <data name="TrDissolve_Constraint" xml:space="preserve">
    <value>Only feature that fulfill constraint between each other are dissolved</value>
  </data>
  <data name="TrDissolve_CreateMultipartFeatures" xml:space="preserve">
    <value>(Default = false)
- false: create separate features when 3 or more features are connected. Only connections with 2 features are dissolved.
- true: create multipart features for all connected source features.</value>
  </data>
  <data name="TrDissolve_featureClass" xml:space="preserve">
    <value>Line feature class to dissolve</value>
  </data>
  <data name="TrDissolve_GroupBy" xml:space="preserve">
    <value>Group features by 'GroupBy' before dissolving
In the resulting feature class, only attributes defined in 'Attributes' or 'GroupBy' can be used.</value>
  </data>
  <data name="TrDissolve_NeighborSearchOption" xml:space="preserve">
    <value>(Default = Tile)
-Tile: dissolve features only within the current tile
- All: if features start/end outside tile, load additional connected features (recursively)</value>
  </data>
  <data name="TrDissolve_SearchDistance" xml:space="preserve">
    <value>Additonal distance to cache 'featureClass' features per tile</value>
  </data>
  <data name="TrFootprint_0" xml:space="preserve">
    <value>Transforms multipatches to polygons by taking their footprints</value>
  </data>
  <data name="TrFootprint_multipatchClass" xml:space="preserve">
    <value>multipatch feature class to transform</value>
  </data>
  <data name="TrGeometryToPoints_0" xml:space="preserve">
    <value>Transforms geometries to points. The transformed feature class has the attribute PartIndex and VertexIndex. These fields index from which polygon part the transformed polygon part was generated</value>
  </data>
  <data name="TrGeometryToPoints_component" xml:space="preserve">
    <value>GeometryComponent to extract</value>
  </data>
  <data name="TrGeometryToPoints_featureClass" xml:space="preserve">
    <value>multipoint, line, polygon or multpatch class to transform</value>
  </data>
  <data name="TrGeometryTransform_Attributes" xml:space="preserve">
    <value>Attributes that are copied from source featureclass to resulting featureclass</value>
  </data>
  <data name="TrIntersect_0" xml:space="preserve">
    <value>Transforms features of 'intersected' by intersecting them with features from 'intersecting'.
If intersected is a line class and intersecting is a polygon class, then the resulting feature class has an attribute 'PartIntersected' which contains the (resultingFeature.Shape.Length / intersectedFeature.Shape.Length)</value>
  </data>
  <data name="TrIntersect_intersected" xml:space="preserve">
    <value>Feature class. The attributes of 'intersected' can be accessed by 't0.&lt;field&gt;' in the resulting featureClass</value>
  </data>
  <data name="TrIntersect_intersecting" xml:space="preserve">
    <value>Feature class. The attributes of 'intersecting' can be accessed by 't1.&lt;field&gt;' in the resulting featureClass</value>
  </data>
  <data name="TrLineToPolygon_0" xml:space="preserve">
    <value>Transforms closed lines of 'closedLineClass' to polygons</value>
  </data>
  <data name="TrLineToPolygon_closedLineClass" xml:space="preserve">
    <value>line feature class to transform</value>
  </data>
  <data name="TrLineToPolygon_PolylineUsage" xml:space="preserve">
    <value>Defines how to handle not closed lines
- AsPolygonIfClosedElseIgnore (default) : ignore not closed lines</value>
  </data>
  <data name="TrMakeTable_0" xml:space="preserve">
    <value>Creates a table from an existing table or view in the database. This allows using tables that would otherwise not be usable because they have not been harvested as datasets in the data dictionary. Typical examples are:
- Association tables in many-to-many relationship classes
- Tables or views that are not part of the geodatabase.
If the table is part of the geodatabase and registered as versioned it will be opened from the same version as the base table.</value>
  </data>
  <data name="TrMakeTable_1" xml:space="preserve">
    <value>Creates a table from an SQL statement directly evaluated in the RDBMS. The same restrictions apply as for ArcGIS 'query layers'. For example, versioned data cannot be accessed, only the raw tables in the database including tables that are not registered as part of the geodatabase.</value>
  </data>
  <data name="TrMakeTable_baseTable" xml:space="preserve">
    <value>A table from the same data model. This table will be used to determine the workspace of the table.</value>
  </data>
  <data name="TrMakeTable_objectIdField" xml:space="preserve">
    <value>The field name containing the non-null and unique values to be used as identifier.</value>
  </data>
  <data name="TrMakeTable_sql" xml:space="preserve">
    <value>The SQL statement to be evaluated in the database. Example: SELECT ID, REGION, LAUF_NR, STATUS FROM TLM.GEWISS_LAUF_REGION WHERE REGION &lt;&gt; 'LI' AND LAUF_NR IN (SELECT LAUF_NR FROM TLM.GEWISS_LAUF_EXTERNAL WHERE OWNER = 'KANTON')</value>
  </data>
  <data name="TrMakeTable_viewOrTableName" xml:space="preserve">
    <value>The name of the database object to be created and made usable as table.</value>
  </data>
  <data name="TrCombinedFilter_0" xml:space="preserve">
    <value>Creates a filtered feature class based on several other filters that use the same 'featureClassToFilter'.</value>
  </data>
  <data name="TrCombinedFilter_expression" xml:space="preserve">
    <value>An expression that allows combining input filters with AND or OR. An input filter which is passed by a feature evaluates to 'true', a filter that excludes a feature evaluates to 'false'. 
The input filters are referenced by the transformer configuration name. If not specified, all input filters are combined with AND, i.e. the feature must pass all filters to be in the result.
Example to get all islands in Bavaria: 
(islands_in_lakes OR islands_in_rivers) AND islands_in_bavaria
islands_in_lakes uses the OnlyContained transformer with 'containing' feature class Lakes (polygon)
islands_in_rivers uses the OnlyContained transformer with 'containing' feature class Rivers (polygon)
islands_in_bavaria uses the OnlyIntersecting transformer with 'intersecting' feature class States (polygon) with constraint NAME = 'Bayern'</value>
  </data>
  <data name="TrCombinedFilter_featureClassToFilter" xml:space="preserve">
    <value>The feature class to be filtered.</value>
  </data>
  <data name="TrCombinedFilter_inputFilters" xml:space="preserve">
    <value>The filters which should be checked to determine if a feature passes the filter. By default, a feature passes the filter if it passes all input filters.</value>
  </data>
  <data name="TrMultilineToLine_0" xml:space="preserve">
    <value>Transforms multipart lines to single lines. The transformed feature class has the attribute PartIndex. This field index from which line part the transformed line was generated</value>
  </data>
  <data name="TrMultilineToLine_featureClass" xml:space="preserve">
    <value>line feature class to transform</value>
  </data>
  <data name="TrMultipolygonToPolygon_0" xml:space="preserve">
    <value>Transforms multipart polygons to single polygons. The transformed feature class has the attributes OuterRingIndex and InnerRingIndex. These fields index from which polygon part the transformed polygon was generated.
The transformed feature class has also the attributes of 'featureClass', which can be accessed by 't0.&lt;fieldName&gt;'.</value>
  </data>
  <data name="TrMultipolygonToPolygon_featureClass" xml:space="preserve">
    <value>polygon feature class to transform</value>
  </data>
  <data name="TrMultipolygonToPolygon_TransformedParts" xml:space="preserve">
    <value>Default = SinglePolygons
-SinglePolygon: converts multi polygon to single polygons (Remark: InnerRingIndex = -2)
-OuterRings: converts all out rings to polygons (Remark: InnerRingIndex = -1)
-InnerRings: converts all inner rings to polygons
-AllRings: converts all rings to polygons (Remark: polygons generated from outer rings: InnerRingIndex = -1)</value>
  </data>
  <data name="TrOnlyContainedFeatures_0" xml:space="preserve">
    <value>Creates a filtered feature class containing only the features that are contained within features from 'containing'. The resulting feature class has the same properties and attributes as 'featureClassToFilter'.</value>
  </data>
  <data name="TrOnlyContainedFeatures_containing" xml:space="preserve">
    <value>The features used to check if they contain the features to be filtered.</value>
  </data>
  <data name="TrOnlyContainedFeatures_featureClassToFilter" xml:space="preserve">
    <value>The feature class to be filtered.</value>
  </data>
  <data name="TrOnlyIntersectingFeatures_0" xml:space="preserve">
    <value>Creates a filtered feature class containing only the features that intersect features from 'intersecting'.  The resulting feature class has the same properties and attributes as 'featureClassToFilter'.</value>
  </data>
  <data name="TrOnlyIntersectingFeatures_featureClassToFilter" xml:space="preserve">
    <value>The feature class to be filtered.</value>
  </data>
  <data name="TrOnlyIntersectingFeatures_intersecting" xml:space="preserve">
    <value>The features used to check if they intersect the features to be filtered.</value>
  </data>
  <data name="TrPolygonToLine_0" xml:space="preserve">
    <value>Transform polygon to line by taking the boundary of the polygons in 'featureClass'.
The transformed feature class has also the attributes of 'featureClass', which can be accessed by 't0.&lt;fieldName&gt;'.</value>
  </data>
  <data name="TrPolygonToLine_featureClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="TrSpatialJoin_0" xml:space="preserve">
    <value>Transforms features of 't0' and features of 't1' to features, with shape of 't0' if they intersect.</value>
  </data>
  <data name="TrSpatialJoin_Constraint" xml:space="preserve">
    <value>Constraint on spatially joined features. Only spatially joined feature pairs that fulfill the constraint will be transformed to resulting features.
The involved features are aliased using "T0" and T1".
Example: T0.Level = T1.Level</value>
  </data>
  <data name="TrSpatialJoin_Grouped" xml:space="preserve">
    <value>Default = false.
If false: create one feature for each (t0,t1)-feature pair that intersects
if true: create one feature for each feature in 't0', that intersects any feature of 't1'</value>
  </data>
  <data name="TrSpatialJoin_NeighborSearchOption" xml:space="preserve">
    <value>(Default = Tile)
-Tile: join features only within the current tile
- All: if features lie partially outside tile, load additional connected features </value>
  </data>
  <data name="TrSpatialJoin_OuterJoin" xml:space="preserve">
    <value>Default = false.Left outer Join.
If true: transform features from t0-features that have no spatial relation to any feature of t1
If false: ignore features from t0 that have no spatial relation to any feature of t1</value>
  </data>
  <data name="TrSpatialJoin_t0" xml:space="preserve">
    <value>Feature class that provides the shape for the new features</value>
  </data>
  <data name="TrSpatialJoin_T0Attributes" xml:space="preserve">
    <value>Attributes of 't0' that are transfered to transformed feature class. Can be used with alias, i.e. 'TOPGIS_TLM.TLM_GEWAESSER_LAUF.LAUF_NR AS T1_LAUF_NR'.
In the resulting feature class, only attributes defined in T0Attributes or T1Attributes can be used. </value>
  </data>
  <data name="TrSpatialJoin_t1" xml:space="preserve">
    <value>Feature class to join</value>
  </data>
  <data name="TrSpatialJoin_T1Attributes" xml:space="preserve">
    <value>See T0Attributes.
If 'Grouped'=true, the attributes must be defined by Group-Expressions like COUNT(),MIN(),MAX()... 
Remark: Group expressions can only containt a single field expression. If a more complex expression is needed, use the parameter T1CalcAttributes.
Example: Count the number of joined features with a specific objecttype 'x' would be: 
T1CalcAttributes: "IIF(objecttype='x',1,0) AS X_VALUE"
T1Attributes: "SUM(X_VALUE) AS X_COUNT"</value>
  </data>
  <data name="TrSpatialJoin_T1CalcAttributes" xml:space="preserve">
    <value>Calculations with attributes of 't1' that are used in Group-Expressions.
See T1Attributes</value>
  </data>
  <data name="TrTableJoinInMemory_0" xml:space="preserve">
    <value>Creates a joined table with the fields from 'leftTable' and 'rightTable'.</value>
  </data>
  <data name="TrTableJoinInMemory_joinType" xml:space="preserve">
    <value>The type of join. Currently inner joins and left joins are supported.</value>
  </data>
  <data name="TrTableJoinInMemory_leftTable" xml:space="preserve">
    <value>The left table in the join. Its OBJECTID field will be used in the result table. If it is a FeatureClass its shape field it will be used in the result FeatureClass.</value>
  </data>
  <data name="TrTableJoinInMemory_leftTableKey" xml:space="preserve">
    <value>The key field in the left table.</value>
  </data>
  <data name="TrTableJoinInMemory_manyToManyTable" xml:space="preserve">
    <value>The association / bridge table for a many-to-many join.</value>
  </data>
  <data name="TrTableJoinInMemory_manyToManyTableLeftKey" xml:space="preserve">
    <value>The key field in the many-to-many association table referencing the leftTableKey.</value>
  </data>
  <data name="TrTableJoinInMemory_manyToManyTableRightKey" xml:space="preserve">
    <value>The key field in the many-to-many association table referencing the rightTableKey.</value>
  </data>
  <data name="TrTableJoinInMemory_rightTable" xml:space="preserve">
    <value>The right table in the join.</value>
  </data>
  <data name="TrTableJoinInMemory_rightTableKey" xml:space="preserve">
    <value>The key field in the right table.</value>
  </data>
  <data name="TrTableJoin_0" xml:space="preserve">
    <value>Transforms table 't0' and table 't1', which must be related by 'relationName', to a joined table</value>
  </data>
  <data name="TrTableJoin_joinType" xml:space="preserve">
    <value>JoinType</value>
  </data>
  <data name="TrTableJoin_relationName" xml:space="preserve">
    <value>name of existing relation between 't0' and 't1'</value>
  </data>
  <data name="TrTableJoin_t0" xml:space="preserve">
    <value>table to join with 't1'</value>
  </data>
  <data name="TrTableJoin_t1" xml:space="preserve">
    <value>table to join with 'leftTable'</value>
  </data>
  <data name="TrOnlyDisjointFeatures_0" xml:space="preserve">
    <value>Creates a filtered feature class containing only the features that are disjoint from features from 'disjoint'. Features that intersect any feature from 'disjoint' are filtered out. The resulting feature class has the same properties and attributes as 'featureClassToFilter'.</value>
  </data>
  <data name="TrOnlyDisjointFeatures_disjoint" xml:space="preserve">
    <value>The features used to check if they are disjoint from the features to be filtered.</value>
  </data>
  <data name="TrOnlyDisjointFeatures_featureClassToFilter" xml:space="preserve">
    <value>The feature class to be filtered.</value>
  </data>
</root>
