<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="QaDangleFactory" xml:space="preserve">
    <value>Finds all start/end points in 'polylineClasses' that connect to no other start/end point
Remark: The feature classes in 'polylineClasses' must have the same spatial reference</value>
  </data>
  <data name="QaDangleFactory_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaDatasetConstraintFactory" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill the constraints</value>
  </data>
  <data name="QaDatasetConstraintFactory_constraint" xml:space="preserve">
    <value>constraints to check. If a constraint starts with '+', the constraint is a subconstraint</value>
  </data>
  <data name="QaDatasetConstraintFactory_table" xml:space="preserve">
    <value>table to check</value>
  </data>
  <data name="QaGdbConstraintFactory" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill the attribute rules that are defined in the geodatabase</value>
  </data>
  <data name="QaGdbConstraintFactory_table" xml:space="preserve">
    <value>table with subtypes and domains</value>
  </data>
  <data name="QaLineConnection" xml:space="preserve">
    <value>Finds all connected features in 'featureClasses' that do not correspond with the 'rules'.
'featureClasses' can consist of line and point featureclasses. 'rules' are checked at all distinct points that exist as start/endpoint (line featureclasses) or points (point featureclasses).
Remark: the feature classes in 'featureClasses' must have the same spatial reference. 
The rules are processed in ordered direction. 
If the involved features correspond to no rule, they are reported.

One rule consists out of one expression for each featureClass.
Each expression is either null or has a selection expression.
Additionally, a expression can have variable declarations separated by ";". 
Optionally, one expression of a rule can have count condition (separeted by ";"), where the declared variables can be checked. 

A selection expression is a constraint on the corresponding featureclass (Example: "ObjektArt IN (x,y)"). If any feature connected at a point does not fulfill the selection expression for the corresponding featureclass, the corresponding rule is considered invalid and the next rules are checked for validity.

A variable expression is formatted "&lt;variablename&gt;:&lt;count expression&gt;" (Example: "v1:Objektart=r"). The value of the variable is equal the count of the features at a point that fulfill the &lt;count expression&gt; (for the corresponding feature Class).
For polyline featureclasses, an additional attribute "_StartsIn" is available in the count expression. The attribute value is true, if the FromPoint of the polyline lies at the point, and false, if the ToPoint lies at the point. Remark: If the FromPoint and ToPoint of a polyline are coincident, the polyline corresponds to two features in that point, one with _StartsIn=true and one with _StartsIn=false.  

A count expression checks if the variables fulfill a condition (Example: "v1 =1 AND v2=1", where v1, v2 are declared variables). If the count expression is false, the corresponding rule is considered invalid and the next rules are checked for validity. A count expression can /should use all variables declared in any expression of the corresponding rule. If a variable is not use in the count expression, the variable can be ommitted.

Example:
featureClasses: A, B
rules:
{
  { "ObjektArt IN (x,y)", "ObjektArt IN (u,v)" }, 
      // Meaning: all involved features belong either to A with ObjektArt in (x,y) or to B with ObjektArt in (u,v)

  { "ObjektArt = z", null },
     // Meaning: No B-Feature must touch any A-Feature with ObjektArt = z

  { null, "ObjektArt = t" },
     // Meaning: no A-Feature must touch any B-Feature with ObjektArt = t

  { "true;v1:ObjektArt=r;v2:Objektart=s;", "ObjektArt in (u,v);v1 =1 AND v2=1" }
     // Meaning: all feature of A and the features of B in (u,v) can be involved. Additionally, the count of A.ObjektArt =r must be 1 and the count of A.ObjektArt=s must be 1
}</value>
  </data>
  <data name="QaLineConnection_featureClasses" xml:space="preserve">
    <value>polyline or point feature classes</value>
  </data>
  <data name="QaLineConnection_rules" xml:space="preserve">
    <value>list of rules. Must be a multiple of the number of 'featureClasses'</value>
  </data>
  <data name="QaRelConstraint" xml:space="preserve">
    <value>Finds all rows in the joined table that do not fulfill 'constraint'</value>
  </data>
  <data name="QaRelConstraint_constraint" xml:space="preserve">
    <value>constraints to check. If a constraint starts with '+', the constraint is a subconstraint</value>
  </data>
  <data name="QaRelConstraint_join" xml:space="preserve">
    <value>join type. The first table of the 'relationTables' is left table, the second table is right table</value>
  </data>
  <data name="QaRelConstraint_relation" xml:space="preserve">
    <value>name of the relation</value>
  </data>
  <data name="QaRelConstraint_relationTables" xml:space="preserve">
    <value>tables of relation</value>
  </data>
  <data name="QaRelConstraint_ApplyFilterExpressionsInDatabase" xml:space="preserve">
    <value>Indicates if the filter expressions of the joined datasets are applied in the database. If False, the filter expressions are applied on the client, 
using the SQL dialect used by the QA framework, which provides cross-database compatibility. For large datasets, applying the filter expressions 
in the database may provide significant performance gains. However, this requires the filter expression to conform to the SQL syntax of the database.
Note that constraints are always applied on the client, expecting the SQL dialect used by the QA framework.
    </value>
  </data>
  <data name="QaRelGroupConnected" xml:space="preserve">
    <value>Find errors in checking if polylines of a joined table with same attributes are connected</value>
  </data>
  <data name="QaRelGroupConnected_allowedShape" xml:space="preserve">
    <value>indication of allowed shape types (combinations are possible):

Cycles (1): Circular connected lines are allowed
Branches (2): Branching lines are allowed, that means common start/end points of 3 or more lines
InsideBranches (4): A branch toward the inside of a circular area may exist</value>
  </data>
  <data name="QaRelGroupConnected_groupBy" xml:space="preserve">
    <value>a list of all field names that define a key. Features with the same key are tested to be connected</value>
  </data>
  <data name="QaRelGroupConnected_join" xml:space="preserve">
    <value>join type. The first table of the 'relationTables' is left table, the second table is right table</value>
  </data>
  <data name="QaRelGroupConnected_relation" xml:space="preserve">
    <value>name of the relation</value>
  </data>
  <data name="QaRelGroupConnected_relationTables" xml:space="preserve">
    <value>tables of relation</value>
  </data>
  <data name="QaRelUnique" xml:space="preserve">
    <value>Find all none unique rows in a joined table</value>
  </data>
  <data name="QaRelUnique_join" xml:space="preserve">
    <value>join type. The first table of the 'relationTables' is left table, the second table is right table</value>
  </data>
  <data name="QaRelUnique_maxRows" xml:space="preserve">
    <value>maximum number of rows in memory. If less or equal 0, default value is used</value>
  </data>
  <data name="QaRelUnique_relation" xml:space="preserve">
    <value>name of the relation</value>
  </data>
  <data name="QaRelUnique_relationTables" xml:space="preserve">
    <value>tables of relation</value>
  </data>
  <data name="QaRelUnique_unique" xml:space="preserve">
    <value>attributes for unique constraint (separated by ",", an index on the first unique attribute must exist)</value>
  </data>
  <data name="QaRelGroupConstraints" xml:space="preserve">
    <value>Checks if the number of distinct values of an expression (which may be a single field or a more complex expression involving field concatenation, value translation, substring extraction etc.) within groups defined by a 'group by' expression (which also may be a single field or a more complex expression on fields) does not exceed an allowed maximum value. The expressions are evaluated in a joined view of two tables.</value>
  </data>
  <data name="QaConstraintsListFactory" xml:space="preserve">
    <value>Finds rows in 'table' based on a list of expressions defined in another table. The expression table can be filtered to a subset of expressions relevant for the verified table.</value>
  </data>
  <data name="QaConstraintsListFactory_constraintsTable" xml:space="preserve">
    <value>The table that contains the list of constraints</value>
  </data>
  <data name="QaConstraintsListFactory_descriptionField" xml:space="preserve">
    <value>An optional field name that contains a description of the expression. If an error is reported, the error description includes this description text.</value>
  </data>
  <data name="QaConstraintsListFactory_expressionField" xml:space="preserve">
    <value>The name of the field that contains the expression to check</value>
  </data>
  <data name="QaConstraintsListFactory_expressionIsError" xml:space="preserve">
    <value>If 'true', the expressions indicate error situations. In this case the row must not fulfill the expression to be correct. If 'false', the expressions are treated as constraints that must be fulfilled by a row to be correct.</value>
  </data>
  <data name="QaConstraintsListFactory_table" xml:space="preserve">
    <value>The table to verify</value>
  </data>
  <data name="QaRelLineGroupConstraints" xml:space="preserve">
    <value>Find errors in checking if connected polylines of a joined table with same attributes related to 'groupBy' meet the conditions defined by the parameters</value>
  </data>
  <data name="QaRelLineGroupConstraints_GroupCondition" xml:space="preserve">
    <value>Only groups that fulfill 'GroupCondition' are tested.</value>
  </data>
  <data name="QaGdbConstraintFactory_AllowNullValuesForCodedValueDomains" xml:space="preserve">
    <value>Indicates if NULL values for fields with a coded value domain are allowed</value>
  </data>
  <data name="QaGdbConstraintFactory_AllowNullValuesForRangeDomains" xml:space="preserve">
    <value>Indicates if NULL values for fields with a range domain are allowed</value>
  </data>
  <data name="QaRelMustBeNearOther" xml:space="preserve">
    <value>Finds all features in a joined table that are not closer than 'maximumDistance' to any feature of 'nearClasses', or for which nearby features in 'nearClasses' do exist, but a given comparison constraint is not fulfilled.
Note that errors can be reported only for features that are completely within the verified extent. Features that extend beyond the verified extent may have valid neighbors outside of the searched extent, and are therefore ignored.</value>
  </data>
  <data name="QaRelMustBeNearOther_join" xml:space="preserve">
    <value>join type. The first table of the 'relationTables' is left table, the second table is right table</value>
  </data>
  <data name="QaRelMustBeNearOther_relation" xml:space="preserve">
    <value>name of the relation</value>
  </data>
  <data name="QaRelMustBeNearOther_relationTables" xml:space="preserve">
    <value>tables of relation</value>
  </data>
  <data name="QaTopoNotNearPolyFactory" xml:space="preserve">
    <value>Find features of 'featureClass' that intersect 'reference' when buffered according to 'featuresubtypeRules'.

Remark: For line ends that are not coincident to any other line end (=dangles), a flat end buffer is used.

Remark: The configuration can be exported/imported to/from a csv-File for easier configuration.
if &lt;referenceSubtypes&gt; and &lt;featuresubtypeRules&gt; are empty, a matrix with all available subtypes is created when exporting the quality condition.</value>
  </data>
  <data name="QaTopoNotNearPolyFactory_featureClass" xml:space="preserve">
    <value>line featureClass</value>
  </data>
  <data name="QaTopoNotNearPolyFactory_featuresubtypeRules" xml:space="preserve">
    <value>rules defining buffer and valid overlaps. 
Each rule is formatted as follows:

&lt;subtypecode&gt;;&lt;default near distance&gt;;&lt;right side distance&gt;;[&lt;allowedOverlaps&gt;]

with
&lt;subtypeCode&gt; must be a subtype code of 'featureClass'
&lt;default near distance&gt;: minimum distance that a feature with subtype &lt;subtypecode&gt; must be away from relevant features of 'reference'. For the right side of the feature, this value may be overridden by &lt;right side distance&gt;. 
&lt;right side distance&gt;: minimum distance that the right side of a feature with subtype &lt;subtypecode&gt; must be away from relevant features of 'reference'. If no value is provided, &lt;default near distance&gt; is used for both sides.
&lt;overlaps&gt;: must have the same number of members as &lt;referenceSubtypes&gt;.
   0 : overlapping &lt;reference&gt;-polygons with corresponding subtype is allowed.
  -1: overlapping &lt;reference&gt;-polygons with corresponding subtype is not allowed. Remark: x can be used instead of -1 in export/import csv-File.</value>
  </data>
  <data name="QaTopoNotNearPolyFactory_reference" xml:space="preserve">
    <value>polygon featureClass</value>
  </data>
  <data name="QaTopoNotNearPolyFactory_referenceSubtypes" xml:space="preserve">
    <value>test relevant subtype codes of 'reference'. features with subtypes that are not in 'referenceSubtypes' are not tested.</value>
  </data>
  <data name="QaGdbConstraintFactory_Fields" xml:space="preserve">
    <value>list of fields to check. If defined, only field values belonging to 'fields' get validated. Otherwise, all field values get validated.</value>
  </data>
</root>