using System;
using System.ComponentModel;
using System.Reflection;
using System.Windows.Forms;
using ProSuite.Commons.Essentials.CodeAnnotations;

namespace ProSuite.Commons.UI.WinForms.Controls
{
	/// <summary>
	/// When targeting .NET 3.5 AND .NET 4.x, use this class instead of
	/// the WinForms <see cref="System.Windows.Forms.SplitContainer"/>.
	/// It works around a backwards-compatibility problem:
	/// SplitContainer code generated by VS Designer for .NET 4.x fails
	/// on .NET 3.5 at runtime with an InvalidCastException.
	/// </summary>
	/// <remarks>
	/// System.ComponentModel.ISupportInitialize exists since .NET 1.1.
	/// <para/>
	/// In .NET 4.0 and later, SplitContainer implements ISupportInitialize
	/// and the VS Designer generates casts to ISupportInitialize (not as an
	/// optimization, but to work around an issue with setting properties
	/// in alphabetical order on SplitContainer).
	/// <para/>
	/// In .NET pre 4.0 SplitContainer does NOT implement ISupportInitialize!
	/// Designer code generated for .NET 4.0 or later will fail on .NET 3.5
	/// or earlier with an InvalidCastException!
	/// <para/>
	/// The troubling lines of code are in the InitializeComponent() method: 
	/// ((System.ComponentModel.ISupportInitialize)(this._splitContainer)).BeginInit();
	/// ((System.ComponentModel.ISupportInitialize)(this._splitContainer)).EndInit();
	/// <para/>
	/// See also the article below; the essence is in the comment by Ed Gadziemski:
	/// https://www.codeproject.com/tips/356323/isupportinitialize-begininit-problems
	/// Other than in the article, our approach uses reflection.
	/// </remarks>
	public class SplitContainerEx : SplitContainer, ISupportInitialize
	{
		private bool _initializing;

		private int _newPanel1MinSize;
		private int _newPanel2MinSize;
		private int _newSplitterWidth;

		public SplitContainerEx()
		{
			_initializing = false;

			_newPanel1MinSize = base.Panel1MinSize;
			_newPanel2MinSize = base.Panel2MinSize;
			_newSplitterWidth = base.SplitterWidth;
		}

		// Base class properties are not virtual: cannot override,
		// have to hide using "new" keyword. Beware that hiding method
		// is only called if invoked through this subclass at compile-time!

		public new int Panel1MinSize
		{
			get { return base.Panel1MinSize; }
			set
			{
				_newPanel1MinSize = value;

				if (value != base.Panel1MinSize && ! _initializing)
				{
					base.Panel1MinSize = value;
				}
			}
		}

		public new int Panel2MinSize
		{
			get { return base.Panel2MinSize; }
			set
			{
				_newPanel2MinSize = value;

				if (value != base.Panel2MinSize && ! _initializing)
				{
					base.Panel2MinSize = value;
				}
			}
		}

		public new int SplitterWidth
		{
			get { return base.SplitterWidth; }
			set
			{
				_newSplitterWidth = value;

				if (value != base.SplitterWidth && ! _initializing)
				{
					base.SplitterWidth = value;
				}
			}
		}

		#region ISupportInitialize

		void ISupportInitialize.BeginInit()
		{
			Type implementingType = GetType().BaseType;
			var method = FindSupportInitializeMethod(implementingType, "BeginInit");

			if (method != null)
			{
				method.Invoke(this, null);
			}
			else
			{
				// Base class has no ISupportInitialize.BeginInit; emulate!

				_initializing = true;

				_newPanel1MinSize = base.Panel1MinSize;
				_newPanel2MinSize = base.Panel2MinSize;
				_newSplitterWidth = base.SplitterWidth;
			}
		}

		void ISupportInitialize.EndInit()
		{
			Type implementingType = GetType().BaseType;
			var method = FindSupportInitializeMethod(implementingType, "EndInit");

			if (method != null)
			{
				method.Invoke(this, null);
			}
			else
			{
				// Base class has no ISupportInitialize.EndInit; emulate!
				// Just set the base properties now, knowing that base.Size has been
				// set (even though Size comes lexicographically after Panel1MinSize)

				_initializing = false;

				base.Panel1MinSize = _newPanel1MinSize;
				base.Panel2MinSize = _newPanel2MinSize;
				base.SplitterWidth = _newSplitterWidth;
			}
		}

		#endregion

		#region Private utilities

		[CanBeNull]
		private static MethodInfo FindSupportInitializeMethod(
			[CanBeNull] Type implementingType, [NotNull] string methodName)
		{
			if (implementingType == null)
			{
				return null;
			}

			// Find implicitly implemented interface method:
			var method = implementingType.GetMethod(methodName, new Type[0]);
			if (method != null)
			{
				return method;
			}

			// At .NET 4.x SplitContainer implements ISupportInitialize
			// via public methods. Should it ever change to explicit
			// interface implementation, here is how to get it: 

			string interfaceName = typeof(ISupportInitialize).FullName;
			return implementingType.GetMethod(interfaceName,
			                                  BindingFlags.Instance | BindingFlags.NonPublic,
			                                  null, new Type[0], null);
		}

		#endregion
	}
}
