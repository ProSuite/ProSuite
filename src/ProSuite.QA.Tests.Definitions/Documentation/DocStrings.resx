<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Qa3dConstantZ_0" xml:space="preserve">
    <value>Finds all points in 'featureClass' with a Z range larger than 'tolerance'</value>
  </data>
  <data name="Qa3dConstantZ_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class with Z values</value>
  </data>
  <data name="Qa3dConstantZ_tolerance" xml:space="preserve">
    <value>maximum allowed Z range within the feature</value>
  </data>
  <data name="Qa3dMonoton_0" xml:space="preserve">
    <value>Finds all line segments in 'featureClass' that do not correspond to 'type'</value>
  </data>
  <data name="Qa3dMonoton_constantAllowed" xml:space="preserve">
    <value>if segments with constant height are valid (only applicable if 'type' != Constant)</value>
  </data>
  <data name="Qa3dMonoton_featureClass" xml:space="preserve">
    <value>polyline or (for 'type' = Constant) polygon feature class</value>
  </data>
  <data name="Qa3dMonoton_type" xml:space="preserve">
    <value>Expected slope property. If type = MonotonType.Monotonous, the type gets defined for each part by the height difference from its start to its end point</value>
  </data>
  <data name="Qa3dPipe_0" xml:space="preserve">
    <value>Finds all line segments in 'featureClass' that differ more than 'limit' from 'terrain'

Remark: The feature classes in 'featureClass' and 'terrain' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfacePipe_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class with heights</value>
  </data>
  <data name="QaSurfacePipe_limit" xml:space="preserve">
    <value>maximum allowed difference (in z-units)</value>
  </data>
  <data name="QaSurfacePipe_terrain" xml:space="preserve">
    <value>terrain to compare</value>
  </data>
  <data name="Qa3dSmoothing_0" xml:space="preserve">
    <value>Finds all points or vertices in 'featureClass' that differ more than 'limit' from 'terrain'

Remark: The feature classes in 'featureClass' and 'terrain' must have the same spatial reference.</value>
  </data>
  <data name="Qa3dSmoothing_directionOfError" xml:space="preserve">
    <value>'greater' : the difference must be larger than limit
'smaller' : the difference must be smaller than limit</value>
  </data>
  <data name="QaSurfaceVertex_featureClass" xml:space="preserve">
    <value>feature class with heights</value>
  </data>
  <data name="QaSurfaceVertex_limit" xml:space="preserve">
    <value>limit (in z-units)</value>
  </data>
  <data name="QaSurfaceVertex_mustBeLarger" xml:space="preserve">
    <value>true : the difference must be larger than limit
false : the difference must be smaller than limit</value>
  </data>
  <data name="Qa3dSmoothing_terrain" xml:space="preserve">
    <value>terrain to compare</value>
  </data>
  <data name="QaSurfaceVertex_zOffsetConstraint" xml:space="preserve">
    <value>AboveLimit : All z-values must be above surface height + 'limit'
BelowLimit : All z-values must be below surface height + 'limit' (For underground, 'limit' must be &lt; 0)
WithinLimit: All z-values must be below surface height + 'limit' and above surface height - 'limit'
OutsideLimit: All z-values must be either above surface height + 'limit' or below surface height - 'limit'</value>
  </data>
  <data name="QaBorderSense_0" xml:space="preserve">
    <value>Finds features that are not involved in valid rings:
Checks if features in 'polylineClass' build rings and if the features in a ring are directed in clockwise / counterclockwise direction</value>
  </data>
  <data name="QaBorderSense_1" xml:space="preserve">
    <value>Finds features that are not involved in valid rings:
Checks if features in 'polylineClasses' build rings and if the features in a ring are directed in clockwise / counterclockwise direction

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaBorderSense_clockwise" xml:space="preserve">
    <value>indication if rings must be built in clockwise direction (true: features are ordered in clockwise direction)</value>
  </data>
  <data name="QaBorderSense_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaBorderSense_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaCentroids_0" xml:space="preserve">
    <value>Finds errors in point-line-polygon topology:
Checks if there is exactly one point from 'pointClass' within each polygon built by the features of 'polylineClass'

Remark: The feature classes in 'polylineClass' and 'pointClass' must have the same spatial reference.
The features of 'polylineClass' are not checked for intersections. Use QaLineIntersect to check</value>
  </data>
  <data name="QaCentroids_2" xml:space="preserve">
    <value>Finds errors in point-line-polygon topology:
Checks if there is exactly one point from 'pointClasses' within each polygon built by the features of 'polylineClasses'

Remark: All feature classes in 'polylineClasses' and 'pointClasses' must have the same spatial reference.
The features of 'polylineClasses' are not checked for intersections. Use QaLineIntersect to check</value>
  </data>
  <data name="QaCentroids_constraint" xml:space="preserve">
    <value>constraint on polygon. Border feature is aliased as "B", left polygon feature as "L" and right polygon feature as "R"
Example for constraint: "B.ObjektArt = x AND L.ObjektArt = R.ObjektArt"</value>
  </data>
  <data name="QaCentroids_pointClass" xml:space="preserve">
    <value>point feature class</value>
  </data>
  <data name="QaCentroids_pointClasses" xml:space="preserve">
    <value>point feature classes</value>
  </data>
  <data name="QaCentroids_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaCentroids_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaConnections_0" xml:space="preserve">
    <value>Finds all connected features in 'featureClasses' that do not correspond with the 'rules'.
'featureClasses' can consist of line and point featureclasses. 'rules' are checked at all distinct points that exist as start/endpoint (line featureclasses) or points (point featureclasses).

Remark: The feature classes in 'featureClasses' must have the same spatial reference. 
The rules are processed in ordered direction. 
If the involved features correspond to no rule, they are reported.

One rule consists out of one expression for each featureClass.
Each expression is either null or has a selection expression.
Additionally, a expression can have variable declarations separated by ";". 
Optionally, one expression of a rule can have count condition (separated by ";"), where the declared variables can be checked. 

A selection expression is a constraint on the corresponding featureclass (Example: "ObjektArt IN (x,y)"). If any feature connected at a point does not fulfill the selection expression for the corresponding featureclass, the corresponding rule is considered invalid and the next rules are checked for validity.

A variable expression is formatted "&lt;variablename&gt;:&lt;count expression&gt;" (Example: "v1:Objektart=r"). The value of the variable is equal the count of the features at a point that fulfill the &lt;count expression&gt; (for the corresponding feature Class).
For polyline featureclasses, an additional attribute "_StartsIn" is available in the count expression. The attribute value is true, if the FromPoint of the polyline lies at the point, and false, if the ToPoint lies at the point. Remark: If the FromPoint and ToPoint of a polyline are coincident, the polyline corresponds to two features in that point, one with _StartsIn=true and one with _StartsIn=false.  

A count expression checks if the variables fulfill a condition (Example: "v1 =1 AND v2=1", where v1, v2 are declared variables). If the count expression is false, the corresponding rule is considered invalid and the next rules are checked for validity. A count expression can /should use all variables declared in any expression of the corresponding rule. If a variable is not use in the count expression, the variable can be ommitted.

Example:
featureClasses: A, B
rules:
{
  { "ObjektArt IN (x,y)", "ObjektArt IN (u,v)" }, 
      // Meaning: all involved features belong either to A with ObjektArt in (x,y) or to B with ObjektArt in (u,v)

  { "ObjektArt = z", null },
     // Meaning: No B-Feature must touch any A-Feature with ObjektArt = z

  { null, "ObjektArt = t" },
     // Meaning: no A-Feature must touch any B-Feature with ObjektArt = t

  { "true;v1:ObjektArt=r;v2:Objektart=s;", "ObjektArt in (u,v);v1 =1 AND v2=1" }
     // Meaning: all feature of A and the features of B in (u,v) can be involved. Additionally, the count of A.ObjektArt =r must be 1 and the count of A.ObjektArt=s must be 1
}</value>
  </data>
  <data name="QaConnections_1" xml:space="preserve">
    <value>Finds all connected features in 'featureClass' that do not correspond with the 'rules'.
'featureClass' can be a polyline or point featureclasses. 'rules' are checked at all distinct points that exist as start/endpoint (polyline featureclass) or points (point featureclass).
The rules are processed in ordered direction. 
If the involved features correspond to no rule, they are reported.

One rule consists out of one expression for 'featureClass'.
Each expression has a selection expression.
Additionally, a expression can have variable declarations separated by ";". 
Optionally, one expression of a rule can have count condition (separated by ";"), where the declared variables can be checked. 

A selection expression is a constraint on the corresponding featureclass (Example: "ObjektArt IN (x,y)"). If any feature connected at a point does not fulfill the selection expression for the corresponding featureclass, the corresponding rule is considered invalid and the next rules are checked for validity.

A variable expression is formatted "&lt;variablename&gt;:&lt;count expression&gt;" (Example: "v1:Objektart=r"). The value of the variable is equal the count of the features at a point that fulfill the &lt;count expression&gt; (for the corresponding feature Class).
For polyline featureclasses, an additional attribute "_StartsIn" is available in the count expression. The attribute value is true, if the FromPoint of the polyline lies at the point, and false, if the ToPoint lies at the point. Remark: If the FromPoint and ToPoint of a polyline are coincident, the polyline corresponds to two features in that point, one with _StartsIn=true and one with _StartsIn=false.

A count expression checks if the variables fulfill a condition (Example: "v1 =1 AND v2=1", where v1, v2 are declared variables). If the count expression is false, the corresponding rule is considered invalid and the next rules are checked for validity. A count expression can /should use all variables declared in the corresponding rule. If a variable is not use in the count expression, the variable can be ommitted.

Example:
rules:
{
  { "ObjektArt IN (x,y)" }, 
      // Meaning: all involved features belong either to ObjektArt in (x,y)
  { "true;v1:ObjektArt=r;v2:Objektart=s;v1 =1 AND v2=1" }
     // Meaning: all features of A can be involved. Additionally, the count of ObjektArt =r must be 1 and the count of ObjektArt=s must be 1
}</value>
  </data>
  <data name="QaConnections_2" xml:space="preserve">
    <value>Finds all connected features in 'featureClasses' that do not correspond with the 'rules'.
'featureClasses' can consist of polyline and point featureclasses. 'rules' are checked at all distinct points that exist as start/endpoint (polyline featureclasses) or points (point featureclasses).

Remark: The feature classes in 'featureClasses' must have the same spatial reference. 
The rules are processed in ordered direction. 
If the involved features correspond to no rule, they are reported.
</value>
  </data>
  <data name="QaConnections_3" xml:space="preserve">
    <value>Finds all connected features in 'featureClass' that do not correspond with the 'rules'.
'featureClass' can be a polyline or point featureclasses. 'rules' are checked at all distinct points that exist as start/endpoint (polyline featureclass) or points (point featureclass).
The rules are processed in ordered direction. 
If the involved features correspond to no rule, they are reported.</value>
  </data>
  <data name="QaConnections_featureClass" xml:space="preserve">
    <value>involved feature class</value>
  </data>
  <data name="QaConnections_featureClasses" xml:space="preserve">
    <value>involved feature classes</value>
  </data>
  <data name="QaConnections_rules_0" xml:space="preserve">
    <value>list of rules. Each string[]-Array builds a rule. In each string[]-Array must be exactly n expressions, where n is the number of feature classes in 'featureClasses'</value>
  </data>
  <data name="QaConnections_rules_1" xml:space="preserve">
    <value>list of rules</value>
  </data>
  <data name="QaConnections_StartsIn" xml:space="preserve">
    <value>name of the boolean-Column containing the information about the direction of the line relative to the node</value>
  </data>
  <data name="QaConstraint_0" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill 'constraint'</value>
  </data>
  <data name="QaConstraint_1" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill the hierarchical 'constraints'</value>
  </data>
  <data name="QaConstraint_constraint" xml:space="preserve">
    <value>checked constraint</value>
  </data>
  <data name="QaConstraint_constraints" xml:space="preserve">
    <value>hierarchical list of constraints</value>
  </data>
  <data name="QaConstraint_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaContainsOther_0" xml:space="preserve">
    <value>Finds all features in 'isWithin' that are not contained by any feature in 'contains'
Remarks: All feature classes in 'contains' and 'isWithin' must have the same spatial reference</value>
  </data>
  <data name="QaContainsOther_contains_0" xml:space="preserve">
    <value>feature classes</value>
  </data>
  <data name="QaContainsOther_contains_1" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaContainsOther_isWithin_0" xml:space="preserve">
    <value>feature classes with features checked not to be contained by any feature of 'contains'</value>
  </data>
  <data name="QaContainsOther_isWithin_1" xml:space="preserve">
    <value>feature class with features checked not to be contained by any feature of 'contains'</value>
  </data>
  <data name="QaCrossesOther_0" xml:space="preserve">
    <value>Finds all features in 'crossingClasses' that are crossing any features of 'crossedClasses'

Remark: All feature classes in 'crossingClasses' and 'crossedClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaCrossesOther_crossedClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaCrossesOther_crossedClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaCrossesOther_crossingClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaCrossesOther_crossingClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaCurve_0" xml:space="preserve">
    <value>Finds segments in 'featureClass' that are not straight lines</value>
  </data>
  <data name="QaCurve_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaDuplicateGeometrySelf_0" xml:space="preserve">
    <value>Finds features with equal geometries in a feature class. Geometries for which the difference geometry is empty are considered duplicates. Z and M values are therefore ignored, and the XY tolerance of the spatial reference is applied.</value>
  </data>
  <data name="QaDuplicateGeometrySelf_1" xml:space="preserve">
    <value>Finds features with equal geometries in a feature class for which a given constraint is not fulfilled. Geometries for which the difference geometry is empty are considered duplicates. Z and M values are therefore ignored, and the XY tolerance of the spatial reference is applied.</value>
  </data>
  <data name="QaDuplicateGeometrySelf_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaDuplicateGeometrySelf_validDuplicateConstraint" xml:space="preserve">
    <value>Constraint on features with duplicate geometries. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaEmptyNotNullTextFields_0" xml:space="preserve">
    <value>Finds empty strings in non-nullable text fields</value>
  </data>
  <data name="QaEmptyNotNullTextFields_1" xml:space="preserve">
    <value>Finds empty or NULL strings in a list of text fields</value>
  </data>
  <data name="QaEmptyNotNullTextFields_notNullTextFields" xml:space="preserve">
    <value>text fields that should not contain NULL or empty string</value>
  </data>
  <data name="QaEmptyNotNullTextFields_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaExtent_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' where the largest extension of the bounding box is larger than 'limit'</value>
  </data>
  <data name="QaExtent_1" xml:space="preserve">
    <value>Finds all features or feature parts in 'featureClass' where the largest extension of the bounding box is larger than 'limit'.</value>
  </data>
  <data name="QaExtent_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaExtent_limit" xml:space="preserve">
    <value>maximum extension in (x,y)-units</value>
  </data>
  <data name="QaExtent_perPart" xml:space="preserve">
    <value>check for each part</value>
  </data>
  <data name="QaFlowLogic_0" xml:space="preserve">
    <value>Finds all (From/To-) points in 'polylineClass', that are not coincident with exactly one From-point</value>
  </data>
  <data name="QaFlowLogic_1" xml:space="preserve">
    <value>Finds all (From/To-) points in 'polylineClasses', that are not coincident with exactly one From-point

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaFlowLogic_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaFlowLogic_polylineClasses" xml:space="preserve">
    <value>polyline feature classes </value>
  </data>
  <data name="QaFullCoincidence_0" xml:space="preserve">
    <value>Finds all line parts in 'featureClass' that are further than 'near' from any feature of 'reference'

Remark: The feature classes in 'featureClass' and 'reference' must have the same spatial reference.</value>
  </data>
  <data name="QaFullCoincidence_2" xml:space="preserve">
    <value>Finds all line parts in 'featureClass' that are further than 'near' from any feature of 'references'

Remark: All feature classes in 'featureClass' and 'references' must have the same spatial reference.</value>
  </data>
  <data name="QaFullCoincidence_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaFullCoincidence_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaFullCoincidence_near" xml:space="preserve">
    <value>maximum allowed distance in (x,y)-units from 'featureClass' feature to any 'reference' feature</value>
  </data>
  <data name="QaFullCoincidence_reference" xml:space="preserve">
    <value>reference polyline or polygon feature class</value>
  </data>
  <data name="QaFullCoincidence_references" xml:space="preserve">
    <value>reference polyline or polygon feature classes</value>
  </data>
  <data name="QaFullCoincidence_tileSize" xml:space="preserve">
    <value>Note: this parameter is no longer used</value>
  </data>
  <data name="QaGdbConnectivity_0" xml:space="preserve">
    <value>Finds network connectivity problems in 'network' for a geometric network defined in the geodatabase.

Notes: 
- The errors correspond to network problem set calculated by CheckAndRepairConnectivity(). If the test is called while editing, edits may be made to repair the connectivity.
- For detecting inconsistencies in the logical network, consider using QaGdbNetworkElements.</value>
  </data>
  <data name="QaGdbConnectivity_network" xml:space="preserve">
    <value>network to check</value>
  </data>
  <data name="QaGdbConstraint_0" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill the attribute rules that are defined in the geodatabase

Remark: IAttributeRule.Validate() is used to check the rows.</value>
  </data>
  <data name="QaGdbConstraint_table" xml:space="preserve">
    <value>table to check</value>
  </data>
  <data name="QaGdbTopology_0" xml:space="preserve">
    <value>Finds all geodatabase topology errors in 'topology'. Consider using the other constructor for better support. This constructor is for backward-compatibility only.

Remark: If the topology has not been previously validated, the dirty areas are reported as issues.
The reported issues are copies of the error features of the topology's error features.</value>
  </data>
  <data name="QaGdbTopology_1" xml:space="preserve">
    <value>Finds all geodatabase topology errors in the topologies referenced by 'featureClasses'.

Remark: If a topology has not been previously validated, the dirty areas are reported as issues.
The reported issues are copies of the error features of the topology's error features.</value>
  </data>
  <data name="QaGdbTopology_topology" xml:space="preserve">
    <value>topology to check</value>
  </data>
  <data name="QaGdbTopology_featureClasses" xml:space="preserve">
    <value>feature classes that participate in a geodatabase topology</value>
  </data>
  <data name="QaGraphicConflict_0" xml:space="preserve">
    <value>Finds all graphic conflicts between 'layer' and 'conflictLayer'.

Remark: Internally uses GP tool 'Detect Graphic Conflict'.
The reported errors are copies of the conflict polygons returned by the GP tool.</value>
  </data>
  <data name="QaGraphicConflict_1" xml:space="preserve">
    <value>Finds all graphic conflicts between 'featureClass' ('layerRepresentation') and 'conflictClass' ('conflictRepresentation').

Remark: Internally uses GP tool 'Detect Graphic Conflict'.
The reported errors are copies of the conflict polygons returned by the GP tool.</value>
  </data>
  <data name="QaGraphicConflict_conflictClass" xml:space="preserve">
    <value>feature class having graphic conflicts</value>
  </data>
  <data name="QaGraphicConflict_conflictDistance" xml:space="preserve">
    <value>Size and unit (page units or map units) of GP tool parameter "conflict distance".
Example: 50 meters</value>
  </data>
  <data name="QaGraphicConflict_conflictLayer" xml:space="preserve">
    <value>feature layer using representation renderer having graphic conflicts</value>
  </data>
  <data name="QaGraphicConflict_conflictRepresentation" xml:space="preserve">
    <value>representation class name of 'conflictClass'</value>
  </data>
  <data name="QaGraphicConflict_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaGraphicConflict_layer" xml:space="preserve">
    <value>feature layer using representation renderer</value>
  </data>
  <data name="QaGraphicConflict_layerRepresentation" xml:space="preserve">
    <value>representation class name of 'featureClass'</value>
  </data>
  <data name="QaGraphicConflict_lineConnectionAllowance" xml:space="preserve">
    <value>Size and unit (page units or map units) of GP tool parameter "line connection allowance".
Example: 25 meters</value>
  </data>
  <data name="QaGraphicConflict_referenceScale" xml:space="preserve">
    <value>reference scale</value>
  </data>
  <data name="QaGraphicConflict_scratchWorkspace" xml:space="preserve">
    <value>scratch workspace where a temporary feature class can be created</value>
  </data>
  <data name="QaGroupConnected_0" xml:space="preserve">
    <value>Find errors in checking if polylines of 'polylineClass' with same attributes are connected. Reports disjoint line groups with ErrorReporting.ReferToFirstPart.</value>
  </data>
  <data name="QaGroupConnected_allowedShape" xml:space="preserve">
    <value>Indicates the allowed overall shape types for line groups:

- None: only linearly connected lines are allowed (no cycles or branches)
- Cycles: Circular connected lines are allowed
- Branches: Branching lines are allowed, that means common start/end points of 3 or more lines
- InsideBranches: A branch toward the inside of a circular area may exist
- CyclesAndBranches: Cycles and branches are allowed
- All: Cycles and branches and inside branches are allowed</value>
  </data>
  <data name="QaGroupConnected_groupBy" xml:space="preserve">
    <value>A list of all field names that define a key. Features with the same key are tested to be connected</value>
  </data>
  <data name="QaGroupConnected_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaInteriorIntersectsOther_0" xml:space="preserve">
    <value>Finds features in 'relatedClass' that have an interior intersection with a feature in 'featureClass'</value>
  </data>
  <data name="QaInteriorIntersectsOther_1" xml:space="preserve">
    <value>Finds pairs of features in 'featureClass' vs. 'relatedClass' that have an interior intersection, and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaInteriorIntersectsOther_2" xml:space="preserve">
    <value>Finds pairs of features in 'featureClasses' vs. 'relatedClasses' that have an interior intersection.</value>
  </data>
  <data name="QaInteriorIntersectsOther_3" xml:space="preserve">
    <value>Finds pairs of features in 'featureClasses' vs. 'relatedClasses' that have an interior intersection, and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaInteriorIntersectsOther_constraint" xml:space="preserve">
    <value>Constraint on a pair of features that have intersecting interiors. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" (featureClass) and "G2" (relatedClass).
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaInteriorIntersectsOther_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaInteriorIntersectsOther_featureClasses" xml:space="preserve">
    <value>feature classes</value>
  </data>
  <data name="QaInteriorIntersectsOther_relatedClass" xml:space="preserve">
    <value>The feature class to search for interior intersections with 'featureClass'.</value>
  </data>
  <data name="QaInteriorIntersectsOther_relatedClasses" xml:space="preserve">
    <value>The feature classes to search for interior intersections with features in 'featureClasses'.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_0" xml:space="preserve">
    <value>Finds all pairs of features in a feature class with intersecting interiors.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_1" xml:space="preserve">
    <value>Finds all pairs of features in a feature class with intersecting interiors, and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_2" xml:space="preserve">
    <value>Finds all pairs of features in a list of feature classes with intersecting interiors.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_constraint" xml:space="preserve">
    <value>Constraint on a pair of features that have intersecting interiors. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaInteriorIntersectsSelf_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaInteriorIntersectsSelf_featureClasses" xml:space="preserve">
    <value>The feature classes to check for interior intersections</value>
  </data>
  <data name="QaIntersectionMatrixOther_0" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that have a given spatial relationship with features in 'relatedClasses'. The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: All feature classes in 'featureClasses' and 'relatedClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixOther_1" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that have a given spatial relationship with features in 'relatedClasses', and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: All feature classes in 'featureClasses' and 'relatedClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixOther_2" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with features in 'relatedClass'. The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixOther_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with features in 'relatedClass', and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixOther_constraint" xml:space="preserve">
    <value>Constraint on features that are involved in the specified spatial relationship. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaIntersectionMatrixOther_featureClass" xml:space="preserve">
    <value>feature class which contains features to be checked against features in 'relatedClass'</value>
  </data>
  <data name="QaIntersectionMatrixOther_featureClasses" xml:space="preserve">
    <value>feature classes which contain features to be checked against features in 'relatedClasses'</value>
  </data>
  <data name="QaIntersectionMatrixOther_intersectionMatrix" xml:space="preserve">
    <value>9IM intersection matrix defining the spatial relationship representing an error. The matrix string consists of the 9 cells of the 3x3 intersection matrix, in the following sequence:

1. G1.interior G2.interior
2. G1.interior G2.boundary
3. G1.interior G2.exterior
4. G1.boundary G2.interior
5. G1.boundary G2.boundary
6. G1.boundary G2.exterior
7. G1.exterior G2.interior
8. G1.exterior G2.boundary
9. G1.exterior G2.exterior

Example: ****T**** (intersection of geometry boundaries)
For additional information, refer to the topic "Spatial Relationships" in the ArcGIS online help.</value>
  </data>
  <data name="QaIntersectionMatrixOther_relatedClass" xml:space="preserve">
    <value>feature class which contains features that may have an invalid spatial relationship with features in 'featureClass'</value>
  </data>
  <data name="QaIntersectionMatrixOther_relatedClasses" xml:space="preserve">
    <value>feature classes which contain features that may have an invalid spatial relationship with features in 'featureClasses'</value>
  </data>
  <data name="QaIntersectionMatrixSelf_0" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that have a given spatial relationship with other features in 'featureClasses' (including the feature class of the feature to be tested). The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_1" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that have a given spatial relationship with other features in 'featureClasses' (including the feature class of the feature to be tested), and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_2" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with other features in 'featureClass'. The spatial relationship of the error cases is defined by a 9IM intersection matrix.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with other features in 'featureClass', and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_constraint" xml:space="preserve">
    <value>Constraint on features that are involved in the specified spatial relationship. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaIntersectionMatrixSelf_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaIntersectionMatrixSelf_featureClasses" xml:space="preserve">
    <value>feature classes</value>
  </data>
  <data name="QaIntersectionMatrixSelf_intersectionMatrix" xml:space="preserve">
    <value>9IM intersection matrix defining the spatial relationship representing an error. The matrix string consists of the 9 cells of the 3x3 intersection matrix, in the following sequence:

1. G1.interior G2.interior
2. G1.interior G2.boundary
3. G1.interior G2.exterior
4. G1.boundary G2.interior
5. G1.boundary G2.boundary
6. G1.boundary G2.exterior
7. G1.exterior G2.interior
8. G1.exterior G2.boundary
9. G1.exterior G2.exterior

Example: ****T**** (intersection of geometry boundaries)
For additional information, refer to the topic "Spatial Relationships" in the ArcGIS online help.</value>
  </data>
  <data name="QaIntersectsOther_0" xml:space="preserve">
    <value>Finds all features in 'intersectingClasses' that intersect by any features of 'intersectedClasses'

Remark: All feature classes in 'intersectedClasses' and 'intersectingClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectsOther_intersectedClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaIntersectsOther_intersectingClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaIntersectsOther_intersectingClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaIntersectsOther_intersectedClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaIntersectsSelf_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' that intersect any feature in 'featureClass'</value>
  </data>
  <data name="QaIntersectsSelf_featureClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaIsCoveredByOther_0" xml:space="preserve">
    <value>Finds all features in 'covered' that are not fully covered by the features in 'covering'

Remarks: All feature classes in 'covered' and 'covering' must have the same spatial reference.</value>
  </data>
  <data name="QaIsCoveredByOther_1" xml:space="preserve">
    <value>Finds all features in 'covered' that are not fully covered by the features in 'covering'

Remarks: The feature classes in 'covered' and 'covering' must have the same spatial reference.</value>
  </data>
  <data name="QaIsCoveredByOther_4" xml:space="preserve">
    <value>Finds all features in 'covered' for which the specified geometry components are not fully covered by the specified geometry component of features in 'covering'.

The following geometry components are supported:

- EntireGeometry: the original feature geometry
- Boundary: supported for polygons and polylines. For polylines, the boundary consists of the start/end points of all parts. For polygons, it corresponds to the outlines of all polygon rings.
- Vertices: supported for polygons, polylines, multipatches and multiparts. The vertices of the geometry.
- LineEndPoints: supported for polylines. The start and end point of the entire polyline, i.e. the start point of the first path and the end point of the last path.
- LineStartPoint: supported for polylines. The start point of the entire polyline, i.e. the start point of the first path.
- LineEndPoint: supported for polylines. The end point of the entire polyline, i.e. the end point of the last path.
- Centroid: supported for polygons. The centroid point of the entire polygon.
- LabelPoint: supported for polygons. The label point of the entire polygon.
- InteriorVertices: supported for polylines. All line vertices except the start and end point of the entire polyline.

The number of geometry components in the list must be either 0 (in which case 'EntireGeometry' is used as default), 1 (in which case that component is used for all feature classes in the list) or equal to the number of feature classes. In that case, the components are assigned to the feature classes by their index position in the list.</value>
  </data>
  <data name="QaIsCoveredByOther_covered_0" xml:space="preserve">
    <value>feature classes with features that must be covered by features in 'covering'</value>
  </data>
  <data name="QaIsCoveredByOther_covered_1" xml:space="preserve">
    <value>feature class with features that must be covered by features in 'covering'</value>
  </data>
  <data name="QaIsCoveredByOther_covering_0" xml:space="preserve">
    <value>feature classes</value>
  </data>
  <data name="QaIsCoveredByOther_covering_1" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaIsCoveredByOther_coveringGeometryComponents_0" xml:space="preserve">
    <value>The geometry components for the covering feature classes.
If empty, then 'EntireGeometry' will be used. If one component is specified, it is used</value>
  </data>
  <data name="QaIsCoveredByOther_coveredGeometryComponents_0" xml:space="preserve">
    <value>The geometry components for the covered feature classes.</value>
  </data>
  <data name="QaLineIntersect_0" xml:space="preserve">
    <value>Finds all features in 'polylineClasses' that cross any other feature in 'polylineClasses'

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersect_1" xml:space="preserve">
    <value>Finds all features in 'polylineClass' that cross any other feature in 'polylineClass'</value>
  </data>
  <data name="QaLineIntersect_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaLineIntersect_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaLineIntersectAngle_0" xml:space="preserve">
    <value>Finds all intersection between lines of 'polylineClasses' where the intersection angle is smaller than 'limit'

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersectAngle_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaLineIntersectAngle_limit" xml:space="preserve">
    <value>minimum permitted angle (in 'AngularUnit', default value of 'AngularUnit' is radian)</value>
  </data>
  <data name="QaLineIntersectAngle_polylineClasses" xml:space="preserve">
    <value>polyline or polygon feature classes</value>
  </data>
  <data name="QaLineIntersectZ_0" xml:space="preserve">
    <value>Finds intersections of features in 'polylineClasses' where the height difference is smaller than 'limit'

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersectZ_1" xml:space="preserve">
    <value>Finds intersections of features in 'polylineClass' where the height difference is smaller than 'limit'</value>
  </data>
  <data name="QaLineIntersectZ_2" xml:space="preserve">
    <value>Finds intersections of features in 'polylineClass' where the height difference is smaller than 'limit' and 'constraint' is not fulfilled</value>
  </data>
  <data name="QaLineIntersectZ_3" xml:space="preserve">
    <value>Finds intersections of features in 'polylineClasses' where the height difference is smaller than 'limit' and 'constraint' is not fulfilled

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersectZ_constraint" xml:space="preserve">
    <value>constraint on features at intersection.
Upper feature is aliased as "U", lower feature as "L"
Example: U.EdgeLevel &gt; L.EdgeLevel

Remark: if 'limit' &lt;= 0, only 'constraint' is checked with "U", "L" arbitrarily assigned to features)</value>
  </data>
  <data name="QaLineIntersectZ_limit_0" xml:space="preserve">
    <value>minimum height difference in z-Units</value>
  </data>
  <data name="QaLineIntersectZ_limit_1" xml:space="preserve">
    <value>minimum height difference in z-Units.
if 'limit' &lt;= 0, only constraint is checked (in arbitrary order of the involved features)</value>
  </data>
  <data name="QaLineIntersectZ_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaLineIntersectZ_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaMaxArea_0" xml:space="preserve">
    <value>Finds all polygons in 'polygonClass' with areas larger than 'limit'</value>
  </data>
  <data name="QaMaxArea_1" xml:space="preserve">
    <value>Finds all parts in 'polygonClass' with areas larger than 'limit'. Parts are defined by perPart</value>
  </data>
  <data name="QaMaxArea_limit" xml:space="preserve">
    <value>maximum area in (x,y)-units</value>
  </data>
  <data name="QaMaxArea_perPart" xml:space="preserve">
    <value>Indicates if the area is checked for each ring (true) or for the entire feature (false)</value>
  </data>
  <data name="QaMaxArea_polygonClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="QaMaxLength_0" xml:space="preserve">
    <value>Finds all lines in 'featureClass' with length larger than 'limit'</value>
  </data>
  <data name="QaMaxLength_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaMaxLength_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaMaxLength_limit" xml:space="preserve">
    <value>maximum length in (x,y)-units</value>
  </data>
  <data name="QaMaxLength_perPart" xml:space="preserve">
    <value>check for each part </value>
  </data>
  <data name="QaMaxSlope_0" xml:space="preserve">
    <value>Finds all segments in 'featureClass' where the slope is larger than 'limit'</value>
  </data>
  <data name="QaMaxSlope_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaMaxSlope_limit" xml:space="preserve">
    <value>maximum slope (in 'AngularUnit', default value of 'AngularUnit' is radian)</value>
  </data>
  <data name="QaMinAngle_0" xml:space="preserve">
    <value>Finds all pair of (From/To-) points in 'polylineClass' where the angle built by the lines is smaller than 'limit'</value>
  </data>
  <data name="QaMinAngle_1" xml:space="preserve">
    <value>Finds all pair of (From/To-) points in 'polylineClasses' where the angle built by the lines is smaller than 'limit'

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinAngle_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaMinAngle_limit" xml:space="preserve">
    <value>minimum angle (in 'AngularUnit', default value of 'AngularUnit' is radian)</value>
  </data>
  <data name="QaMinAngle_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaMinAngle_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaMinArea_0" xml:space="preserve">
    <value>Finds all polygons in 'polygonClass' with areas smaller than 'limit'. Features with empty geometries are not tested.</value>
  </data>
  <data name="QaMinArea_1" xml:space="preserve">
    <value>Finds all parts in 'polygonClass' with areas smaller than 'limit'. Parts are defined by perPart. Features with empty geometries are not tested.</value>
  </data>
  <data name="QaMinArea_limit" xml:space="preserve">
    <value>minimum area in (x,y)-units</value>
  </data>
  <data name="QaMinArea_perPart" xml:space="preserve">
    <value>Indicates if the area is checked for each ring (true) or for the entire feature (false)</value>
  </data>
  <data name="QaMinArea_polygonClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="QaMinIntersect_0" xml:space="preserve">
    <value>Finds all area overlaps between two features in 'polygonClasses', where the overlapping area is smaller than 'limit'

Remark: The feature classes in 'polygonClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinIntersect_1" xml:space="preserve">
    <value>Finds all area overlaps between two features in 'polygonClass', where the overlapping area is smaller than 'limit'</value>
  </data>
  <data name="QaMinIntersect_limit" xml:space="preserve">
    <value>minimum overlap area in (x,y)-units</value>
  </data>
  <data name="QaMinIntersect_polygonClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="QaMinIntersect_polygonClasses" xml:space="preserve">
    <value>polygon feature classes</value>
  </data>
  <data name="QaMinLength_0" xml:space="preserve">
    <value>Finds all lines in 'featureClass' with length smaller than 'limit'</value>
  </data>
  <data name="QaMinLength_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaMinLength_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaMinLength_limit" xml:space="preserve">
    <value>minimum length in (x,y)-units</value>
  </data>
  <data name="QaMinLength_perPart" xml:space="preserve">
    <value>check for each part</value>
  </data>
  <data name="QaMinNodeDistance_0" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near'</value>
  </data>
  <data name="QaMinNodeDistance_1" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near'

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinNodeDistance_2" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near'. Pairs closer than 'tolerance' are considered coincident</value>
  </data>
  <data name="QaMinNodeDistance_3" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near'. Pairs closer than 'tolerance' are considered coincident

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinNodeDistance_4" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'</value>
  </data>
  <data name="QaMinNodeDistance_5" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinNodeDistance_6" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'. Pairs closer than 'tolerance' are considered coincident</value>
  </data>
  <data name="QaMinNodeDistance_7" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'. Pairs closer than 'tolerance' are considered coincident</value>
  </data>
  <data name="QaMinNodeDistance_9" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'. Pairs closer than 'tolerance' are considered coincident. No error is reported for point pairs that fulfill a defined constraint.</value>
  </data>
  <data name="QaMinNodeDistance_10" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near' and find all coincident pairs with z-coordinate difference larger than 'maxZDifference'. Pairs closer than 'tolerance' are considered coincident. No error is reported for point pairs that fulfill a defined constraint.</value>
  </data>
  <data name="QaMinNodeDistance_11" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClass' closer than 'near'. Pairs closer than 'tolerance' are considered coincident. No error is reported for point pairs that fulfill a defined constraint.</value>
  </data>
  <data name="QaMinNodeDistance_12" xml:space="preserve">
    <value>Finds all pair of (From/To-) points of 'featureClasses' closer than 'near'. Pairs closer than 'tolerance' are considered coincident. No error is reported for point pairs that fulfill a defined constraint.

Remark: The feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMinNodeDistance_featureClass" xml:space="preserve">
    <value>point or polyline feature class</value>
  </data>
  <data name="QaMinNodeDistance_featureClasses" xml:space="preserve">
    <value>point or polyline feature classes</value>
  </data>
  <data name="QaMinNodeDistance_is3D" xml:space="preserve">
    <value>Indicates if the distance between the point should be calculated as a 3D distance.</value>
  </data>
  <data name="QaMinNodeDistance_maxZDifference" xml:space="preserve">
    <value>maximum allowed z-coordinate difference of coincident points</value>
  </data>
  <data name="QaMinNodeDistance_near" xml:space="preserve">
    <value>minimum point distance in (x,y)-units</value>
  </data>
  <data name="QaMinNodeDistance_tolerance" xml:space="preserve">
    <value>coincidence distance in (x,y)-units. If the distance between the (From/To-) points is less than this tolerance, the points are considered to be coincident.
    
A negative tolerance value indicates that coincident points are not considered as valid. This allows to find *all* pairs of points closer than 'near', whether they are coincident or not.</value>
  </data>
  <data name="QaMinNodeDistance_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of features that are invalid according to the tolerance values. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaMinSegAngle_0" xml:space="preserve">
    <value>Finds all consecutive segments in 'featureClass' where the angle between two segments is smaller than 'limit'</value>
  </data>
  <data name="QaMinSegAngle_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaMinSegAngle_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaMinSegAngle_limit" xml:space="preserve">
    <value>minimum allowed angle between segments (in 'AngularUnit', default value of 'AngularUnit' is radian)</value>
  </data>
  <data name="QaMultipart_0" xml:space="preserve">
    <value>Find all multipart features in 'featureClass'</value>
  </data>
  <data name="QaMultipart_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaMultipart_singleRing" xml:space="preserve">
    <value>only one ring allowed in polygons</value>
  </data>
  <data name="QaNeighbourAreas_0" xml:space="preserve">
    <value>Finds all touching features in 'polygonClass' that do not fulfill 'constraint'</value>
  </data>
  <data name="QaNeighbourAreas_constraint" xml:space="preserve">
    <value>checked constraint between two touching features. Left polygon feature is aliased as "L" and right polygon feature as "R"
Example for constraint: "L.ObjektArt &lt;&gt; R.ObjektArt"</value>
  </data>
  <data name="QaNeighbourAreas_polygonClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="QaNonEmptyGeometry_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' with null or empty geometries.</value>
  </data>
  <data name="QaNonEmptyGeometry_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaNotNear_0" xml:space="preserve">
    <value>Finds all line sections longer than 'minLength' in 'featureClass' that are closer than 'near' to any other line in 'featureClass'.</value>
  </data>
  <data name="QaNotNear_2" xml:space="preserve">
    <value>Finds all line sections in 'featureClass' longer than 'minLength' that are closer than 'near' to any line in 'reference'.

Remark: The feature classes in 'featureClass' and 'reference' must have the same spatial reference.</value>
  </data>
  <data name="QaNotNear_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaNotNear_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaNotNear_minLength" xml:space="preserve">
    <value>minimum reporting length in (x,y)-units</value>
  </data>
  <data name="QaNotNear_near" xml:space="preserve">
    <value>near distance in (x,y)-units</value>
  </data>
  <data name="QaNotNear_reference" xml:space="preserve">
    <value>reference polyline or polygon feature class</value>
  </data>
  <data name="QaNotNear_tileSize" xml:space="preserve">
    <value>Note: this parameter is no longer used</value>
  </data>
  <data name="QaOrphanNode_0" xml:space="preserve">
    <value>Finds all points in 'pointClasses' that are neither From- nor To-point of any feature in 'polylineClasses' and line end points without any point

Remark: All feature classes in 'pointClasses' and 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaOrphanNode_1" xml:space="preserve">
    <value>Finds all points in 'pointClass' that are neither From- nor To-point of any feature in 'polylineClass' and line end points without any point

Remark: The feature classes in 'pointClass' and 'polylineClass' must have the same spatial reference.</value>
  </data>
  <data name="QaOrphanNode_2" xml:space="preserve">
    <value>Finds all points in 'pointClasses' that are neither From- nor To-point of any feature in 'polylineClasses' and/or line end points without any point
Performs the tests defined in 'errorType'.

Remark: All feature classes in 'pointClasses' and 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaOrphanNode_3" xml:space="preserve">
    <value>Finds all points in 'pointClass' that are neither From- nor To-point of any feature in 'polylineClass' and/or line end points without any point
Performs the tests defined in 'errorType'.

Remark: The feature classes in 'pointClass' and 'polylineClass' must have the same spatial reference.</value>
  </data>
  <data name="QaOrphanNode_errorType" xml:space="preserve">
    <value>report only orphaned points, only line end points without points or both.</value>
  </data>
  <data name="QaOrphanNode_pointClass" xml:space="preserve">
    <value>point feature class</value>
  </data>
  <data name="QaOrphanNode_pointClasses" xml:space="preserve">
    <value>point feature classes</value>
  </data>
  <data name="QaOrphanNode_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaOrphanNode_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaOverlapsOther_0" xml:space="preserve">
    <value>Finds features in 'overlappingClasses' overlapping with any feature in 'overlappedClasses'

Remark: All feature classes in 'overlappedClasses' and 'overlappingClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaOverlapsOther_overlappedClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaOverlapsOther_overlappedClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaOverlapsOther_overlappingClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaOverlapsOther_overlappingClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaOverlapsSelf_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' that overlap any feature in 'featureClass'</value>
  </data>
  <data name="QaOverlapsSelf_featureClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaPartCoincidence_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaPartCoincidence_featureClasses" xml:space="preserve">
    <value>polyline or polygon feature classes</value>
  </data>
  <data name="QaPartCoincidence_is3D" xml:space="preserve">
    <value>include z-coordinate for checking</value>
  </data>
  <data name="QaPartCoincidence_minLength" xml:space="preserve">
    <value>minimum length to report near, but not coincident line sections</value>
  </data>
  <data name="QaPartCoincidence_near" xml:space="preserve">
    <value>maximum distance in (x,y)-units where 2 lines are checked for coincidence</value>
  </data>
  <data name="QaPartCoincidence_reference" xml:space="preserve">
    <value>reference polyline or polygon feature class</value>
  </data>
  <data name="QaPartCoincidence_tileSize" xml:space="preserve">
    <value>Note: this parameter is no longer used</value>
  </data>
  <data name="QaPartCoincidenceOther_0" xml:space="preserve">
    <value>Find line sections longer than 'minLength' in 'featureClass', that lie nearer than 'near' to lines in 'reference' but are not coincident.

Remark: All feature classes in 'featureClass' and 'reference' must have the same spatial reference.</value>
  </data>
  <data name="QaPartCoincidenceSelf_0" xml:space="preserve">
    <value>Find line sections longer than 'minLength' in 'featureClass', where 2 non-coincident lines lie nearer than 'near' but are not coincident.</value>
  </data>
  <data name="QaPartCoincidenceSelf_2" xml:space="preserve">
    <value>Find line sections longer than 'minLength' in 'featureClasses', where 2 non-coincident lines lie nearer than 'near', but are not coincident.

Remark: All feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaPointOnLine_0" xml:space="preserve">
    <value>Finds all points in 'pointClass' not nearer than 'near' to any feature of 'nearClasses'

Remark: All feature classes in 'pointClass' and 'nearClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaPointOnLine_near" xml:space="preserve">
    <value>maximum point distance in (x,y)-units</value>
  </data>
  <data name="QaPointOnLine_nearClasses" xml:space="preserve">
    <value>polyline or polygon feature classes</value>
  </data>
  <data name="QaPointOnLine_pointClass" xml:space="preserve">
    <value>point or multipoint feature class</value>
  </data>
  <data name="QaPseudoNodes_0" xml:space="preserve">
    <value>Finds pseudo nodes: Finds all endpoints in 'polylineClasses', that correspond to exactly 2 From-/To-points of 'polylineClasses', the two involved features belong to the same feature class, the attributes values of the involved features do not differ and they are not separated by a point out of 'validPseudoNodes' 

Remark: All feature classes in 'polylineClasses' and 'validPseudoNodes' must have the same spatial reference.</value>
  </data>
  <data name="QaPseudoNodes_1" xml:space="preserve">
    <value>Finds pseudo nodes: Finds all endpoints in 'polylineClass', that correspond to exactly 2 From-/To-points of 'polylineClass', the attributes values of the involved features do not differ and they are not separated by a point out of 'validPseudoNode'

Remark: The feature classes in 'validPseudoNode' and 'polylineClass' must have the same spatial reference.</value>
  </data>
  <data name="QaPseudoNodes_2" xml:space="preserve">
    <value>Finds pseudo nodes: Finds all endpoints in 'polylineClasses', that correspond to exactly 2 From-/To-points of 'polylineClasses', the two involved features belong to the same feature class and the attributes values of the involved features do not differ

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaPseudoNodes_3" xml:space="preserve">
    <value>Finds pseudo nodes: Finds all endpoints in 'polylineClass', that correspond to exactly 2 From-/To-points and the attributes values of the involved features do not differ</value>
  </data>
  <data name="QaPseudoNodes_ignoreFields_0" xml:space="preserve">
    <value>fields that are not checked for equality (not editable fields are ignored by default).
For each feature class in 'polylineClasses', the ignore fields must be defined.
The sort order must correspond with 'polylineClasses'.</value>
  </data>
  <data name="QaPseudoNodes_ignoreFields_1" xml:space="preserve">
    <value>fields that are not checked for equality (not editable fields are ignored by default).</value>
  </data>
  <data name="QaPseudoNodes_polylineClass" xml:space="preserve">
    <value>polyline feature class</value>
  </data>
  <data name="QaPseudoNodes_polylineClasses" xml:space="preserve">
    <value>polyline feature classes</value>
  </data>
  <data name="QaPseudoNodes_validPseudoNode" xml:space="preserve">
    <value>feature class containing point, line or polygon features to indicate valid pseudo nodes. Pseudo nodes are valid, if they lie on a point, a polyline or a polygon border of 'validPseudoNode'.</value>
  </data>
  <data name="QaPseudoNodes_validPseudoNodes" xml:space="preserve">
    <value>feature classes containing point, line or polygon features to indicate valid pseudo nodes. Pseudo nodes are valid, if they lie on a point, a polyline or a polygon border of 'validPseudoNodes'.</value>
  </data>
  <data name="QaRelationConstraint_0" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill 'constraint'</value>
  </data>
  <data name="QaRelationConstraint_1" xml:space="preserve">
    <value>Finds all rows in 'table' that do not fulfill the hierarchical 'constraints'</value>
  </data>
  <data name="QaRelationConstraint_constraint" xml:space="preserve">
    <value>checked constraint</value>
  </data>
  <data name="QaRelationConstraint_constraints" xml:space="preserve">
    <value>hierarchical list of constraints</value>
  </data>
  <data name="QaRelationConstraint_relatedTables" xml:space="preserve">
    <value>related tables to find involved rows</value>
  </data>
  <data name="QaRelationConstraint_table" xml:space="preserve">
    <value>table built with relations out of 'relatedTables'</value>
  </data>
  <data name="QaRequiredFields_0" xml:space="preserve">
    <value>Finds rows with null values for a given list of required fields</value>
  </data>
  <data name="QaRequiredFields_requiredFieldNames" xml:space="preserve">
    <value>List of field names to check for null values</value>
  </data>
  <data name="QaRequiredFields_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaSegmentLength_0" xml:space="preserve">
    <value>Find all segments in 'featureClass' smaller than 'limit'</value>
  </data>
  <data name="QaSegmentLength_featureClass" xml:space="preserve">
    <value>polyline, polygon or multipatch feature class</value>
  </data>
  <data name="QaSegmentLength_is3D" xml:space="preserve">
    <value>include z-coordinate for checking (default = false for polyline and polygon, = true for multipatch feature class)</value>
  </data>
  <data name="QaSegmentLength_limit" xml:space="preserve">
    <value>minimum segment length</value>
  </data>
  <data name="QaSimpleGeometry_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' with non-simple geometries</value>
  </data>
  <data name="QaSimpleGeometry_featureClass" xml:space="preserve">
    <value>multipoint, polyline, polygon or multipatch feature class</value>
  </data>
  <data name="QaSliverPolygon_0" xml:space="preserve">
    <value>Finds all sliver polygons in 'polygonClass'</value>
  </data>
  <data name="QaSliverPolygon_limit" xml:space="preserve">
    <value>The maximal allowed ratio between the square of the perimeter and the area</value>
  </data>
  <data name="QaSliverPolygon_maxArea" xml:space="preserve">
    <value>maximum area of checked features</value>
  </data>
  <data name="QaSliverPolygon_polygonClass" xml:space="preserve">
    <value>polygon feature class</value>
  </data>
  <data name="QaSmooth_0" xml:space="preserve">
    <value>Finds all segments in 'featureClass' where the discretized second derivative of the slope angle exceeds 'limit'. This means that there are to abrupt changes in the slope angle.</value>
  </data>
  <data name="QaSmooth_featureClass" xml:space="preserve">
    <value>polyline or polygon feature class with z-coordinates</value>
  </data>
  <data name="QaSmooth_limit" xml:space="preserve">
    <value>the maximum permitted second derivative of the angle (in 'AngularUnit', default value of 'AngularUnit' is radian)</value>
  </data>
  <data name="QaTrimmedTextFields_0" xml:space="preserve">
    <value>Finds rows with text fields having leading or trailing whitespace characters. All text fields of the table are checked. Fields with only whitespace characters are also reported.</value>
  </data>
  <data name="QaTrimmedTextFields_1" xml:space="preserve">
    <value>Finds rows with text fields having leading or trailing whitespace characters. All text fields of the table are checked. For fields that contain only whitespace, a maximum number of allowed whitespace characters can specified.</value>
  </data>
  <data name="QaTrimmedTextFields_2" xml:space="preserve">
    <value>Finds rows that have leading or trailing whitespace characters in a specified text field. An error is reported also if the field contains only whitespace characters.</value>
  </data>
  <data name="QaTrimmedTextFields_3" xml:space="preserve">
    <value>Finds rows that have leading or trailing whitespace characters in a specified text field. If the field contains only whitespace, a maximum number of allowed whitespace characters can specified.</value>
  </data>
  <data name="QaTrimmedTextFields_4" xml:space="preserve">
    <value>Finds rows that have leading or trailing whitespace characters in a given list of text fields. If the field contains only whitespace, a maximum number of allowed whitespace characters can specified.</value>
  </data>
  <data name="QaTrimmedTextFields_allowedWhiteSpaceOnlyCount" xml:space="preserve">
    <value>The number of allowed whitespace characters, if a text field contains only whitespace characters.</value>
  </data>
  <data name="QaTrimmedTextFields_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaTrimmedTextFields_textFieldName" xml:space="preserve">
    <value>The text field to check for leading or trailing blanks</value>
  </data>
  <data name="QaTrimmedTextFields_textFieldNames" xml:space="preserve">
    <value>The list of text fields to check for leading or trailing blanks</value>
  </data>
  <data name="QaUnique_0" xml:space="preserve">
    <value>Finds rows in 'table' for which the values in the field(s) defined by 'unique' are not unique</value>
  </data>
  <data name="QaUnique_maxRows" xml:space="preserve">
    <value>maximum number of rows in memory</value>
  </data>
  <data name="QaUnique_table" xml:space="preserve">
    <value>table to check for uniqueness of field values</value>
  </data>
  <data name="QaUnique_unique" xml:space="preserve">
    <value>unique constraint for the table  (one or more field names. If the combination of values from more than one field name should be unique, then the field names must be separated by ","). Note that an index on the first unique attribute should exist if the total row count is large (otherwise the test may be slow if applied to a subset of the data, e.g. a spatial query to a feature class)</value>
  </data>
  <data name="QaValidDateValues_0" xml:space="preserve">
    <value>Finds rows with date field values that are invalid or outside a defined date range</value>
  </data>
  <data name="QaValidDateValues_1" xml:space="preserve">
    <value>Finds rows with date values from a given list of date fields that are invalid or outside a defined date range</value>
  </data>
  <data name="QaValidDateValues_dateFieldNames" xml:space="preserve">
    <value>List of date field names to verify against the defined date range</value>
  </data>
  <data name="QaValidDateValues_maximumDateValue" xml:space="preserve">
    <value>the upper bound of the range of valid date values</value>
  </data>
  <data name="QaValidDateValues_minimumDateValue" xml:space="preserve">
    <value>the lower bound of the range of valid date values</value>
  </data>
  <data name="QaValidDateValues_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaValue_0" xml:space="preserve">
    <value>Finds all rows in 'table' with invalid data types. This can be the case for GUID-values. The test itself checks all datatypes</value>
  </data>
  <data name="QaValue_fields" xml:space="preserve">
    <value>fields to check</value>
  </data>
  <data name="QaValue_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaDateFieldsWithoutTime_0" xml:space="preserve">
    <value>Finds rows with date fields having non-zero time parts. All date fields of the table are checked.</value>
  </data>
  <data name="QaDateFieldsWithoutTime_1" xml:space="preserve">
    <value>Finds rows that have non-zero time parts in a specified date field.</value>
  </data>
  <data name="QaDateFieldsWithoutTime_2" xml:space="preserve">
    <value>Finds rows that have non-zero time parts in a given list of date fields.</value>
  </data>
  <data name="QaDateFieldsWithoutTime_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaDateFieldsWithoutTime_dateFieldName" xml:space="preserve">
    <value>The date field to check for a non-zero time part</value>
  </data>
  <data name="QaDateFieldsWithoutTime_dateFieldNames" xml:space="preserve">
    <value>The list of date fields to check for non-zero time parts</value>
  </data>
  <data name="QaRegularExpression_0" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression</value>
  </data>
  <data name="QaRegularExpression_pattern" xml:space="preserve">
    <value>String defining the regular expression. The test uses the .Net regular expression syntax. The basic syntax typically used for this test should be identical to other regular expression implementations.

Regular expression (regex) tutorials and basic syntax reference:

- http://www.ternent.com/tech/regexp.html
- http://regexlib.com/CheatSheet.aspx
- http://www.regular-expressions.info/tutorial.html
- http://www.regular-expressions.info/reference.html

.Net regular expression documentation: 

- http://msdn.microsoft.com/en-us/library/kweb790z(VS.71).aspx
- http://msdn.microsoft.com/en-us/library/az24scfc(VS.71).aspx

Web application to test regular expressions:

- http://regexlib.com/RETester.aspx

Comparison of regular expression flavors:

- http://www.regular-expressions.info/refflavors.html</value>
  </data>
  <data name="QaRegularExpression_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaRegularExpression_textFieldNames" xml:space="preserve">
    <value>List of field to verify against the regular expression</value>
  </data>
  <data name="QaRegularExpression_1" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression</value>
  </data>
  <data name="QaRegularExpression_fieldName" xml:space="preserve">
    <value>Name of one or more fields to verify against the regular expression. If multiple fields are specified, they have to be separated by blank, comma or semicolon.</value>
  </data>
  <data name="QaFlowLogic_2" xml:space="preserve">
    <value>Finds all (From/To-) points in 'polylineClasses', that are not coincident with exactly one From-point. From/To-Points are determined by 'flipExpressions'.

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaFlowLogic_flipExpressions" xml:space="preserve">
    <value>Expressions for determining the directions of the polylines.
The expressions are evaluated on the features attributes and must return a boolean value. If the expression returns true, the flipped geometry of the features shape is used for testing, otherwise the actual shape.

If 'flipExpressions' are null: directions are as the features shapes

If there is exactly 1 'flipExpressions', the expression is applied to all 'polylineClasses'. Otherwise, there must be exactly one expression per polylineClass, in corresponding order.</value>
  </data>
  <data name="QaFlowLogic_allowMultipleOutgoingLines" xml:space="preserve">
    <value>Indicates that multiple outgoing lines at a node should not be considered an error.</value>
  </data>
  <data name="QaNodeLineCoincidence_0" xml:space="preserve">
    <value>Finds nodes in 'nodeClass' that are not coincident with any feature in 'nearClasses', but are within 'near' of at least one feature in 'nearClasses'</value>
  </data>
  <data name="QaNodeLineCoincidence_1" xml:space="preserve">
    <value>Finds nodes in 'nodeClass' that are not coincident with any feature in 'nearClasses', but are within 'near' of at least one feature in 'nearClasses'. Optionally, only nodes near an edge but no end point are reported. This permits avoiding multiple errors when applying other tests to check for minimum node distance.</value>
  </data>
  <data name="QaNodeLineCoincidence_ignoreNearEndpoints" xml:space="preserve">
    <value>if set to true, unconnected nodes that are near an endpoint of a line are not reported.</value>
  </data>
  <data name="QaNodeLineCoincidence_near" xml:space="preserve">
    <value>maximum distance in (x,y)-units from lines or polygon boundaries for which unconnected nodes are reported. Unconnected nodes further away than this tolerance are not reported.</value>
  </data>
  <data name="QaNodeLineCoincidence_nearClasses" xml:space="preserve">
    <value>Polyline or polygon classes. For polygon classes, the polygon boundaries will be used.</value>
  </data>
  <data name="QaNodeLineCoincidence_nodeClass" xml:space="preserve">
    <value>Polyline or point feature class. For polyline feature classes, end points will be processed.</value>
  </data>
  <data name="QaTouchesOther_0" xml:space="preserve">
    <value>Finds all features in 'touchedClasses' that are touched by features in 'touchingClasses'</value>
  </data>
  <data name="QaTouchesOther_1" xml:space="preserve">
    <value>Finds all features in 'touchedClass' that are touched by features in 'touchingClass'</value>
  </data>
  <data name="QaTouchesOther_2" xml:space="preserve">
    <value>Finds all features in 'touchedClasses' that are touched by features in 'touchingClasses', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaTouchesOther_3" xml:space="preserve">
    <value>Finds all features in 'touchedClass' that are touched by features in 'touchingClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaTouchesOther_touchedClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaTouchesOther_touchedClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaTouchesOther_touchingClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaTouchesOther_touchingClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaTouchesOther_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of touching features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaTouchesSelf_0" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that are touched by other features in 'featureClasses'</value>
  </data>
  <data name="QaTouchesSelf_1" xml:space="preserve">
    <value>Finds all features in 'featureClass' that are touched by other features in 'featureClass'</value>
  </data>
  <data name="QaTouchesSelf_2" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that are touched by other features in 'featureClasses', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaTouchesSelf_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that are touched by other features in 'featureClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaTouchesSelf_featureClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaTouchesSelf_featureClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaTouchesSelf_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of touching features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaRequiredFields_allowEmptyStrings" xml:space="preserve">
    <value>Indicates if empty string values are allowed. If false, then empty string values in required fields are reported as errors</value>
  </data>
  <data name="QaInteriorIntersectsSelf_3" xml:space="preserve">
    <value>Finds all pairs of features in a list of feature classes with intersecting interiors, and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaRegularExpression_fieldNames" xml:space="preserve">
    <value>Fields to verify against the regular expression</value>
  </data>
  <data name="QaSimpleGeometry_1" xml:space="preserve">
    <value>Finds all features in 'featureClass' with non-simple geometries. Optionally ignores non-planar (self-intersecting) lines</value>
  </data>
  <data name="QaSimpleGeometry_allowNonPlanarLines" xml:space="preserve">
    <value>Indicates if non-planar (self-intersecting) lines should be ignored or reported.</value>
  </data>
  <data name="QaForeignKey_0" xml:space="preserve">
    <value>Finds rows that have a key value that does not refer to a value in a referenced table.</value>
  </data>
  <data name="QaForeignKey_foreignKeyField" xml:space="preserve">
    <value>the foreign key field in 'table'</value>
  </data>
  <data name="QaForeignKey_referencedKeyField" xml:space="preserve">
    <value>the key field in the referenced table. The values in this field are loaded into memory. For very large referenced tables that are in the same database as 'table' the test factory QaRelConstraint may be a better choice since it joins the tables in the database instead of loading the referenced keys into memory. The memory usage of this test is logged at verbose debug level.</value>
  </data>
  <data name="QaForeignKey_referencedTable" xml:space="preserve">
    <value>the table referenced by the foreign keys in 'table'</value>
  </data>
  <data name="QaForeignKey_table" xml:space="preserve">
    <value>table containing foreign key values</value>
  </data>
  <data name="QaGdbNetworkElements_0" xml:space="preserve">
    <value>Finds invalid logical network elements in a geometric network</value>
  </data>
  <data name="QaGdbNetworkElements_geometricNetwork" xml:space="preserve">
    <value>geometric network</value>
  </data>
  <data name="QaRegularExpression_2" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression. Optionally, a match can be considered an error.</value>
  </data>
  <data name="QaRegularExpression_3" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression. Optionally, a match can be considered an error.</value>
  </data>
  <data name="QaRegularExpression_4" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression. Optionally, a match can be considered an error.</value>
  </data>
  <data name="QaRegularExpression_5" xml:space="preserve">
    <value>Finds rows with values that do not match a defined regular expression. Optionally, a match can be considered an error.</value>
  </data>
  <data name="QaRegularExpression_matchIsError" xml:space="preserve">
    <value>Indicates if a pattern match is considered an error:
- 'true': a match is an error
- 'false' -&gt; a match is correct (default)</value>
  </data>
  <data name="QaRegularExpression_patternDescription" xml:space="preserve">
    <value>A description for the pattern, to be displayed in the error text.</value>
  </data>
  <data name="QaRequiredFields_allowMissingFields" xml:space="preserve">
    <value>Indicates if fields specified in 'requiredFieldNames', but not existing in table, should be ignored. If 'false' (default) then an exception is thrown if a specified field does not exist</value>
  </data>
  <data name="QaRequiredFields_requiredFieldNamesString" xml:space="preserve">
    <value>List of field names to check for null values, as a concatenated string. This form can simplify some configuration methods. Supported separators; ' ' (blank), ',', ';'</value>
  </data>
  <data name="QaLineIntersectAngle_polylineClass" xml:space="preserve">
    <value>polyline or polygon feature class</value>
  </data>
  <data name="QaNoBoundaryLoops_0" xml:space="preserve">
    <value>Finds all boundary loops (closed 'bays' in polygon boundaries or multipatch rings) in a polygon or multipatch feature class and reports them as polygon errors.</value>
  </data>
  <data name="QaNoBoundaryLoops_1" xml:space="preserve">
    <value>Finds all boundary loops (closed 'bays' in polygon boundaries or multipatch rings) in a polygon or multipatch feature class and reports them optionally as polygon errors or as point errors identifying the location where the boundary loop starts/ends.</value>
  </data>
  <data name="QaNoBoundaryLoops_2" xml:space="preserve">
    <value>Finds all boundary loops (closed 'bays' in polygon boundaries or multipatch rings) in a polygon or multipatch feature class and reports them optionally as polygon errors or as point errors identifying the location where the boundary loop starts/ends. 

Optionally, loops larger or smaller than a given area limit can be ignored. This can be useful together with 'errorGeometry' to report loop start points specifically for large loops (in addition to reporting the loop polygons reported by a separate test), where it would otherwise be tedious to locate this start point visually.</value>
  </data>
  <data name="QaNoBoundaryLoops_areaLimit" xml:space="preserve">
    <value>The area limit in square xy units of the spatial reference</value>
  </data>
  <data name="QaNoBoundaryLoops_areaRelation" xml:space="preserve">
    <value>Indicates if loop polygons smaller than or equal the area limit should be ignored, or if loop polygons larger than the area limit should be ignored.</value>
  </data>
  <data name="QaNoBoundaryLoops_errorGeometry" xml:space="preserve">
    <value>The type of error geometry to produce (loop polygon or loop start point). Note that even if LoopPolygon is selected, points may be reported, in certain exceptional cases (the reason for which will be included in the error description)</value>
  </data>
  <data name="QaNoBoundaryLoops_polygonClass" xml:space="preserve">
    <value>Polygon or multipatch feature class to check for boundary loops</value>
  </data>
  <data name="QaMaxVertexCount_0" xml:space="preserve">
    <value>Finds polygon/polyline/multipoint features or feature parts with a vertex count larger than 'limit'</value>
  </data>
  <data name="QaMaxVertexCount_featureClass" xml:space="preserve">
    <value>Polygon, polyline or multipoint feature class</value>
  </data>
  <data name="QaMaxVertexCount_limit" xml:space="preserve">
    <value>The maximum allowed vertex count</value>
  </data>
  <data name="QaMaxVertexCount_perPart" xml:space="preserve">
    <value>Indicates if the test should be applied per individual parts or on the entire feature geometry</value>
  </data>
  <data name="QaMinMeanSegmentLength_0" xml:space="preserve">
    <value>Finds polygon/polyline features or feature parts with an average segment length smaller than 'limit'</value>
  </data>
  <data name="QaMinMeanSegmentLength_featureClass" xml:space="preserve">
    <value>Polygon or polyline feature class</value>
  </data>
  <data name="QaMinMeanSegmentLength_limit" xml:space="preserve">
    <value>The minimum allowed mean segment length</value>
  </data>
  <data name="QaMinMeanSegmentLength_perPart" xml:space="preserve">
    <value>Indicates if the test should be applied per individual parts or on the entire feature geometry</value>
  </data>
  <data name="QaWithinBox_0" xml:space="preserve">
    <value>Finds features that are not fully within a specified box</value>
  </data>
  <data name="QaWithinBox_featureClass" xml:space="preserve">
    <value>Feature class</value>
  </data>
  <data name="QaWithinBox_reportOnlyOutsideParts" xml:space="preserve">
    <value>Indicates if only the geometry parts outside the box are reported. Otherwise the entire feature geometry is reported</value>
  </data>
  <data name="QaWithinBox_xMax" xml:space="preserve">
    <value>X maximum coordinate of the box</value>
  </data>
  <data name="QaWithinBox_xMin" xml:space="preserve">
    <value>X minimum coordinate of the box</value>
  </data>
  <data name="QaWithinBox_yMax" xml:space="preserve">
    <value>Y maximum coordinate of the box</value>
  </data>
  <data name="QaWithinBox_yMin" xml:space="preserve">
    <value>Y minimum coordinate of the box</value>
  </data>
  <data name="QaCrossesOther_1" xml:space="preserve">
    <value>Finds all features in 'crossingClass' that are crossing any features of 'crossedClass'

Remark: The feature classes in 'crossingClass' and 'crossedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaCrossesOther_2" xml:space="preserve">
    <value>Finds all features in 'crossingClasses' that are crossing any features of 'crossedClasses', and for which a given constraint is not fulfilled.

Remark: All feature classes in 'crossingClasses' and 'crossedClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaCrossesOther_3" xml:space="preserve">
    <value>Finds all features in 'crossingClass' that are crossing any features of 'crossedClass', and for which a given constraint is not fulfilled.

Remark: The feature classes in 'crossingClass' and 'crossedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaCrossesOther_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of crossing features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaCrossesSelf_0" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that are crossing any features of 'featureClasses'</value>
  </data>
  <data name="QaCrossesSelf_1" xml:space="preserve">
    <value>Finds all features in 'featureClass' that are crossing any features of 'featureClass'</value>
  </data>
  <data name="QaCrossesSelf_2" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that are crossing any features of 'featureClasses', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaCrossesSelf_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that are crossing any features of 'featureClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaCrossesSelf_featureClass" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature class</value>
  </data>
  <data name="QaCrossesSelf_featureClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaCrossesSelf_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of crossing features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaLineIntersect_2" xml:space="preserve">
    <value>Finds all features in 'polylineClasses' that cross any other feature in 'polylineClasses', and for which a given constraint is not fulfilled.

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersect_3" xml:space="preserve">
    <value>Finds all features in 'polylineClass' that cross any other feature in 'polylineClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaLineIntersect_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of line features that intersect. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" (featureClass) and "G2" (relatedClass).
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaOverlapsSelf_1" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that overlap any feature in 'featureClasses'</value>
  </data>
  <data name="QaOverlapsSelf_2" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that overlap any feature in 'featureClasses', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaOverlapsSelf_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that overlap any feature in 'featureClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaOverlapsSelf_featureClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaOverlapsSelf_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of overlapping features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaOverlapsOther_1" xml:space="preserve">
    <value>Finds features in 'overlappingClass' overlapping with any feature in 'overlappedClass'

Remark: The feature classes 'overlappedClass' and 'overlappingClass' must have the same spatial reference.</value>
  </data>
  <data name="QaOverlapsOther_2" xml:space="preserve">
    <value>Finds features in 'overlappingClasses' overlapping with any feature in 'overlappedClasses', and for which a given constraint is not fulfilled.

Remark: All feature classes in 'overlappedClasses' and 'overlappingClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaOverlapsOther_3" xml:space="preserve">
    <value>Finds features in 'overlappingClass' overlapping with any feature in 'overlappedClass', and for which a given constraint is not fulfilled.

Remark: The feature classes 'overlappedClass' and 'overlappingClass' must have the same spatial reference.</value>
  </data>
  <data name="QaOverlapsOther_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of overlapping features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaIntersectsSelf_1" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that intersect any feature in 'featureClasses'</value>
  </data>
  <data name="QaIntersectsSelf_2" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that intersect any feature in 'featureClasses', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaIntersectsSelf_3" xml:space="preserve">
    <value>Finds all features in 'featureClass' that intersect any feature in 'featureClass', and for which a given constraint is not fulfilled.</value>
  </data>
  <data name="QaIntersectsSelf_featureClasses" xml:space="preserve">
    <value>Point, multipoint, line or polygon feature classes</value>
  </data>
  <data name="QaIntersectsSelf_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of intersecting features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaIntersectsOther_1" xml:space="preserve">
    <value>Finds all features in 'intersectingClass' that intersect by any features of 'intersectedClass'

Remark: The feature classes in 'intersectedClass' and 'intersectingClass' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectsOther_2" xml:space="preserve">
    <value>Finds all features in 'intersectingClasses' that intersect by any features of 'intersectedClasses', and for which a given constraint is not fulfilled.

Remark: All feature classes in 'intersectedClasses' and 'intersectingClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectsOther_3" xml:space="preserve">
    <value>Finds all features in 'intersectingClass' that intersect by any features of 'intersectedClass', and for which a given constraint is not fulfilled.

Remark: The feature classes in 'intersectedClass' and 'intersectingClass' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectsOther_validRelationConstraint" xml:space="preserve">
    <value>Constraint on a pair of intersecting features. If the constraint is defined and fulfilled, no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level</value>
  </data>
  <data name="QaNeighbourAreas_1" xml:space="preserve">
    <value>Finds all touching features in 'polygonClass' that do not fulfill 'constraint'. Optionally allows to ignore polygon pairs that intersect in points only.</value>
  </data>
  <data name="QaNeighbourAreas_allowPointIntersection" xml:space="preserve">
    <value>Indicates if polygon pairs that intersect in one or more points only (instead of sharing a common linear boundary) should be ignored.</value>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_0" xml:space="preserve">
    <value>Finds domains with invalid domain descriptions.</value>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_table" xml:space="preserve">
    <value>The table to check for domains with invalid descriptions.</value>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_maximumLength" xml:space="preserve">
    <value>The maximum string length for domains. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_requireUniqueDescriptions" xml:space="preserve">
    <value>Indicates if descriptions of domains must be unique. Domain descriptions are compared in case-insensitive manner, i.e. domain descriptions that differ only in character case are considered duplicates.</value>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_targetWorkspaceTable" xml:space="preserve">
    <value>A table in another workspace to check for duplicates. Optional, if undefined the workspace of the table to be tested is checked. The table merely points at the workspace to compare against^.</value>
  </data>
  <data name="QaSchemaFieldAliases_0" xml:space="preserve">
    <value>Finds fields with invalid alias names.</value>
  </data>
  <data name="QaSchemaFieldAliases_table" xml:space="preserve">
    <value>The table to check for fields with invalid alias names.</value>
  </data>
  <data name="QaSchemaFieldAliases_maximumLength" xml:space="preserve">
    <value>The maximum string length for field alias names. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldAliases_expectedCase" xml:space="preserve">
    <value>The expected character case for field alias names.</value>
  </data>
  <data name="QaSchemaFieldAliases_requireUniqueAliasNames" xml:space="preserve">
    <value>Indicates if alias names need to be unique for all fields within the table.</value>
  </data>
  <data name="QaSchemaFieldAliases_allowCustomSystemFieldAlias" xml:space="preserve">
    <value>Indicates if non-default alias names for system fields are allowed. If 'false', alias names for system fields need to be equal to the field name, and the maximum length and character case is not tested.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_0" xml:space="preserve">
    <value>Finds fields that have a reserved field name, based on a list of reserved names.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_1" xml:space="preserve">
    <value>Finds fields that have a reserved field name, based on a concatenated string of reserved names.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_2" xml:space="preserve">
    <value>Finds fields that have a reserved field name, based on a table containing reserved names, and optionally a reason why a name is reserved and a valid name that should be used instead.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_table" xml:space="preserve">
    <value>The table to check for fields with reserved names.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_reservedNames" xml:space="preserve">
    <value>The list of reserved names.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_reservedNamesString" xml:space="preserve">
    <value>A string with concatenated reserved names. Individual names can be separated by ',', ';' and ' '.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_reservedNamesTable" xml:space="preserve">
    <value>A table containing reserved names. This may be in a different workspace than the tested table.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_reservedNameFieldName" xml:space="preserve">
    <value>The name of the field containing the reserved field names in 'reservedNamesTable'. This field is required.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_reservedReasonFieldName" xml:space="preserve">
    <value>The name of a field containing the reason why a field name is reserved (e.g., reserved word in some database system). Optional.</value>
  </data>
  <data name="QaSchemaReservedFieldNames_validNameFieldName" xml:space="preserve">
    <value>The name of a field containing a valid name that should be used instead of the reserved name. Optional.</value>
  </data>
  <data name="QaSchemaFieldNames_0" xml:space="preserve">
    <value>Finds fields with invalid names.</value>
  </data>
  <data name="QaSchemaFieldNames_table" xml:space="preserve">
    <value>The table to check for invalid field names.</value>
  </data>
  <data name="QaSchemaFieldNames_maximumLength" xml:space="preserve">
    <value>The maximum string length for field names. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldNames_expectedCase" xml:space="preserve">
    <value>The expected character case for field names.</value>
  </data>
  <data name="QaSchemaFieldNames_uniqueSubstringLength" xml:space="preserve">
    <value>The number of characters at the start of the field name that needs to be unique for all field names in the table. Used to ensure that field names that are truncated during an export (e.g. to shapefiles) are still unique.</value>
  </data>
  <data name="QaSchemaFieldNameRegex_0" xml:space="preserve">
    <value>Finds field names that do not match a defined regular expression.</value>
  </data>
  <data name="QaSchemaFieldNameRegex_table" xml:space="preserve">
    <value>The table to check for fields based on the regular expression.</value>
  </data>
  <data name="QaSchemaFieldNameRegex_pattern" xml:space="preserve">
    <value>String defining the regular expression. The test uses the .Net regular expression syntax. The basic syntax typically used for this test should be identical to other regular expression implementations.

Regular expression (regex) tutorials and basic syntax reference:

- http://www.ternent.com/tech/regexp.html
- http://regexlib.com/CheatSheet.aspx
- http://www.regular-expressions.info/tutorial.html
- http://www.regular-expressions.info/reference.html

.Net regular expression documentation: 

- http://msdn.microsoft.com/en-us/library/kweb790z(VS.71).aspx
- http://msdn.microsoft.com/en-us/library/az24scfc(VS.71).aspx

Web application to test regular expressions:

- http://regexlib.com/RETester.aspx

Comparison of regular expression flavors:

- http://www.regular-expressions.info/refflavors.html</value>
  </data>
  <data name="QaSchemaFieldNameRegex_matchIsError" xml:space="preserve">
    <value>Indicates if a pattern match is considered an error:
- 'true': a match is an error
- 'false' -&gt; a match is correct (default)</value>
  </data>
  <data name="QaSchemaFieldNameRegex_patternDescription" xml:space="preserve">
    <value>A description for the pattern, to be displayed in the error text.</value>
  </data>
  <data name="QaSchemaFieldDomains_0" xml:space="preserve">
    <value>Finds domains referenced from a table that are not valid for the referencing field (due to a data type mismatch).</value>
  </data>
  <data name="QaSchemaFieldDomains_table" xml:space="preserve">
    <value>The table to check for domains that are not valid for the referencing field.</value>
  </data>
  <data name="QaSchemaFieldDomainNameRegex_0" xml:space="preserve">
    <value>Finds domains referenced from a table whose names do not match a defined regular expression.</value>
  </data>
  <data name="QaSchemaFieldDomainNameRegex_table" xml:space="preserve">
    <value>The table to check for referenced domains with invalid names.</value>
  </data>
  <data name="QaSchemaFieldDomainNameRegex_pattern" xml:space="preserve">
    <value>String defining the regular expression. The test uses the .Net regular expression syntax. The basic syntax typically used for this test should be identical to other regular expression implementations.

Regular expression (regex) tutorials and basic syntax reference:

- http://www.ternent.com/tech/regexp.html
- http://regexlib.com/CheatSheet.aspx
- http://www.regular-expressions.info/tutorial.html
- http://www.regular-expressions.info/reference.html

.Net regular expression documentation: 

- http://msdn.microsoft.com/en-us/library/kweb790z(VS.71).aspx
- http://msdn.microsoft.com/en-us/library/az24scfc(VS.71).aspx

Web application to test regular expressions:

- http://regexlib.com/RETester.aspx

Comparison of regular expression flavors:

- http://www.regular-expressions.info/refflavors.html</value>
  </data>
  <data name="QaSchemaFieldDomainNameRegex_matchIsError" xml:space="preserve">
    <value>Indicates if a pattern match is considered an error:
- 'true': a match is an error
- 'false' -&gt; a match is correct (default)</value>
  </data>
  <data name="QaSchemaFieldDomainNameRegex_patternDescription" xml:space="preserve">
    <value>A description for the pattern, to be displayed in the error text.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_0" xml:space="preserve">
    <value>Finds coded value domains referenced from a table that have invalid coded values lists.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_table" xml:space="preserve">
    <value>The table to check for invalid coded value domains.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_maximumNameLength" xml:space="preserve">
    <value>The maximum length for a coded value name. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_uniqueNamesConstraint" xml:space="preserve">
    <value>The constraint for uniqueness of the coded value names:
- None: no uniqueness check is applied.
- UniqueExactCase: names must be unique with their exact case (i.e. names differing only in case are allowed)
- UniqueAnyCase: names must be unique with any case (i.e. names differing only in case are not allowed)</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_minimumValueCount" xml:space="preserve">
    <value>The minimum number of values in the coded value domain.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_minimumNonEqualNameValueCount" xml:space="preserve">
    <value>The minimum number of coded value names that must be different from the value. E.g. if set to 1, an error is reported if all names are equal to the value.</value>
  </data>
  <data name="QaSchemaFieldDomainCodedValues_allowEmptyName" xml:space="preserve">
    <value>Indicates if empty coded value names are allowed.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_0" xml:space="preserve">
    <value>Finds domains referenced from a table that have invalid names.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_table" xml:space="preserve">
    <value>The table to check for referenced domains with invalid name.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_expectedPrefix" xml:space="preserve">
    <value>An expected prefix for the domain name. Optional.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_maximumLength" xml:space="preserve">
    <value>The maximum string length for domain names. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_mustContainFieldName" xml:space="preserve">
    <value>Indicates if the domain name must contain the name of the field that references it.</value>
  </data>
  <data name="QaSchemaFieldDomainNames_expectedCase" xml:space="preserve">
    <value>The expected character case for the domain name.</value>
  </data>
  <data name="QaSchemaFieldProperties_0" xml:space="preserve">
    <value>Verifies if a field has expected properties</value>
  </data>
  <data name="QaSchemaFieldProperties_table" xml:space="preserve">
    <value>The table to check the field properties in.</value>
  </data>
  <data name="QaSchemaFieldProperties_fieldName" xml:space="preserve">
    <value>The name of the field to check the field properties for.</value>
  </data>
  <data name="QaSchemaFieldProperties_expectedFieldType" xml:space="preserve">
    <value>The expected field type.</value>
  </data>
  <data name="QaSchemaFieldProperties_expectedFieldLength" xml:space="preserve">
    <value>The expected field length. If 0 or negative, no length check is applied.</value>
  </data>
  <data name="QaSchemaFieldProperties_expectedAliasName" xml:space="preserve">
    <value>The expected alias name for the field (optional).</value>
  </data>
  <data name="QaSchemaFieldProperties_expectedDomainName" xml:space="preserve">
    <value>The expected domain name for the field (optional).</value>
  </data>
  <data name="QaSchemaFieldProperties_fieldIsOptional" xml:space="preserve">
    <value>Indicates if the field is not required to exist in the table (may be useful when testing for standardized fields that are not present in all tables).</value>
  </data>
  <data name="QaSchemaSpatialReference_0" xml:space="preserve">
    <value>Checks if the spatial reference of a feature class is exactly (including domain, tolerance and resolution) equal to the spatial reference of a reference feature class.</value>
  </data>
  <data name="QaSchemaSpatialReference_featureClass" xml:space="preserve">
    <value>The feature class to check the spatial reference for.</value>
  </data>
  <data name="QaSchemaSpatialReference_referenceFeatureClass" xml:space="preserve">
    <value>The reference feature class to compare the spatial reference with.</value>
  </data>
  <data name="QaSchemaSpatialReference_1" xml:space="preserve">
    <value>Checks if the spatial reference of a feature class is exactly (including domain, tolerance and resolution) equal to the spatial reference defined in an spatial reference xml string.</value>
  </data>
  <data name="QaSchemaSpatialReference_spatialReferenceXml" xml:space="preserve">
    <value>The spatial reference xml string (as used in geodatabase workspace xml files).</value>
  </data>
  <data name="QaNoGaps_0" xml:space="preserve">
    <value>Finds areas in 'polygonClass' with no covering features ( = gaps)</value>
  </data>
  <data name="QaNoGaps_1" xml:space="preserve">
    <value>Finds areas that are not covered by any feature out of 'polygonClasses' ( = gaps)</value>
  </data>
  <data name="QaNoGaps_2" xml:space="preserve">
    <value>Finds areas in 'polygonClass' with no covering features ( = gaps)</value>
  </data>
  <data name="QaNoGaps_3" xml:space="preserve">
    <value>Finds areas that are not covered by any feature out of 'polygonClasses' ( = gaps)</value>
  </data>
  <data name="QaNoGaps_4" xml:space="preserve">
    <value>Finds areas inside polygons in 'areaOfInterestClasses' that are not covered by any feature out of 'polygonClasses' ( = gaps)</value>
  </data>
  <data name="QaNoGaps_5" xml:space="preserve">
    <value>Finds areas inside polygons in 'areaOfInterestClasses' that are not covered by any feature out of 'polygonClasses' ( = gaps)</value>
  </data>
  <data name="QaNoGaps_maxArea" xml:space="preserve">
    <value>If 'maxArea' &gt; 0: Only gaps where the area is smaller than 'maxArea' will be reported.
If 'maxArea' &lt;= 0: the 'maxArea' is not considered.</value>
  </data>
  <data name="QaNoGaps_polygonClass" xml:space="preserve">
    <value>polygon class to test</value>
  </data>
  <data name="QaNoGaps_polygonClasses" xml:space="preserve">
    <value>List of polygon classes that should have no gaps</value>
  </data>
  <data name="QaNoGaps_sliverLimit" xml:space="preserve">
    <value>If 'sliverLimit' &gt; 0: Only gaps where the ratio between the square of the perimeter and the area is larger than 'sliverLimit' will be reported.
If 'sliverLimit' &lt;= 0: the sliverLimit is not considered.</value>
  </data>
  <data name="QaLineConnectionFieldValues_0" xml:space="preserve">
    <value>Checks constraints for the distinct values of fields from connected line and point features at a location.</value>
  </data>
  <data name="QaLineConnectionFieldValues_1" xml:space="preserve">
    <value>Checks constraints for the distinct values of fields from connected line and point features at a location.</value>
  </data>
  <data name="QaLineConnectionFieldValues_lineClass" xml:space="preserve">
    <value>Polyline featureClass</value>
  </data>
  <data name="QaLineConnectionFieldValues_lineClasses" xml:space="preserve">
    <value>Polyline featureClasses. 'lineClasses' and 'lineFields' must correspond.</value>
  </data>
  <data name="QaLineConnectionFieldValues_lineField" xml:space="preserve">
    <value>Field of 'lineClass' checked for equality at connections</value>
  </data>
  <data name="QaLineConnectionFieldValues_lineFields" xml:space="preserve">
    <value>Fields of 'lineClasses' to use for checking the specified constraints. There must be either a single line field value in the list which is valid for all feature classes in 'lineClasses', or there must be one entry in 'lineFields' per entry in 'lineClasses' and the two lists must be sorted in equal order.</value>
  </data>
  <data name="QaLineConnectionFieldValues_pointClass" xml:space="preserve">
    <value>Point featureClass</value>
  </data>
  <data name="QaLineConnectionFieldValues_pointField" xml:space="preserve">
    <value>Field of 'pointClass' to use for checking the specified constraint.</value>
  </data>
  <data name="QaNoTouchingParts_0" xml:space="preserve">
    <value>Finds points in polygon or polyline features where parts of the same feature touch</value>
  </data>
  <data name="QaNoTouchingParts_featureClass" xml:space="preserve">
    <value>The feature class to check for touching parts</value>
  </data>
  <data name="QaNoClosedPaths_0" xml:space="preserve">
    <value>Finds closed paths (loops) in polyline features</value>
  </data>
  <data name="QaNoClosedPaths_polylineClass" xml:space="preserve">
    <value>The polyline feature class to check for closed paths</value>
  </data>
  <data name="QaContainsOther_isContainingCondition" xml:space="preserve">
    <value>Condition that must be fulfilled for a pair of features from 'contains' and 'isWithin'. If the condition is not fulfilled, the feature from 'contains' is ignored.
The feature from 'contains' can be addressed as 'G1' in the condition, the feature from 'isWithin' as 'G2'.</value>
  </data>
  <data name="QaIsCoveredByOther_2" xml:space="preserve">
    <value>Finds all features in 'covered' that are not fully covered by the features in 'covering' for which a given condition is fulfilled

Remarks: All feature classes in 'covered' and 'covering' must have the same spatial reference.</value>
  </data>
  <data name="QaIsCoveredByOther_3" xml:space="preserve">
    <value>Finds all features in 'covered' that are not fully covered by the features in 'covering' for which a given condition is fulfilled

Remarks: All feature classes in 'covered' and 'covering' must have the same spatial reference.</value>
  </data>
  <data name="QaIsCoveredByOther_isCoveringCondition" xml:space="preserve">
    <value>Condition that must be fulfilled for a pair of features from 'covering' and 'covered'. If the condition is not fulfilled, the feature from 'covering' is ignored and does not contribute to the covering area for the 'covered' feature.
The feature from 'covering' can be addressed as 'G1' in the condition, the feature from 'covered' as 'G2'.</value>
  </data>
  <data name="QaContainsOther_1" xml:space="preserve">
    <value>Finds all features in 'isWithin' that are not contained by any feature in 'contains'
Remarks: All feature classes in 'contains' and 'isWithin' must have the same spatial reference</value>
  </data>
  <data name="QaContainsOther_2" xml:space="preserve">
    <value>Finds all features in 'isWithin' that are not contained by any feature in 'contains' for which a given condition is fulfilled.
Remarks: All feature classes in 'contains' and 'isWithin' must have the same spatial reference</value>
  </data>
  <data name="QaContainsOther_3" xml:space="preserve">
    <value>Finds all features in 'isWithin' that are not contained by any feature in 'contains' for which a given condition is fulfilled.
Remarks: All feature classes in 'contains' and 'isWithin' must have the same spatial reference</value>
  </data>
  <data name="QaGroupConstraints_0" xml:space="preserve">
    <value>Checks if the number of distinct values of an expression (which may be a single field or a more complex expression involving field concatenation, value translation, substring extraction etc.) within groups defined by a 'group by' expression (which also may be a single field or a more complex expression on fields) does not exceed an allowed maximum value.</value>
  </data>
  <data name="QaGroupConstraints_distinctExpression" xml:space="preserve">
    <value>The name of a field whose number of distinct values within groups defined by 'groupByExpression' should be evaluated. Instead of a simple field name, a more complex expression that evaluates to a scalar value may be used. The syntax for these expressions is described here:

http://www.csharp-examples.net/dataview-rowfilter/ 
http://msdn.microsoft.com/en-us/library/system.data.datacolumn.expression.aspx

Typical elements of such an expression are substring extraction using SUBSTRING(),  string concatenation using '+' (e.g. FIELD1 + '#' +FIELD2), or string length evaluation using LEN(). Note that the aggregation functions (AVG(), MAX() etc.) of the expression language are not valid in this context.</value>
  </data>
  <data name="QaGroupConstraints_groupByExpression" xml:space="preserve">
    <value>The name of a field whose values define groups for which the number of distinct values of 'distinctExpression' are evaluated. As for 'distinctExpression' a more complex expression may be used instead of a single field (see. description for 'distinctExpression').</value>
  </data>
  <data name="QaGroupConstraints_limitToTestedRows" xml:space="preserve">
    <value>Indicates if the number of distinct values within the groups found within the tested rows (e.g. rows in the test perimeter, or individually selected rows) should be calculated from only the tested rows (true), or if the distinct count within those groups should be calculated based on the entire table (false). 

Setting this to false ensures that all errors are found, however those errors may be caused by rows outside the selection of interest (which therefore may not be correctable in a given work context). Also the performance may be too slow for some work contexts.
This option exists to speed up and focus the test when editing in a narrow subsets of the table. Such a test configuration should always be accompanied by another test that sets this parameter to false, and is run at appropriate times to make sure all constraint violations are ultimately detected.</value>
  </data>
  <data name="QaGroupConstraints_maxDistinctCount" xml:space="preserve">
    <value>The maximum number of distinct values returned from 'distinctExpression', per group value defined by 'groupByExpression'</value>
  </data>
  <data name="QaGroupConstraints_table" xml:space="preserve">
    <value>The table to apply group constraints to.</value>
  </data>
  <data name="QaLineConnectionFieldValues_2" xml:space="preserve">
    <value>Checks constraints for the distinct values of fields from connected lines at a location.</value>
  </data>
  <data name="QaLineConnectionFieldValues_3" xml:space="preserve">
    <value>Checks constraints for the distinct values of fields from connected lines at a location.</value>
  </data>
  <data name="QaLineConnectionFieldValues_lineFieldValuesConstraint" xml:space="preserve">
    <value>Constraints on the field values of connected lines.

- NoConstraint [0]: all line field values are valid
- AllEqual [1]: field values of all connected lines must be equal
- AllEqualOrValidPointExists [2]: field values all all connected lines must be equal, or a valid point must exist at the connection location. If a point exists and has it's constraint fulfilled, distinct line field values are allowed.</value>
  </data>
  <data name="QaLineConnectionFieldValues_pointFieldValuesConstraint" xml:space="preserve">
    <value>Constraints on the field values of connected points (points coincident with other point features and line feature endpoints)

- NoConstraint [0]: all point field values are valid
- AllEqualAndMatchAnyLineValue [1]: all field values of connected points must be equal, and that one value must be equal to *any* of the line field values of the connected lines.
- AllEqualAndMatchMostFrequentLineValue [2]: all field values of connected points must be equal, and that one value must be equal to the most frequent value of the specified line fields for the connected lines.</value>
  </data>
  <data name="QaLineConnectionFieldValues_allowedPointsExpression" xml:space="preserve">
    <value>Expression to identify points in 'pointClass' that are considered valid regardless of their values of the 'pointField' field name or expression.</value>
  </data>
  <data name="QaNoGaps_subtileWidth" xml:space="preserve">
    <value>The width of sub-tiles in the processed tile, used for partitioning the gap detection in a test container tile. 

Finding gaps can be a memory-intensive process in the case of polygons with very large numbers of vertices (tens to hundreds of thousands). To avoid out-of-memory errors, the test can be instructed to work on smaller pieces of the test tile. In the case of excessive memory consumption during this test, it is recommended to set this subtile width to 1/5 of the configured tile size (e.g. 2'000m in case of a 10'000m tile size), and observe resulting the memory consumption (using the Private Bytes counter in Performance Monitor, for the ArcMap process). As a rule of thumb, if the 'Private Bytes' memory consumption raises above 800-900 Mb during this test, a smaller subtile width can be tried. Note that processing overhead increases with smaller subtile widths. This has a negative impact on response times with subtile widths of less than 1/10 of the test tile size. 

A subtile width of 0 indicates that no subtiles should be used, instead the gap detection will process the entire test tile at once.</value>
  </data>
  <data name="QaNoGaps_findGapsBelowTolerance" xml:space="preserve">
    <value>Indicates if the test should find gaps that are smaller than the xy tolerance of the spatial reference of the polygon feature classes. This option will not be needed for feature classes that are regularly consolidated using topology validation or the geoprocessing tool 'Integrate', since those operations will automatically eliminate gaps smaller than the tolerance.
    
This option increases the memory usage of the test significantly, and should be used carefully for polygons with very large vertex counts. It may be necessary to use sub-tiles for testing by specifying a value for 'subtileWidth'.
  
Note that the error geometries of gaps smaller than the xy tolerance may not be accurately represented, due to tolerance effects.</value>
  </data>
  <data name="QaContainsOther_reportIndividualParts" xml:space="preserve">
    <value>Indicates if the non-contained geometry parts should be reported as individual errors (true), or as a single, multi-part error geometry (false)</value>
  </data>
  <data name="QaNoGaps_areaOfInterestClasses" xml:space="preserve">
    <value>List of polygon feature classes that delineate the area of interest within which gaps should be detected. 
    
Note that gaps between the polygons and the limit of the combined area of interest will potentially also be reported as errors.</value>
  </data>
  <data name="QaPartCoincidence_coincidenceTolerance" xml:space="preserve">
    <value>Tolerance for line sections to be considered as coincident (default: 0 --&gt; sections must be exactly coincident)</value>
  </data>
  <data name="QaPartCoincidence_connectedMinLength" xml:space="preserve">
    <value>minimum length to report line sections, that are near but not coincident, and touch or cross the neighboring line sections</value>
  </data>
  <data name="QaPartCoincidence_disjointMinLength" xml:space="preserve">
    <value>minimum length to report line sections, that are near but not coincident, and never touch or cross the neighboring line sections</value>
  </data>
  <data name="QaWithinZRange_0" xml:space="preserve">
    <value>Finds features with Z values outside of a defined range.

- Supported for points, lines, polygons, multipoints and multipatches.
- For lines and polygons, individual errors are reported for consecutive segments (or parts of segments) exceeding the same boundary of the Z range.
- For multipoints and multipatches, one error is reported for all points exceeding the same boundary of the Z range.</value>
  </data>
  <data name="QaWithinZRange_featureClass" xml:space="preserve">
    <value>The feature class to check for Z values outside of the defined range</value>
  </data>
  <data name="QaWithinZRange_minimumZValue" xml:space="preserve">
    <value>The lower boundary of the range of valid Z values. 

Z values smaller than this value are considered invalid.</value>
  </data>
  <data name="QaWithinZRange_maximumZValue" xml:space="preserve">
    <value>The upper boundary of the range of valid Z values.

Z values larger than this value are considered invalid.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_0" xml:space="preserve">
    <value>Finds discontinuities in the M values at connections between line features of the same route.
    
The connecting end points of lines within the same route must have the same M values, otherwise an error is reported. M values with a difference smaller than the M tolerance of the spatial reference are considered equal.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_1" xml:space="preserve">
    <value>Finds discontinuities in the M values at connections between line features of the same route.
    
The connecting end points of lines within the same route must have the same M values, otherwise an error is reported. M values with a difference smaller than the M tolerance of the spatial reference are considered equal.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_polylineClass" xml:space="preserve">
    <value>The line feature class that contains the routes to check for M discontinuities.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_polylineClasses" xml:space="preserve">
    <value>The line feature classes that contain the routes to check for M discontinuities.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_routeIdField" xml:space="preserve">
    <value>The name of the field that contains the route IDs. Features having the same route id belong to the same route.</value>
  </data>
  <data name="QaRouteMeasuresContinuous_routeIdFields" xml:space="preserve">
    <value>The names of the fields that contains the route IDs. Features having the same route id belong to the same route.
    
If one field name is specified, that field name must exist in all the specified feature classes. If individual field names per feature class should be used, then one field name per feature class must be present in the list. Field names are matched to feature classes by their position in the list.</value>
  </data>
  <data name="QaMeasures_0" xml:space="preserve">
    <value>Finds vertices or segments with undefined (NaN) M values.</value>
  </data>
  <data name="QaMeasures_featureClass" xml:space="preserve">
    <value>The feature class to check the M values for.</value>
  </data>
  <data name="QaInteriorRings_0" xml:space="preserve">
    <value>Finds interior rings of polygon features that exceed a given maximum ring count. Optionally, only inner rings that are smaller than a specified area are reported.</value>
  </data>
  <data name="QaInteriorRings_polygonClass" xml:space="preserve">
    <value>The polygon feature class to check for interior rings.</value>
  </data>
  <data name="QaInteriorRings_maximumInteriorRingCount" xml:space="preserve">
    <value>The maximum allowed number of interior rings per polygon. With a value of 0, all interior rings are reported.
    
If the number of interior rings in a polygon exceeds this value, the smallest rings exceeding the allowed maximum number of rings are reported, unless 'ReportOnlySmallestRingsExceedingMaximumCount' is set to false, in which case all rings are reported.</value>
  </data>
  <data name="QaContainedPointsCount_0" xml:space="preserve">
    <value>Finds polygons or polylines with an invalid number of contained points</value>
  </data>
  <data name="QaContainedPointsCount_1" xml:space="preserve">
    <value>Finds polygons or polylines with an invalid number of contained points</value>
  </data>
  <data name="QaContainedPointsCount_2" xml:space="preserve">
    <value>Finds polygons or polylines with an invalid number of contained points</value>
  </data>
  <data name="QaContainedPointsCount_3" xml:space="preserve">
    <value>Finds polygons or polylines with an invalid number of contained points</value>
  </data>
  <data name="QaContainedPointsCount_4" xml:space="preserve">
    <value>Finds polygons or polylines with an invalid number of contained points</value>
  </data>
  <data name="QaContainedPointsCount_polygonClass" xml:space="preserve">
    <value>The polygon or polyline feature class to check for invalid contained point counts.</value>
  </data>
  <data name="QaContainedPointsCount_polygonClasses" xml:space="preserve">
    <value>The polygon or polyline feature classes to check for invalid contained point counts.</value>
  </data>
  <data name="QaContainedPointsCount_pointClass" xml:space="preserve">
    <value>The point feature class with the points to count per polygon/polyline.</value>
  </data>
  <data name="QaContainedPointsCount_pointClasses" xml:space="preserve">
    <value>The point feature classes with the points to count per polygon/polyline.</value>
  </data>
  <data name="QaContainedPointsCount_expectedPointCount" xml:space="preserve">
    <value>The expected number of relevant points per polygon/polyline.</value>
  </data>
  <data name="QaContainedPointsCount_minimumPointCount" xml:space="preserve">
    <value>The minimum number of relevant points per polygon/polyline.</value>
  </data>
  <data name="QaContainedPointsCount_maximumPointCount" xml:space="preserve">
    <value>The maximum number of relevant points per polygon/polyline.</value>
  </data>
  <data name="QaContainedPointsCount_relevantPointCondition" xml:space="preserve">
    <value>Condition expression to determine if a point is relevant for a containing feature. If the condition is defined and not fulfilled for a containing feature/point pair, then the point is not considered relevant for the feature.
The containing polygon/polyline and the point features are aliased using "POLYGON" and "POINT", respectively.

Note that for polyline features (for which support was added later) are also aliased using "POLYGON"

Example: POLYGON.FACILITY_ID = POINT.FACILITY_ID</value>
  </data>
  <data name="QaContainedPointsCount_countPointOnPolygonBorder" xml:space="preserve">
    <value>Indicates if points exactly on the polygon boundary/polyline end points should be counted for the polygon/polyline.</value>
  </data>
  <data name="QaValidNonLinearSegments_0" xml:space="preserve">
    <value>Finds features with invalid non-linear segments. Currently, circular arcs that degenerated to a line and therefore have no center point are found.</value>
  </data>
  <data name="QaValidNonLinearSegments_featureClass" xml:space="preserve">
    <value>Polyline or polygon feature class</value>
  </data>
  <data name="QaValidNonLinearSegments_1" xml:space="preserve">
    <value>Finds features with invalid non-linear segments. Currently, circular arcs that degenerated to a line and therefore have no center point are found. Additionally, circular arcs with a chord height smaller than a specified value may be identified.</value>
  </data>
  <data name="QaValidNonLinearSegments_minimumChordHeight" xml:space="preserve">
    <value>A minimum chord height for the circular arc to be considered valid. Circular arcs with cord heights smaller than the xy tolerance are converted to degenerated, linear circular arcs (radius = infinity, center point =null, cord height =0). If the features are to be transformed into another spatial reference with larger tolerance, this property can be used to detect segments that will degenerate during that transformation.</value>
  </data>
  <data name="QaLineIntersect_4" xml:space="preserve">
    <value>Finds all features in 'polylineClasses' that have invalid point intersections with any other feature in 'polylineClasses', and for which a given constraint is not fulfilled. Invalid point intersections are points where lines cross, and where end points of one line have an unallowed intersection with the interior of the other line. Optionally, linear intersections are also reported (based on the Overlaps relation between the line geometries). Without this option, only point intersections are reported.</value>
  </data>
  <data name="QaLineIntersect_allowedEndpointInteriorIntersections" xml:space="preserve">
    <value>Specifies the allowed intersections of an end point of one line with the interior of another line. 
- All: all intersections of end points with line interiors are allowed
- Vertex: intersections of line end points with the interior of another line are allowed, if the intersection point is on a vertex of the other line
- None: end points may only connect to end points of other lines, never to the interior of other lines</value>
  </data>
  <data name="QaLineIntersect_reportOverlaps" xml:space="preserve">
    <value>Indicates that overlaps between intersecting lines should be reported. The end points of the linear overlap intersection will be reported.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_4" xml:space="preserve">
    <value>Finds all pairs of features in a list of feature classes with intersecting interiors, and for which a given constraint is not fulfilled. Optionally, all intersections between two features can be reported as one error with multipart error geometry.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_reportIntersectionsAsMultipart" xml:space="preserve">
    <value>Indicates that multiple intersections between two features should be reported as one error with multipart geometry. Otherwise, individual errors are reported for every intersection area.</value>
  </data>
  <data name="QaNeighbourAreas_2" xml:space="preserve">
    <value>Finds all touching features in 'polygonClass' for which all values of editable attributes are equal. Optionally allows to ignore polygon pairs that intersect in points only.</value>
  </data>
  <data name="QaNeighbourAreas_3" xml:space="preserve">
    <value>Finds all touching features in 'polygonClass' for which the values of a defined list of fields are equal. This field list can be defined by a concatenated string of either relevant or ignored fields. Optionally allows to ignore polygon pairs that intersect in points only.</value>
  </data>
  <data name="QaNeighbourAreas_4" xml:space="preserve">
    <value>Finds all touching features in 'polygonClass' for which the values of a defined list of fields are equal. This field list can be defined by a list of either relevant or ignored fields. Optionally allows to ignore polygon pairs that intersect in points only.</value>
  </data>
  <data name="QaNeighbourAreas_fieldListType" xml:space="preserve">
    <value>Specifies how the specified list of fields should be interpreted:
- RelevantFields: the list contains the fields that should be compared.
- IgnoredFields: the list contains the fields that should not be compared. All editable fields except the ones in the list are compared.</value>
  </data>
  <data name="QaNeighbourAreas_fields" xml:space="preserve">
    <value>The list of field names.</value>
  </data>
  <data name="QaNeighbourAreas_fieldsString" xml:space="preserve">
    <value>A concatenated string of field names. The names may be separated by blank, comma or semicolon.</value>
  </data>
  <data name="QaTrimmedTextFields_5" xml:space="preserve">
    <value>Finds rows that have leading or trailing whitespace characters in a given list of text fields. The field list can be defined by a concatenated string of either relevant or ignored fields. If the field contains only whitespace, a maximum number of allowed whitespace characters can specified.</value>
  </data>
  <data name="QaTrimmedTextFields_6" xml:space="preserve">
    <value>Finds rows that have leading or trailing whitespace characters in a given list of text fields. The field list can be defined by a list of either relevant or ignored fields. If the field contains only whitespace, a maximum number of allowed whitespace characters can specified.</value>
  </data>
  <data name="QaTrimmedTextFields_fieldListType" xml:space="preserve">
    <value>Specifies how the specified list of fields should be interpreted:
- RelevantFields: the list contains the fields that should be checked for trailing/leading whitespace
- IgnoredFields: the list contains the fields that should not be checked. All editable fields except the ones in the list will be checked.</value>
  </data>
  <data name="QaTrimmedTextFields_textFieldNamesString" xml:space="preserve">
    <value>A concatenated string of field names. The names may be separated by blank, comma or semicolon.</value>
  </data>
  <data name="QaLineIntersectZ_4" xml:space="preserve">
    <value>Finds intersections of features in 'polylineClasses' where the height difference is smaller than 'minimum' or larger than 'maximum' or 'constraint' is not fulfilled

Remark: The feature classes in 'polylineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaLineIntersectZ_maximumZDifference" xml:space="preserve">
    <value>maximum height difference in z-Units.
if 'maximumZDifference' &lt;= 0, maximum height difference is not checked</value>
  </data>
  <data name="QaLineIntersectZ_minimumZDifference" xml:space="preserve">
    <value>minimum height difference in z-Units.
if 'minimumZDifference' &lt;= 0, minimum height difference is not checked</value>
  </data>
  <data name="QaUnreferencedRows_0" xml:space="preserve">
    <value>Finds rows in a table that are not referenced by any row in a collection of referencing tables</value>
  </data>
  <data name="QaUnreferencedRows_referencedTable" xml:space="preserve">
    <value>The table to search for unreferenced rows</value>
  </data>
  <data name="QaUnreferencedRows_referencingTables" xml:space="preserve">
    <value>The tables with relationships to the referenced table. These tables are not required to reside in the same database as the reference table.</value>
  </data>
  <data name="QaUnreferencedRows_relations" xml:space="preserve">
    <value>The definition of relationships between referencing tables and referenced table. For each referencing table, there must be a corresponding 'relation' definition. A 'relation' definition lists the relevant field names, and for n:m relationships, the relationship table. Note that all relations must refer to the same key field in the referenced table.

The following format is used for 'relation' entries:

- n:1 and 1:1 relationships:

&lt;keyfield_in_referenced_table&gt;,&lt;foreignkeyfield_in_referencing_table&gt;

- n:m relationships:

&lt;keyfield_in_referenced_table&gt;,&lt;relationship_table_foreignkeyfield_to_referenced_table,&lt;relationship_table_name&gt;,&lt;relationship_table_foreignkeyfield_to_referencing_table&gt;,&lt;keyfield_in_referencing_table&gt;

For n:m relationships, the relationship_table must reside in the same database as the corresponding referencing table.</value>
  </data>
  <data name="QaNonEmptyGeometry_dontFilterPolycurvesByZeroLength" xml:space="preserve">
    <value>For polygons and polylines, the features are normally filtered to those with length = 0, in addition to any supplied filter expression for the table. By setting this parameter to 'true', the length-based filtering can be suppressed. In this case only the filter expression for the table is applied, if any. This may result in a large number of features being read and checked for empty geometry.</value>
  </data>
  <data name="QaMeasures_1" xml:space="preserve">
    <value>Finds vertices or segments with an invalid M value.</value>
  </data>
  <data name="QaDangleCount_0" xml:space="preserve">
    <value>Finds polyline features with a dangle count for which a given dangle count expression is not fulfilled. Dangles are defined as polyline end points that are not (within a specified tolerance) coincident with end points of other polylines.</value>
  </data>
  <data name="QaMeasures_invalidValue" xml:space="preserve">
    <value>The invalid M value to check for.</value>
  </data>
  <data name="QaDangleCount_1" xml:space="preserve">
    <value>Finds polyline features with a dangle count for which a given dangle count expression is not fulfilled. Dangles are defined as polyline end points that are not (within a specified tolerance) coincident with end points of other polylines.</value>
  </data>
  <data name="QaDangleCount_dangleCountExpression" xml:space="preserve">
    <value>An SQL expression used as condition for valid dangle counts. 

The number of dangles for a given feature can be addressed in the expression as _DangleCount. This value may be compared against constants or expressions involving field values of the verified features.

Examples: 
- _DangleCount &lt; 2
- _DangleCount =IsNull(DANGLES, 0)</value>
  </data>
  <data name="QaDangleCount_dangleCountExpressions" xml:space="preserve">
    <value>SQL expressions used as conditions for valid dangle counts, for the respective feature classes. The number of expressions must be either equal to the number of feature classes (in which case the expressions are associated with the feature classes by their list index), or there can be exactly one expression which is used for all specified feature classes.

The number of dangles for a given feature can be addressed in the expression as _DangleCount. This value may be compared against constants or expressions involving field values of the verified features.

Examples: 
- _DangleCount &lt; 2
- _DangleCount =IsNull(DANGLES, 0)</value>
  </data>
  <data name="QaDangleCount_polylineClass" xml:space="preserve">
    <value>Polyline feature class to check for invalid dangle counts. Dangles are identified as end points that are not connected to any other polyline from the same feature class, subject to the defined filter expression.</value>
  </data>
  <data name="QaDangleCount_polylineClasses" xml:space="preserve">
    <value>Polyline feature classes to check for invalid dangle counts. Dangles are identified as end points that are not connected to any other polyline from any of the feature classes, subject to the defined filter expressions.</value>
  </data>
  <data name="QaDangleCount_tolerance" xml:space="preserve">
    <value>Tolerance for finding coincident end points. End points that lie within the tolerance from other end points are considered coincident. A zero tolerance can be specified to require that end points are exactly coincident (requiring equal resolution grids) to be considered connected.</value>
  </data>
  <data name="QaSurfacePipe_1" xml:space="preserve">
    <value>Finds all line segments in 'featureClass' that differ more than 'limit' from 'terrain'

Remark: The feature classes in 'featureClass' and 'terrain' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfacePipe_asRatio" xml:space="preserve">
    <value>True: 'startEndIgnoreLength' is given as ratio of the shape length
False: 'startEndIgnoreLength' is the absolute length in units of 'featureClass'</value>
  </data>
  <data name="QaSurfacePipe_startEndIgnoreLength" xml:space="preserve">
    <value>Ignore line parts closer than 'startEndIgnoreLength' to the start/end point of the shape</value>
  </data>
  <data name="QaSurfacePipe_zOffsetConstraint" xml:space="preserve">
    <value>AboveLimit : All z-values must be above surface height + 'limit'
BelowLimit : All z-values must be below surface height + 'limit' (For underground, 'limit' must be &lt; 0)
WithinLimit: All z-values must be below surface height + 'limit' and above surface height - 'limit'
OutsideLimit: All z-values must be either above surface height + 'limit' or below surface height - 'limit'</value>
  </data>
  <data name="QaDuplicateGeometrySelf_2" xml:space="preserve">
    <value>Finds features with equal geometries in a feature class for which a given constraint is not fulfilled. Geometries for which the difference geometry is empty are considered duplicates. Z and M values are therefore ignored, and the XY tolerance of the spatial reference is applied. Optionally, duplicates can be reported as a single error for the entire set of features that have an equal geometry.</value>
  </data>
  <data name="QaDuplicateGeometrySelf_reportSingleErrorPerDuplicateSet" xml:space="preserve">
    <value>Indicates if a single error should be reported for the complete set of features with equal geometries. If 'false', individual errors are reported for each pair of features with equal geometries. If a validDuplicateConstraint is specified, the pairwise error reporting allows to include the field values for the constraint in the error description. </value>
  </data>
  <data name="QaForeignKey_1" xml:space="preserve">
    <value>Finds rows that have a key value combination that does not refer to a value combination in a referenced table.</value>
  </data>
  <data name="QaForeignKey_foreignKeyFields" xml:space="preserve">
    <value>The list of foreign key fields in 'table'. This list must contain the same number of elements as 'referencedKeyFields', and the matching fields must be at the same position in the two field lists.</value>
  </data>
  <data name="QaForeignKey_referencedKeyFields" xml:space="preserve">
    <value>the key fields in the referenced table. The values in these fields are loaded into memory. For very large referenced tables that are in the same database as 'table' the test factory QaRelConstraint may be a better choice since it joins the tables in the database instead of loading the referenced keys into memory. The memory usage of this test is logged at verbose debug level.</value>
  </data>
  <data name="QaNodeLineCoincidence_is3D" xml:space="preserve">
    <value>Indicates if the 3D distance between nodes and near features should be checked, for features that have Z values. If 'false', the 2D distance is checked.</value>
  </data>
  <data name="QaMeasuresAtPoints_0" xml:space="preserve">
    <value>Finds points on 'lineClasses' whose m-Values differ from the neighboring 'pointClass'-point

Remark: All feature classes in 'pointClass' and 'lineClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaMeasuresAtPoints_expectedMValueExpression" xml:space="preserve">
    <value>Expression for getting the expected measure value for a point of 'pointClass':
- if 'expectedMValueExpression' = null, the M-value of the point is used
- otherwise the field that defines the measure value. Instead of a simple field name, a more complex expression that evaluates to a scalar value may be used. The syntax for these expressions is described here:

http://www.csharp-examples.net/dataview-rowfilter/ 
http://msdn.microsoft.com/en-us/library/system.data.datacolumn.expression.aspx</value>
  </data>
  <data name="QaMeasuresAtPoints_lineClasses" xml:space="preserve">
    <value>Line or polygon featureClasses to be tested</value>
  </data>
  <data name="QaMeasuresAtPoints_lineMSource" xml:space="preserve">
    <value>defines the point of a line which measure will be compared:
-Nearest: the nearest segment point or vertex is taken
-VertexPreferred: if a vertex lies within 'searchDistance' of the point, this vertex, otherwise the nearest segment point
-VertexRequired: a vertex must lie within the 'searchDistance' of a point from 'pointClass' closer than 'searchDistance' to the line, and this vertex is compared</value>
  </data>
  <data name="QaMeasuresAtPoints_mTolerance" xml:space="preserve">
    <value>maximum allow difference of the point measure value and the corresponding line measure value </value>
  </data>
  <data name="QaMeasuresAtPoints_pointClass" xml:space="preserve">
    <value>Point featureClass providing measure information dependent on 'expectedMValueExpression'</value>
  </data>
  <data name="QaGroupConstraints_1" xml:space="preserve">
    <value>Checks if the number of distinct values of an expression (which may be a single field or a more complex expression involving field concatenation, value translation, substring extraction etc.) within groups defined by a 'group by' expression (which also may be a single field or a more complex expression on fields) does not exceed an allowed maximum value.

Example:
Table A with Field 'KeyA' with a row KeyA = 5
Table B with Field 'KeyB' with a row KeyB = 5

Test with QaGroupConstraint({A,B}, {KeyA,KeyB}, {'name A', 'name B'}, 1, false).

The row of table A and the row of table B belong to the same group, 5, evaluated by the corresponding groupByExpressions. In this group there are 2 distinct values, 'name A' from the row in table A and 'name B' from the row in table B. So the group 5 will be reported as error, because only 1  distinct value (see maxDistinctCount) is allowed.

</value>
  </data>
  <data name="QaGroupConstraints_distinctExpressions" xml:space="preserve">
    <value>The name of fields whose number of distinct values within groups defined by 'groupByExpressions' should be evaluated. Instead of a simple field name, a more complex expression that evaluates to a scalar value may be used.
The syntax for these expressions is described here:

http://www.csharp-examples.net/dataview-rowfilter/ 
http://msdn.microsoft.com/en-us/library/system.data.datacolumn.expression.aspx

Typical elements of such an expression are substring extraction using SUBSTRING(),  string concatenation using '+' (e.g. FIELD1 + '#' +FIELD2), or string length evaluation using LEN(). Note that the aggregation functions (AVG(), MAX() etc.) of the expression language are not valid in this context.</value>
  </data>
  <data name="QaGroupConstraints_groupByExpressions" xml:space="preserve">
    <value>The names of fields whose values define groups for which the number of distinct values of 'distinctExpressions' are evaluated. The groups are evaluated over all 'tables', meaning if a group value exists in table a and in table b, the corresponding rows are grouped together. 
As for 'distinctExpressions' a more complex expression may be used instead of a single field (see. description for 'distinctExpressions').</value>
  </data>
  <data name="QaGroupConstraints_tables" xml:space="preserve">
    <value>The tables to apply group constraints to. For each table in 'tables' there must be a corresponding groupByExpression and distinctExpression</value>
  </data>
  <data name="QaMeasuresAtPoints_requireLine" xml:space="preserve">
    <value>if true, at least 1 line must lie closer than 'searchDistance' to a point of 'pointClass'</value>
  </data>
  <data name="QaMeasuresAtPoints_searchDistance" xml:space="preserve">
    <value>maximum distance of a point to a line where measure values are compared </value>
  </data>
  <data name="QaMeasuresAtPoints_ignoreUndefinedExpectedMValue" xml:space="preserve">
    <value>Indicates that point features with an undefined expected M value (either the result of the expected M value expression, or the M value of the point if no expression is specified) should be ignored. If 'false' an error is reported for undefined expected M values.</value>
  </data>
  <data name="QaMeasuresAtPoints_matchExpression" xml:space="preserve">
    <value>Optional expression for matching lines to points. If the expression is defined, a line feature is only checked for a given point if the expression is fulfilled. In the expression, the point feature can be adressed as 'P' and the line features as 'L'.

Example: 

   P.ROUTEID = L.ROUTEID

The syntax for these expressions is described here:

http://www.csharp-examples.net/dataview-rowfilter/ 
http://msdn.microsoft.com/en-us/library/system.data.datacolumn.expression.aspx</value>
  </data>
  <data name="QaRouteMeasuresUnique_0" xml:space="preserve">
    <value>Finds segment sequences within line features belonging to the same route that have the same measure values. Both non-unique measure ranges from different features, and non-unique measures within a single feature (due to non-monotonic measures) are reported.</value>
  </data>
  <data name="QaRouteMeasuresUnique_1" xml:space="preserve">
    <value>Finds segment sequences within line features belonging to the same route that have the same measure values. Both non-unique measure ranges from different features, and non-unique measures within a single feature (due to non-monotonic measures) are reported.</value>
  </data>
  <data name="QaRouteMeasuresUnique_polylineClass" xml:space="preserve">
    <value>Polyline class with M values</value>
  </data>
  <data name="QaRouteMeasuresUnique_polylineClasses" xml:space="preserve">
    <value>Polyline classes with M values</value>
  </data>
  <data name="QaRouteMeasuresUnique_routeIdField" xml:space="preserve">
    <value>The name of the field that contains the route ID. All features having the same route ID are checked for unique M values.</value>
  </data>
  <data name="QaRouteMeasuresUnique_routeIdFields" xml:space="preserve">
    <value>The names of the fields that contains the route ID, per line feature class. All features having the same route ID are checked for unique M values.
If multiple feature classes are specified, there must be either a single route ID field name (to be used for all feature classes), or an equal number of route ID field names and feature classes. Field names are associated to feature classes by their position in the list.</value>
  </data>
  <data name="QaMonotonicMeasures_0" xml:space="preserve">
    <value>Finds non-monotonic sequences in M values</value>
  </data>
  <data name="QaMonotonicMeasures_1" xml:space="preserve">
    <value>Finds non-monotonic sequences in M values for a given direction</value>
  </data>
  <data name="QaMonotonicMeasures_allowConstantValues" xml:space="preserve">
    <value>Indicates if constant M values are not to be treated as errors</value>
  </data>
  <data name="QaMonotonicMeasures_flipExpression" xml:space="preserve">
    <value>Expression to evaluate if feature needs to be flipped for monotonicity evaluation</value>
  </data>
  <data name="QaMonotonicMeasures_lineClass" xml:space="preserve">
    <value>Line feature class</value>
  </data>
  <data name="QaMonotonicMeasures_expectedMonotonicity" xml:space="preserve">
    <value>Expected direction of monotonicity</value>
  </data>
  <data name="QaMustTouchOther_0" xml:space="preserve">
    <value>Finds features that don't touch any other feature in another feature class</value>
  </data>
  <data name="QaMustTouchOther_1" xml:space="preserve">
    <value>Finds features in a list of feature classes that don't touch any other feature in another list of feature classes</value>
  </data>
  <data name="QaMustTouchOther_featureClass" xml:space="preserve">
    <value>Point, line or polygon feature class</value>
  </data>
  <data name="QaMustTouchOther_featureClasses" xml:space="preserve">
    <value>Point, line or polygon feature classes</value>
  </data>
  <data name="QaMustTouchOther_otherFeatureClass" xml:space="preserve">
    <value>Point, line or polygon feature class to be searched for touching features</value>
  </data>
  <data name="QaMustTouchOther_otherFeatureClasses" xml:space="preserve">
    <value>Point, line or polygon feature classes to be searched for touching features</value>
  </data>
  <data name="QaMustTouchOther_relevantRelationCondition" xml:space="preserve">
    <value>Condition on a pair of touching features. The pair only counts as touching if the condition is either undefined or fulfilled.
The feature to be tested is aliased using "G1". The touched ("other") feature is aliased using "G2".</value>
  </data>
  <data name="QaMustTouchSelf_0" xml:space="preserve">
    <value>Finds features that don't touch any other feature in the same feature class</value>
  </data>
  <data name="QaMustTouchSelf_1" xml:space="preserve">
    <value>Finds features in a list of feature classes that don't touch any other feature in the same list of feature classes</value>
  </data>
  <data name="QaMustTouchSelf_featureClass" xml:space="preserve">
    <value>Point, line or polygon feature class</value>
  </data>
  <data name="QaMustTouchSelf_featureClasses" xml:space="preserve">
    <value>Point, line or polygon feature classes</value>
  </data>
  <data name="QaMustTouchSelf_relevantRelationCondition" xml:space="preserve">
    <value>Condition on a pair of touching features. The pair only counts as touching if the condition is either undefined or fulfilled.
The features are aliased using "G1" and "G2".</value>
  </data>
  <data name="QaRowCount_0" xml:space="preserve">
    <value>Determines if the number of rows in a table is within an expected range</value>
  </data>
  <data name="QaRowCount_maximumRowCount" xml:space="preserve">
    <value>The expected maximum row count. A negative value indicates that there is no upper limit for the number of rows in the table.</value>
  </data>
  <data name="QaRowCount_minimumRowCount" xml:space="preserve">
    <value>The expected minimum row count.</value>
  </data>
  <data name="QaRowCount_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaSchemaFieldAliases_expectedDifference" xml:space="preserve">
    <value>The expected difference between the alias name and the field name (for non-system fields)

- Any: no comparison made
- CaseSensitiveDifference: the alias name must be different from the field name. A case-only difference is valid (e.g. alias name 'Name' for field 'NAME' is allowed)
- CaseInsensitiveDifference: the alias name must be different from the field name. A case-only difference is not allowed</value>
  </data>
  <data name="QaMpAllowedPartTypes_0" xml:space="preserve">
    <value>Finds all geometry parts of 'multipatchClass' that not allowed part types</value>
  </data>
  <data name="QaMpAllowedPartTypes_allowRings" xml:space="preserve">
    <value>if false : report all parts that are rings</value>
  </data>
  <data name="QaMpAllowedPartTypes_multiPatchClass" xml:space="preserve">
    <value>multipatch feature class</value>
  </data>
  <data name="QaMpAllowedPartTypes_allowTriangleFans" xml:space="preserve">
    <value>if false : report all parts that are triangleFans</value>
  </data>
  <data name="QaHorizontalSegments_0" xml:space="preserve">
    <value>Finds almost horizontal segments: Find segments with a slope angle smaller than 'limit', but larger than 'tolerance'.</value>
  </data>
  <data name="QaHorizontalSegments_featureClass" xml:space="preserve">
    <value>Polyline, polygon or multipatch feature class</value>
  </data>
  <data name="QaHorizontalSegments_limit" xml:space="preserve">
    <value>Segments with a slope angle &gt; 'limit' [Degree] are not checked. </value>
  </data>
  <data name="QaHorizontalSegments_tolerance" xml:space="preserve">
    <value>Segments with a slope angle &lt;= 'tolerance' [Degree] are not reported. </value>
  </data>
  <data name="QaMpConstantPointIdsPerRing_0" xml:space="preserve">
    <value>Find rings where the pointIds of its points are not constant</value>
  </data>
  <data name="QaMpConstantPointIdsPerRing_includeInnerRings" xml:space="preserve">
    <value>if true: Check that points of inner rings of an outer rings have the same PointIDs as the outer ring's points</value>
  </data>
  <data name="QaMpConstantPointIdsPerRing_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaCoplanarRings_0" xml:space="preserve">
    <value>Finds multipatch or polygon rings where its points are not coplanar</value>
  </data>
  <data name="QaCoplanarRings_coplanarityTolerance" xml:space="preserve">
    <value>maximum allowed offset from the regression plane through all points of a ring. If this value is 0 or smaller than the resolution of the featureclass, the resolution is used</value>
  </data>
  <data name="QaCoplanarRings_featureClass" xml:space="preserve">
    <value>multipatch or polygon feature class</value>
  </data>
  <data name="QaCoplanarRings_includeAssociatedParts" xml:space="preserve">
    <value>Check outer rings together with their inner rings</value>
  </data>
  <data name="QaMpHorizontalAzimuths_0" xml:space="preserve">
    <value>Find all horizontal segments of a multipatch feature where their azimuth's differ less than 'nearAngle' but more than 'azimuthTolerance'</value>
  </data>
  <data name="QaMpHorizontalAzimuths_azimuthTolerance" xml:space="preserve">
    <value>Near segments with azimuths not closer than 'azimuthTolerance' [degree] are reported</value>
  </data>
  <data name="QaMpHorizontalAzimuths_horizontalTolerance" xml:space="preserve">
    <value>Segment with slope angle less than 'horizontalTolerance' are considered horizontal</value>
  </data>
  <data name="QaMpHorizontalAzimuths_nearAngle" xml:space="preserve">
    <value>Segments with azimuths closer than 'nearAngle' [degree] are checked</value>
  </data>
  <data name="QaMpHorizontalAzimuths_perRing" xml:space="preserve">
    <value>if true: check each ring separately; otherwise: check all horizontal segments of the multipatch feature</value>
  </data>
  <data name="QaMpVerticalFaces_0" xml:space="preserve">
    <value>Finds patches in a multipatch that are almost vertical </value>
  </data>
  <data name="QaMpVerticalFaces_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpVerticalFaces_nearAngle" xml:space="preserve">
    <value>Patches with a slope angle &gt; 'nearAngle' [Degree] are checked. nearAngle is i.e. 85 [°]</value>
  </data>
  <data name="QaMpVerticalFaces_toleranceAngle" xml:space="preserve">
    <value>Patches where the slope angle is not closer than 'toleranceAngle' to 90° are reported. 'toleranceAngle' i.e 0.5 [°]. 
If toleranceAngle = 0 [°] or smaller than the spatial tolerance of the checked multipatch, the spatial tolerance is used.</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_azimuthTolerance" xml:space="preserve">
    <value>Segment pairs with azimuths not closer than 'azimuthTolerance' [degree] to 90° are reported</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_connectedOnly" xml:space="preserve">
    <value>if true: Only segment pairs where two border points are closer than 'connectedTolerance' are checked. Border points are start and end point of both segments.</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_connectedTolerance" xml:space="preserve">
    <value>distance in 3D and xy units of the 'multiPatchClass'' spatial reference</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_horizontalTolerance" xml:space="preserve">
    <value>Segment with slope angle less than 'horizontalTolerance' are considered horizontal</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_nearAngle" xml:space="preserve">
    <value>Segment pairs with azimuths closer than 'nearAngle' [degree] to 90° are checked</value>
  </data>
  <data name="QaMpHorizontalPerpendicular_0" xml:space="preserve">
    <value>Find all horizontal segment pairs of a multipatch feature where their azimuth's differ less than 'nearAngle' from 90° but more than 'azimuthTolerance'</value>
  </data>
  <data name="QaMpHorizontalAzimuths_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpHorizontalHeights_0" xml:space="preserve">
    <value>Find all horizontal segment pairs of a multipatch feature where their heights differ less than 'nearHeight' but more than 'heightTolerance'</value>
  </data>
  <data name="QaMpHorizontalHeights_heightTolerance" xml:space="preserve">
    <value>Horizontal segments with a height difference less than 'heightTolerance' are considered equal height</value>
  </data>
  <data name="QaMpHorizontalHeights_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpHorizontalHeights_nearHeight" xml:space="preserve">
    <value>Horizontal segments with a height difference less than 'nearHeight' are check for equal height</value>
  </data>
  <data name="QaMinMeanSegmentLength_is3D" xml:space="preserve">
    <value>include z-coordinate for checking (default = false for polyline and polygon, = true for multipatch feature class)</value>
  </data>
  <data name="QaMpAllowedPartTypes_allowTriangles" xml:space="preserve">
    <value>if false : report all parts that are triangles</value>
  </data>
  <data name="QaMpAllowedPartTypes_allowTriangleStrips" xml:space="preserve">
    <value>if false : report all parts that are triangleStrip</value>
  </data>
  <data name="QaSimpleGeometry_2" xml:space="preserve">
    <value>Finds all features in 'featureClass' with non-simple geometries. Optionally ignores non-planar (self-intersecting) lines, and allows specifying a custom factor for reducing the spatial reference xy tolerance used in the detection of non-simple geometries.</value>
  </data>
  <data name="QaSimpleGeometry_toleranceFactor" xml:space="preserve">
    <value>A factor (between 0.1 and 1.0) to apply to the spatial reference xy tolerance used for the detection of non-simple geometries (advanced; default factor for other constructors is 0.4).</value>
  </data>
  <data name="QaForeignKey_2" xml:space="preserve">
    <value>Finds rows that have a key value combination that does not refer to a value combination in a referenced table. Optionally, an existing reference can be treated as an error.</value>
  </data>
  <data name="QaForeignKey_referenceIsError" xml:space="preserve">
    <value>Indicates if an existing reference is an error. This can be used in conjunction with a filter expression on the referenced table, to check for unallowed references to rows of specific types.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' that do not have a given spatial relationship with any feature in 'otherFeatureClass', or for which a given constraint is not fulfilled. The required spatial relationship is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_1" xml:space="preserve">
    <value>Finds all features in 'featureClass' that do not have a given spatial relationship with any feature in 'otherFeatureClass', or for which a given constraint is not fulfilled. The required spatial relationship is defined by a 9IM intersection matrix. Optionally, the required and unallowed intersection dimensions may be defined. 

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_2" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that do not have a given spatial relationship with any feature in 'otherFeatureClasses', or for which a given constraint is not fulfilled. The required spatial relationship is defined by a 9IM intersection matrix.

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_3" xml:space="preserve">
    <value>Finds all features in 'featureClasses' that do not have a given spatial relationship with any feature in 'otherFeatureClasses', or for which a given constraint is not fulfilled. The required spatial relationship is defined by a 9IM intersection matrix. Optionally, the required and unallowed intersection dimensions may be defined. 

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_featureClass" xml:space="preserve">
    <value>The feature class to check for an expected intersection matrix spatial relation with features in 'otherFeatureClass'</value>
  </data>
  <data name="QaMustIntersectMatrixOther_featureClasses" xml:space="preserve">
    <value>The feature classes to check for an expected intersection matrix spatial relation with features in 'otherFeatureClasses'</value>
  </data>
  <data name="QaMustIntersectMatrixOther_intersectionMatrix" xml:space="preserve">
    <value>9IM intersection matrix defining the required spatial relationship. The matrix string consists of the 9 cells of the 3x3 intersection matrix, in the following sequence:

1. G1.interior G2.interior
2. G1.interior G2.boundary
3. G1.interior G2.exterior
4. G1.boundary G2.interior
5. G1.boundary G2.boundary
6. G1.boundary G2.exterior
7. G1.exterior G2.interior
8. G1.exterior G2.boundary
9. G1.exterior G2.exterior

Example: ****T**** (intersection of geometry boundaries)
Refer to the topic "Spatial Relationships" in the ArcGIS online help.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_otherFeatureClass" xml:space="preserve">
    <value>The feature class in which to search for features with expected intersection matrix spatial relation</value>
  </data>
  <data name="QaMustIntersectMatrixOther_otherFeatureClasses" xml:space="preserve">
    <value>The feature classes in which to search for features with expected intersection matrix spatial relation</value>
  </data>
  <data name="QaMustIntersectMatrixOther_relevantRelationCondition" xml:space="preserve">
    <value>Condition on a pair of spatially related features. The pair only counts as related if the condition is either undefined or fulfilled.
The feature to be tested is aliased using "G1". The spatially related ("other") feature is aliased using "G2".</value>
  </data>
  <data name="QaMustIntersectMatrixOther_requiredIntersectionDimensions" xml:space="preserve">
    <value>A list of geometry dimensions that are expected in the 9IM intersection between compared features. The following dimensions are supported:
- 0: point intersections
- 1: linear intersections
- 2: area intersections
If multiple dimensions are expected, then the dimension values can be separated by comma, semicolon or blank. If any of the required dimensions do not occur at least once in the 9IM intersection result, then the relationship is not relevant, and an error will be reported (unless there is a relevant relationship to another feature).
Note that the dimensions are checked against the intersection geometry according to the specified intersection matrix. I.e. if a matrix of '****T****' is specified (boundaries must intersect), then the intersection of only the boundaries is considered.</value>
  </data>
  <data name="QaMustIntersectMatrixOther_unallowedIntersectionDimensions" xml:space="preserve">
    <value>A list of geometry dimensions that are not allowed in the 9IM intersection between compared features. The following dimensions are supported:
- 0: point intersections
- 1: linear intersections
- 2: area intersections
If multiple dimensions are specified as unallowed, then the dimension values can be separated by comma, semicolon or blank. If any of the unallowed dimensions occurs at least once in the 9IM intersection result, then the relationship is not relevant, and an error will be reported (unless there is a relevant relationship to another feature).
Note that the dimensions are checked against the intersection geometry according to the specified intersection matrix. I.e. if a matrix of '****T****' is specified (boundaries must intersect), then the intersection of only the boundaries is considered.</value>
  </data>
  <data name="QaIsCoveredByOther_5" xml:space="preserve">
    <value>Finds all features in 'covered' for which the specified geometry components are not sufficiently covered by the specified geometry component of features in 'covering'. An allowed uncovered percentage may be specified.

The following geometry components are supported:

- EntireGeometry: the original feature geometry
- Boundary: supported for polygons and polylines. For polylines, the boundary consists of the start/end points of all parts. For polygons, it corresponds to the outlines of all polygon rings.
- Vertices: supported for polygons, polylines, multipatches and multiparts. The vertices of the geometry.
- LineEndPoints: supported for polylines. The start and end point of the entire polyline, i.e. the start point of the first path and the end point of the last path.
- LineStartPoint: supported for polylines. The start point of the entire polyline, i.e. the start point of the first path.
- LineEndPoint: supported for polylines. The end point of the entire polyline, i.e. the end point of the last path.
- Centroid: supported for polygons. The centroid point of the entire polygon.
- LabelPoint: supported for polygons. The label point of the entire polygon.
- InteriorVertices: supported for polylines. All line vertices except the start and end point of the entire polyline.

The number of geometry components in the list must be either 0 (in which case 'EntireGeometry' is used as default), 1 (in which case that component is used for all feature classes in the list) or equal to the number of feature classes. In that case, the components are assigned to the feature classes by their index position in the list.</value>
  </data>
  <data name="QaIsCoveredByOther_allowedUncoveredPercentage" xml:space="preserve">
    <value>The maximum uncovered percentage that is still allowed. The specified value must be equal to or larger than 0, and smaller than 100. A value of 0 indicates that the features (or geometry components) must be fully covered. A value of 25 indicates that each feature (or geometry component) must be covered at least by 75 %.</value>
  </data>
  <data name="QaMpFootprintHoles_0" xml:space="preserve">
    <value>Find multipatch features where footprints have inner rings</value>
  </data>
  <data name="QaMpFootprintHoles_innerRingHandling" xml:space="preserve">
    <value>None: check the footprint of the original multipatch
IgnoreInnerRings:check the footprint of the multipatch without inner rings
IgnoreHorizontalInnerRings: check the footprint of the multipatch without the inner rings of horizontal outer rings</value>
  </data>
  <data name="QaMpFootprintHoles_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaGroupConnected_1" xml:space="preserve">
    <value>Find errors in checking if polylines of 'polylineClasses' with same attributes are connected</value>
  </data>
  <data name="QaGroupConnected_polylineClasses" xml:space="preserve">
    <value>polyline feature classes, all having the attributes of 'groupBy'</value>
  </data>
  <data name="QaGroupConnected_errorReporting" xml:space="preserve">
    <value>The method for reporting errors.

- ReferToFirstPart: the end points of the first encountered group, plus any point of another group with the same identifier are reported. This method is available for backwards compatibility. Use CombineGroups or ShortestGaps.
If 'CompleteGroupsOutsideTestArea' = true, ReferToFirstPart is replaced with ShortestGaps.

- ShortestGaps: each disjoint line group is connected with the nearest line group for the same group identifier, even if the endpoint of the other line group is already connected to another disjoint line group.

- CombineGroups: each disjoint line group is connected with the nearest line group for the same group identifier. Each end point of a disjoint line group is connected to no more than one other disjoint line group. This may result in longer connection lines than the shortest possible connection. Also, no connections are made to line group 'ends' that form a closed loop, instead an attempt is made to connect to another end of the line group.</value>
  </data>
  <data name="QaGroupConnected_minimumErrorConnectionLineLength" xml:space="preserve">
    <value>The minimum length for gaps between disjoint line groups for which a connection line will be reported. For shorter gaps, the end points are reported as part of a multipoint error feature.</value>
  </data>
  <data name="QaGroupConnected_valueSeparator" xml:space="preserve">
    <value>An optional separator for storing multiple group identifiers in the same field (e.g. E100#E200)</value>
  </data>
  <data name="QaIntersectionMatrixOther_4" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with features in 'relatedClass', and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix. A list of valid intersection dimensions can be specified. Any parts of the intersection geometry (according to the 9IM intersection matrix) with a dimension that is included in this list are not reported as errors.

Remark: The feature classes in 'featureClass' and 'relatedClass' must have the same spatial reference.</value>
  </data>
  <data name="QaIntersectionMatrixOther_validIntersectionDimensions" xml:space="preserve">
    <value>An optional list of geometry dimensions that are valid in the 9IM intersection between compared features. The following dimensions are supported:
- 0: point intersections
- 1: linear intersections
- 2: area intersections
If multiple dimensions are valid, then the dimension values can be separated by comma, semicolon or blank. 
Note that the dimensions are checked against the intersection geometry according to the specified intersection matrix. I.e. if a matrix of '****T****' is specified (boundary intersections), then the various intersections of the boundaries are evaluated against the list of valid intersection dimensions. Only intersections with dimensions that are not present in the list of valid dimensions are reported as errors.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_4" xml:space="preserve">
    <value>Finds all features in 'featureClass' that have a given spatial relationship with other features in 'featureClass', and for which a given constraint is not fulfilled. The spatial relationship of the error cases is defined by a 9IM intersection matrix. A list of valid intersection dimensions can be specified. Any parts of the intersection geometry (according to the 9IM intersection matrix) with a dimension that is included in this list are not reported as errors.</value>
  </data>
  <data name="QaIntersectionMatrixSelf_validIntersectionDimensions" xml:space="preserve">
    <value>An optional list of geometry dimensions that are valid in the 9IM intersection between compared features. The following dimensions are supported:
- 0: point intersections
- 1: linear intersections
- 2: area intersections
If multiple dimensions are valid, then the dimension values can be separated by comma, semicolon or blank. 
Note that the dimensions are checked against the intersection geometry according to the specified intersection matrix. I.e. if a matrix of '****T****' is specified (boundary intersections), then the various intersections of the boundaries are evaluated against the list of valid intersection dimensions. Only intersections with dimensions that are not present in the list of valid dimensions are reported as errors.</value>
  </data>
  <data name="QaMustBeNearOther_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' that are not closer than 'maximumDistance' to any feature of 'nearClasses', or for which nearby features in 'nearClasses' do exist, but a given comparison constraint is not fulfilled.
Note that errors can be reported only for features that are completely within the verified extent. Features that extend beyond the verified extent may have valid neighbors outside of the searched extent, and are therefore ignored.</value>
  </data>
  <data name="QaMustBeNearOther_ErrorDistanceFormat" xml:space="preserve">
    <value>Format string for numbers in error description, i.e. "{0:N2} m" will display '1.23 m' for a value of 1.2319</value>
  </data>
  <data name="QaMustBeNearOther_featureClass" xml:space="preserve">
    <value>featureClass to test</value>
  </data>
  <data name="QaGdbRelease_0" xml:space="preserve">
    <value>Verifies that the geodatabase release for a given table corresponds to a specified version.</value>
  </data>
  <data name="QaGdbRelease_1" xml:space="preserve">
    <value>Verifies that the geodatabase release for a given table corresponds to a specified version range. The version range may be open on one side, by specifying only one of minimumVersion and maximumVersion.</value>
  </data>
  <data name="QaGdbRelease_expectedVersion" xml:space="preserve">
    <value>The unique expected version for the geodatabase release.
Versions can be specified with up to three components (e.g. 10, 10.2, 10.2.1; the first two are equivalent to 10.*.*, 10.2.*). An unspecified version component matches any value for that component.</value>
  </data>
  <data name="QaMustBeNearOther_maximumDistance" xml:space="preserve">
    <value>maximum distance within which another feature is required</value>
  </data>
  <data name="QaMustBeNearOther_nearClasses" xml:space="preserve">
    <value>featureClasses to search for required nearby features</value>
  </data>
  <data name="QaZDifferenceSelf_0" xml:space="preserve">
    <value>Finds features where the Z difference to another feature is less than 'limit'</value>
  </data>
  <data name="QaGdbRelease_maximumVersion" xml:space="preserve">
    <value>The maximum version of the valid range of versions for the geodatabase release.
Versions can be specified with up to three components (e.g. 10, 10.2, 10.2.1; the first two are equivalent to 10.*.*, 10.2.*). An unspecified version component matches any value for that component.</value>
  </data>
  <data name="QaGdbRelease_minimumVersion" xml:space="preserve">
    <value>The minimum version of the valid range of versions for the geodatabase release.
Versions can be specified with up to three components (e.g. 10, 10.2, 10.2.1; the first two are equivalent to 10.*.*, 10.2.*). An unspecified version component matches any value for that component.</value>
  </data>
  <data name="QaZDifferenceSelf_zComparisonMethod" xml:space="preserve">
    <value>BoundingBox: compare the Z difference between the bounding boxes of features that intersect in 2D</value>
  </data>
  <data name="QaZDifferenceSelf_zRelationConstraint" xml:space="preserve">
    <value>Constraint on Z relation of features with 2D intersection.
Upper feature is aliased as "U", lower feature as "L"
Example: U.EdgeLevel &gt; L.EdgeLevel</value>
  </data>
  <data name="QaZDifferenceSelf_featureClasses" xml:space="preserve">
    <value>3D feature classes to check against each other and itself</value>
  </data>
  <data name="QaZDifferenceSelf_limit" xml:space="preserve">
    <value>minimum allowed Z difference</value>
  </data>
  <data name="QaMustBeNearOther_relevantRelationCondition" xml:space="preserve">
    <value>Condition on a pair of nearby features. The pair only counts as 'near enough' if the condition is either undefined or fulfilled.
The feature to be tested is aliased using "G1". The nearby ("other") feature is aliased using "G2".</value>
  </data>
  <data name="QaMpOverhangCodedDomainField_codedDomainField" xml:space="preserve">
    <value>Coded domain field. The overhang for the feature is determined by the description of the coded value</value>
  </data>
  <data name="QaMpOverhang_0" xml:space="preserve">
    <value>Finds multipatches where the overhang footprint is less than 'limit' or the ring count of the footprint and the overhang footprint differ.</value>
  </data>
  <data name="QaMpOverhang_expression" xml:space="preserve">
    <value>expression for determining the overhang. Examples: 
"3.0"; "overhangField"; "2.1 * numericField + 5"</value>
  </data>
  <data name="QaMpOverhang_limit" xml:space="preserve">
    <value>minimum allowed area</value>
  </data>
  <data name="QaMpOverhang_multipatchClass" xml:space="preserve">
    <value>Multipatch class</value>
  </data>
  <data name="QaMpFootprintHoles_HorizontalZTolerance" xml:space="preserve">
    <value>The Z extent tolerance for horizontal inner rings: inner rings with a Z extent that is less than or equal to this value are considered horizontal. Used for innerRingHandling = IgnoreHorizontalInnerRings.</value>
  </data>
  <data name="QaValidDateValues_2" xml:space="preserve">
    <value>Finds rows with date values from a given list of date fields that are invalid or outside a defined date range. The list of date fields can be defined by a concatenated string of field names</value>
  </data>
  <data name="QaValidDateValues_3" xml:space="preserve">
    <value>Finds rows with date field values that are invalid or outside a defined date range. The maximum date value can be specified relative to the current date/time</value>
  </data>
  <data name="QaValidDateValues_4" xml:space="preserve">
    <value>Finds rows with date values from a given list of date fields that are invalid or outside a defined date range. The list of date fields can be defined by a concatenated string of field names. The maximum date value can be specified relative to the current date/time</value>
  </data>
  <data name="QaValidDateValues_5" xml:space="preserve">
    <value>Finds rows with date values from a given list of date fields that are invalid or outside a defined date range. The list of date fields can be defined by a concatenated string of field names. The minimum date value can be specified relative to the current date/time</value>
  </data>
  <data name="QaValidDateValues_6" xml:space="preserve">
    <value>Finds rows with date values from a given list of date fields that are invalid or outside a defined date range. The list of date fields can be defined by a concatenated string of field names. The minimum and maximum date values can be specified relative to the current date/time</value>
  </data>
  <data name="QaValidDateValues_dateFieldNamesString" xml:space="preserve">
    <value>A concatenated string of date field names. The names may be separated by blank, comma or semicolon.</value>
  </data>
  <data name="QaValidDateValues_maximumDateTimeRelativeToNow" xml:space="preserve">
    <value>The upper bound of the range of valid date values, relative to the current date/time. If the value is left empty, the current date/time is used as the maximum date. Optionally, an offset can be defined from the current date/time, using the following syntax:

[-]{ d | d.hh:mm[:ss] | hh:mm[:ss] }

Elements in square brackets ([ and ]) are optional. One selection from the list of alternatives enclosed in braces ({ and }) and separated by vertical bars (|) is required. The following list describes each element:

- : An optional minus sign, which indicates a negative offset
d : Days, ranging from 0 to 10675199
hh : Hours, ranging from 0 to 23
mm : Minutes, ranging from 0 to 59
ss : Optional seconds, ranging from 0 to 59

Examples: 
-7 : 7 days before the current date/time
1.12:00 : 1 and a half day after the current date time
00:10 : 10 minutes after the current date/time
00:00:05 : 5 seconds after the current date/time</value>
  </data>
  <data name="QaValidDateValues_minimumDateTimeRelativeToNow" xml:space="preserve">
    <value>The lower bound of the range of valid date values, relative to the current date/time. If the value is left empty, the current date/time is used as the minimum date. Optionally, an offset can be defined from the current date/time, using the following syntax:

[-]{ d | d.hh:mm[:ss] | hh:mm[:ss] }

Elements in square brackets ([ and ]) are optional. One selection from the list of alternatives enclosed in braces ({ and }) and separated by vertical bars (|) is required. The following list describes each element:

- : An optional minus sign, which indicates a negative offset
d : Days, ranging from 0 to 10675199
hh : Hours, ranging from 0 to 23
mm : Minutes, ranging from 0 to 59
ss : Optional seconds, ranging from 0 to 59

Examples: 
-7 : 7 days before the current date/time
1.12:00 : 1 and a half day after the current date time
00:10 : 10 minutes after the current date/time
00:00:05 : 5 seconds after the current date/time</value>
  </data>
  <data name="QaValidUrls_0" xml:space="preserve">
    <value>Checks field values in 'table' for valid URLs. The URLs can be stored in a single field or it can be the result of a SQL expression referencing one or more fields. Supported are HTTP or file system URLs (UNC paths or paths to mapped drives). FTP URLs are not supported yet</value>
  </data>
  <data name="QaValidUrls_table" xml:space="preserve">
    <value>The table to check for valid URLs</value>
  </data>
  <data name="QaValidUrls_urlExpression" xml:space="preserve">
    <value>The name of a field containing URLs to be checked. Instead of a simple field name, a more complex expression that evaluates to a string value may be used. The syntax for these expressions is described here:

http://www.csharp-examples.net/dataview-rowfilter/ 
http://msdn.microsoft.com/en-us/library/system.data.datacolumn.expression.aspx

Typical elements of such an expression are substring extraction using SUBSTRING(),  string concatenation using '+' (e.g. FIELD1 + '#' +FIELD2), or string length evaluation using LEN(). Note that the aggregation functions (AVG(), MAX() etc.) of the expression language are not valid in this context.</value>
  </data>
  <data name="QaVertexCoincidence_0" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge within the geometry of features of a given feature class.</value>
  </data>
  <data name="QaVertexCoincidence_CoincidenceTolerance" xml:space="preserve">
    <value>The tolerance for considering a nearby vertex or edge as coincident. To verify for exact topological correctness, a value of 0 should be used (default). However if multiple feature classes are verified, which have differing XY resolutions and/or domains, a larger value (less than the largest of the involved XY resolutions) may have to be used, since coordinates may not be exactly coincident due to offsets in the resolution grids used for storing coordinate values.</value>
  </data>
  <data name="QaVertexCoincidence_EdgeTolerance" xml:space="preserve">
    <value>The search tolerance for nearby edges that are required to be coincident. If an edge is within this search distance from a vertex of the verified feature, but not close enough to it (according to the CoincidenceTolerance), an error is reported. If RequireVertexOn is True, then an error is reported even if the edge is within the CoincidenceTolerance from the verified vertex.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby edges should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidence_featureClass" xml:space="preserve">
    <value>The feature class to check for vertices that lack a coincident vertex and/or edge within the same feature. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidence_Is3D" xml:space="preserve">
    <value>Indicates that the distance between verified vertices and nearby vertices/edges should be calculated as 3D distance. Applicable for feature classes with Z values.</value>
  </data>
  <data name="QaVertexCoincidence_PointTolerance" xml:space="preserve">
    <value>The search tolerance for nearby vertices that are required to be coincident. If a vertex is within this search distance from a vertex of the verified feature, but not coincident with it (according to the CoincidenceTolerance), an error is reported.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby vertices should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidence_RequireVertexOnNearbyEdge" xml:space="preserve">
    <value>Indicates if any edge within the EdgeTolerance is required to have a coincident vertex. If True, an error is reported if there is any edge within the EdgeTolerance from the verified vertex, even if the distance from the vertex to the edge is less than or equal the CoincidenceTolerance, as long as there is no coincident vertex on that edge.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_0" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of a given feature class.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_1" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of a given list of feature classes.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_CoincidenceTolerance" xml:space="preserve">
    <value>The tolerance for considering a nearby vertex or edge as coincident. To verify for exact topological correctness, a value of 0 should be used (default). However if multiple feature classes are verified, which have differing XY resolutions and/or domains, a larger value (less than the largest of the involved XY resolutions) may have to be used, since coordinates may not be exactly coincident due to offsets in the resolution grids used for storing coordinate values.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_EdgeTolerance" xml:space="preserve">
    <value>The search tolerance for nearby edges that are required to be coincident. If an edge is within this search distance from a vertex of the verified feature, but not close enough to it (according to the CoincidenceTolerance), an error is reported. If RequireVertexOn is True, then an error is reported even if the edge is within the CoincidenceTolerance from the verified vertex.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby edges should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidenceSelf_featureClass" xml:space="preserve">
    <value>The feature class to check for vertices that lack a coincident vertex and/or edge in nearby features in the same feature class. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_featureClasses" xml:space="preserve">
    <value>The feature classes to check for vertices that lack a coincident vertex and/or edge in nearby features in any of the specified feature classes. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_Is3D" xml:space="preserve">
    <value>Indicates that the distance between verified vertices and nearby vertices/edges should be calculated as 3D distance. Applicable for feature classes with Z values.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_PointTolerance" xml:space="preserve">
    <value>The search tolerance for nearby vertices that are required to be coincident. If a vertex is within this search distance from a vertex of the verified feature, but not coincident with it (according to the CoincidenceTolerance), an error is reported.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby vertices should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidenceSelf_RequireVertexOnNearbyEdge" xml:space="preserve">
    <value>Indicates if any edge within the EdgeTolerance is required to have a coincident vertex. If True, an error is reported if there is any edge within the EdgeTolerance from the verified vertex, even if the distance from the vertex to the edge is less than or equal the CoincidenceTolerance, as long as there is no coincident vertex on that edge.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_VerifyWithinFeature" xml:space="preserve">
    <value>Indicates that vertex coincidence should be verified also within the geometry of each verified feature. If False, vertex coincidence is verified only between different features.</value>
  </data>
  <data name="QaMpFootprintHoles_ResolutionFactor" xml:space="preserve">
    <value>Optional factor to reduce the value of the XY resolution, to find inner rings that are too small to be detected with the current XY resolution and tolerance values. The factor must be larger or equal to 1. Default value is 1 (no change of the resolution and tolerance). If a value greater than 1 is specified, the XY tolerance is set to 2 * the reduced resolution value.</value>
  </data>
  <data name="QaWithinZRange_1" xml:space="preserve">
    <value>Finds features with Z values outside of a defined range, and allowing for special values outside the defined range (e.g. -9999).

- Supported for points, lines, polygons, multipoints and multipatches.
- For lines and polygons, individual errors are reported for consecutive segments (or parts of segments) exceeding the same boundary of the Z range.
- For multipoints and multipatches, one error is reported for all points exceeding the same boundary of the Z range.</value>
  </data>
  <data name="QaWithinZRange_allowedZValues" xml:space="preserve">
    <value>Optional list of special allowed values outside of the defined valid Z range (e.g. -9999)</value>
  </data>
  <data name="QaNodeLineCoincidence_3" xml:space="preserve">
    <value>Finds nodes in 'nodeClass' that are not coincident with any feature in 'nearClasses', but are within 'near' of at least one feature in 'nearClasses'. Optionally, individual tolerances can be specified for each feature class in 'nearClasses', and for testing within multiple polyline paths in 'nodeClass'. Optionally, only nodes near an edge but no end point are reported. This permits avoiding multiple errors when applying other tests to check for minimum node distance.</value>
  </data>
  <data name="QaNodeLineCoincidence_nearTolerances" xml:space="preserve">
    <value>List of maximum distances in (x,y)-units from lines or polygon boundaries for which unconnected nodes are reported. Unconnected nodes further away than this tolerance are not reported. The number of entries in this list must be either one (in which case the same tolerance is used for all 'nearClasses') or equal to the number of 'nearClasses' (to specify individual tolerances for each feature class in 'nearClasses'; in this case, the tolerance values must be in the same order as the feature classes for which the value applies).</value>
  </data>
  <data name="QaNodeLineCoincidence_withinPolylineTolerance" xml:space="preserve">
    <value>The maximum distance in (x,y)-units for searching unconnected nodes within multipart polylines. This value is only used if 'nodeClass' is a polyline feature class, and if the value is greater than 0. Note that this value is only applied to search within each polyline geometry. If unconnected end points between different polyline features of the same class should be detected, then the same feature class must be specified as 'nodeClass' and as part of 'nearClasses'.</value>
  </data>
  <data name="QaMpFootprintHoles_MinimumArea" xml:space="preserve">
    <value>Minimum area for allowed holes. Holes with an area greater or equal the minimum area are ignored. A value of -1 indicates that no minimum area should be applied (all holes are reported).</value>
  </data>
  <data name="QaVertexCoincidenceSelf_2" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of a given list of feature classes. If an optional constraint is fulfilled for a pair of features, non-coincidence of vertices is allowed for these features.</value>
  </data>
  <data name="QaVertexCoincidenceSelf_allowedNonCoincidenceCondition" xml:space="preserve">
    <value>Optional condition on a pair of nearby features. If the condition is defined and fulfilled, non-coincidence of vertices between these features is allowed.
The involved features are aliased using "G1" and "G2".
Example: G1.CountryCode &lt;&gt; G2.CountryCode</value>
  </data>
  <data name="QaIsCoveredByOther_6" xml:space="preserve">
    <value>Finds all features in 'covered' for which the specified geometry components are not sufficiently covered by the specified geometry component of features in 'covering'. An allowed uncovered percentage may be specified.

The following geometry components are supported:

- EntireGeometry: the original feature geometry
- Boundary: supported for polygons and polylines. For polylines, the boundary consists of the start/end points of all parts. For polygons, it corresponds to the outlines of all polygon rings.
- Vertices: supported for polygons, polylines, multipatches and multiparts. The vertices of the geometry.
- LineEndPoints: supported for polylines. The start and end point of the entire polyline, i.e. the start point of the first path and the end point of the last path.
- LineStartPoint: supported for polylines. The start point of the entire polyline, i.e. the start point of the first path.
- LineEndPoint: supported for polylines. The end point of the entire polyline, i.e. the end point of the last path.
- Centroid: supported for polygons. The centroid point of the entire polygon.
- LabelPoint: supported for polygons. The label point of the entire polygon.
- InteriorVertices: supported for polylines. All line vertices except the start and end point of the entire polyline.

The number of geometry components in the list must be either 0 (in which case 'EntireGeometry' is used as default), 1 (in which case that component is used for all feature classes in the list) or equal to the number of feature classes. In that case, the components are assigned to the feature classes by their index position in the list.</value>
  </data>
  <data name="QaIsCoveredByOther_isCoveringConditions" xml:space="preserve">
    <value>Conditions for combinations of 'covered' and 'covering' that must be fulfilled for a pair of features from 'covering' and 'covered'. If the condition is not fulfilled, the feature from 'covering' is ignored and does not contribute to the covering area for the 'covered' feature.
The feature from 'covering' can be addressed as 'G1' in the condition, the feature from 'covered' as 'G2'.

If a single condition is specified in the list, it is used for all combinations of 'covered' and 'covering'. If multiple conditions are specified, the conditions must be ordered such that for each feature class in 'covered', the condition for all feature classes in 'covering' are listed. For 2 'covered' feature classes and 3 'covering' feature classes, the conditions in the list are assigned as follows:

  1. condition: 1. covered, 1. covering
  2. condition: 1. covered, 2. covering
  3. condition: 1. covered, 3. covering
  4. condition: 2. covered, 1. covering
  5. condition: 2. covered, 2. covering
  6. condition: 2. covered, 3. covering

If more than one condition is specified, the number of conditions must be equal to 

  (number of covered classes) * (number of covering classes)</value>
  </data>
  <data name="QaGroupConnected_ReportIndividualGaps" xml:space="preserve">
    <value>If true: Creates the geometric union of all gaps found according to 'errorReporting'. 
If false: Report each found gap separately.

Default = false.
Remark: Has no effect for ErrorReporting.ReferToFirstPart</value>
  </data>
  <data name="QaGroupConnected_IgnoreGapsLongerThan" xml:space="preserve">
    <value>No gaps are reported as errors for endpoints, where the closest other endpoint is further away than 'IgnoreGapsLongerThan'.

Note: has no effect for ErrorReporting.ReferToFirstPart</value>
  </data>
  <data name="QaTerrainSpikes_0" xml:space="preserve">
    <value>Finds spikes in terrain by testing all triangles of 'terrain'. A spike is defined a node, where all neighboring triangles have a height difference &gt; 'maxDeltaZ' and a slope &gt; 'maxSlopeDegrees'</value>
  </data>
  <data name="QaTerrainSpikes_maxDeltaZ" xml:space="preserve">
    <value>Maximum allowed height difference of a triangle in 'terrain' so that the nodes of the triangle are no spikes. Otherwise the nodes may be spikes (see test description for an exact definition of spikes).</value>
  </data>
  <data name="QaTerrainSpikes_maxSlopeDegrees" xml:space="preserve">
    <value>Maximum allowed slope of a triangle in 'terrain' so that the nodes of the triangle are no spikes. Otherwise the nodes may be spikes (see test description for an exact definition of spikes).</value>
  </data>
  <data name="QaTerrainSpikes_terrain" xml:space="preserve">
    <value>Terrain to check</value>
  </data>
  <data name="QaTerrainSpikes_terrainTolerance" xml:space="preserve">
    <value>Tolerance of 'terrain'</value>
  </data>
  <data name="QaMpFootprintRelationCodedDomainField_overhangCodedDomainField" xml:space="preserve">
    <value>Coded domain field. The overhang for the feature is determined by the description of the coded value</value>
  </data>
  <data name="QaMpFootprintRelation_0" xml:space="preserve">
    <value>Finds mutlipatch features that intersect in 2D and their footprints 
- do not intersect but are closer than 'minimumoffset'
- do intersect but intersection boundary length is &lt; 'minimumOverlap'
-do intersect and the angle at the intersections is &lt; 'minimumIntersectionAngleDegrees'</value>
  </data>
  <data name="QaMpFootprintRelation_minimumIntersectAngleDegrees" xml:space="preserve">
    <value>minimum angle in degrees between the footprint boundaries at their intersections</value>
  </data>
  <data name="QaMpFootprintRelation_minimumOffset" xml:space="preserve">
    <value>minimum offset of the footprints if they do not intersect</value>
  </data>
  <data name="QaMpFootprintRelation_minimumOverlap" xml:space="preserve">
    <value>minimum boundary length of the footprint intersection</value>
  </data>
  <data name="QaMpFootprintRelation_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpFootprintRelation_overhangExpression" xml:space="preserve">
    <value>expression for determining the overhang. Examples: 
"3.0"; "overhangField"; "2.1 * numericField + 5"</value>
  </data>
  <data name="QaMpVertexNotNearFace_0" xml:space="preserve">
    <value>Finds vertices of 'vertexClasses' that are not far enough above or below the faces of 'multiPatchClass'</value>
  </data>
  <data name="QaMpVertexNotNearFace_CoplanarityTolerance" xml:space="preserve">
    <value>Coplanarity tolerance of the faces of 'multiPatchClass'</value>
  </data>
  <data name="QaMpVertexNotNearFace_EdgeCoincidence" xml:space="preserve">
    <value>Vertices closer (in 3D) than 'EdgeCoincidence' to an edge of a face are excluded from checking for this specific face</value>
  </data>
  <data name="QaMpVertexNotNearFace_IgnoreNonCoplanarFaces" xml:space="preserve">
    <value>if true, non coplanar faces are excluded from checking the vertices of 'vertexClasses'</value>
  </data>
  <data name="QaMpVertexNotNearFace_minimumDistanceAbove" xml:space="preserve">
    <value>If a vertex lies above a face, the minimum distance it must lie above</value>
  </data>
  <data name="QaMpVertexNotNearFace_minimumDistanceBelow" xml:space="preserve">
    <value>If a vertex lies below a face, the minimum distance it must lie below the face</value>
  </data>
  <data name="QaMpVertexNotNearFace_multiPatchClass" xml:space="preserve">
    <value>The multipatch feature class which faces are checked against the vertices uf 'vertexClasses'. If a feature class shall be checked against itself, it must be used as 'multiPatchClass' and as member of 'vertexClasses'</value>
  </data>
  <data name="QaMpVertexNotNearFace_PointCoincidence" xml:space="preserve">
    <value>Vertices closer (in 3D) than 'PointCoincidence' to a vertex of a face are excluded from checking for this specific face</value>
  </data>
  <data name="QaMpVertexNotNearFace_ReportNonCoplanarity" xml:space="preserve">
    <value>if true, non coplanar faces are reported as errors</value>
  </data>
  <data name="QaMpVertexNotNearFace_VerifyWithinFeature" xml:space="preserve">
    <value>if true, vertices of a multipatch feature are check against the faces of the feature itself</value>
  </data>
  <data name="QaMpVertexNotNearFace_vertexClasses" xml:space="preserve">
    <value>List of featureclasses, from which the vertices are checked against the faces of 'multiPatchClass'</value>
  </data>
  <data name="QaMpVertexNotNearFace_MinimumSlopeDegrees" xml:space="preserve">
    <value>Only faces with slopes &gt; 'MinimumSlopeDegrees' are tested against vertices</value>
  </data>
  <data name="QaMpVertexNotNearFace_PlaneCoincidence" xml:space="preserve">
    <value>Vertices with a z-Difference &lt; 'PlaneCoincidence' are considered as coincident with the face and are not reported as errors</value>
  </data>
  <data name="QaValidCoordinateFields_0" xml:space="preserve">
    <value>Finds features with attributes for XY and/or Z coordinate values whose values differ significantly from the coordinates of the feature. </value>
  </data>
  <data name="QaValidCoordinateFields_AllowMissingXYFieldValueForDefinedShape" xml:space="preserve">
    <value>Indicates that undefined XY coordinate field values are allowed even if the feature shape is defined. If false, an error with issue code 'ShapeIsDefinedButCoordinateFieldHasNoValue' is reported in this case.</value>
  </data>
  <data name="QaValidCoordinateFields_AllowMissingZFieldValueForDefinedShape" xml:space="preserve">
    <value>Indicates that undefined Z coordinate field values are allowed even if the feature shape is defined. If false, an error with issue code 'ShapeIsDefinedButCoordinateFieldHasNoValue' is reported in this case.</value>
  </data>
  <data name="QaValidCoordinateFields_AllowXYFieldValuesForUndefinedShape" xml:space="preserve">
    <value>Indicates that the XY coordinate fields are allowed to contain values even if the feature shape is undefined (empty or null). If false, an error with issue code 'ShapeIsUndefinedButCoordinateFieldHasValue' is reported in this case.</value>
  </data>
  <data name="QaValidCoordinateFields_AllowZFieldValueForUndefinedShape" xml:space="preserve">
    <value>Indicates that the Z coordinate field is allowed to contain values even if the feature shape is undefined (empty or null). If false, an error with issue code 'ShapeIsUndefinedButCoordinateFieldHasValue' is reported in this case.</value>
  </data>
  <data name="QaValidCoordinateFields_culture" xml:space="preserve">
    <value>If coordinate values are stored in text fields, this parameter specified the name of the culture to be used for interpreting the numeric values from the text string (defining the decimal symbol, thousands separator etc.). 

The name is a combination of an ISO 639 two-letter lowercase culture code associated with a language (see http://en.wikipedia.org/wiki/ISO_639) and an ISO 3166 two-letter uppercase subculture code associated with a country or region (see http://en.wikipedia.org/wiki/ISO_3166-2). 

Examples: de-DE (german - Germany), de-CH (german - Switzerland), en-US (english - United States).

If no value is specified for this parameter and coordinates are stored in text fields, the "invariant culture" is used, which corresponds to en-US as far as number formatting is concerned.</value>
  </data>
  <data name="QaValidCoordinateFields_featureClass" xml:space="preserve">
    <value>The point feature class to check for invalid coordinate field values</value>
  </data>
  <data name="QaValidCoordinateFields_xCoordinateFieldName" xml:space="preserve">
    <value>The name of the field containing the X coordinate value (optional)</value>
  </data>
  <data name="QaValidCoordinateFields_xyTolerance" xml:space="preserve">
    <value>The maximum allowed distance between the XY coordinates field values and the coordinates of the feature. If only one of the XY coordinate fields is specified, or if both are specified and only one has a value (and AllowMissingXYFieldValueForDefinedShape is 'true'), the distance is measured only along the axis of the available coordinate value.</value>
  </data>
  <data name="QaValidCoordinateFields_yCoordinateFieldName" xml:space="preserve">
    <value>The name of the field containing the Y coordinate value (optional)</value>
  </data>
  <data name="QaValidCoordinateFields_zCoordinateFieldName" xml:space="preserve">
    <value>The name of the field containing the Z coordinate value (optional)</value>
  </data>
  <data name="QaValidCoordinateFields_zTolerance" xml:space="preserve">
    <value>The maximum allowed distance between the Z coordinates field values and the coordinates of the feature.</value>
  </data>
  <data name="QaLineIntersect_AllowedInteriorIntersections" xml:space="preserve">
    <value>Specifies the allowed intersections of the interiors (i.e. excluding the end points) of both lines
- None: no interior intersections are allowed
- AtVertexOnBothLines: intersections of the line interiors are allowed if each line has a vertex at the intersection location</value>
  </data>
  <data name="QaMpNonIntersectingRingFootprints_0" xml:space="preserve">
    <value>Finds multipatch features having rings whose 2D footprints have an interior intersection. Optionally, intersections of footprint interiors can be allowed for rings having different, unique point ids.</value>
  </data>
  <data name="QaMpNonIntersectingRingFootprints_allowIntersectionsForDifferentPointIds" xml:space="preserve">
    <value>Indicates if intersections of footprint interiors are allowed for rings that have different, unique point ids. If set to 'true', an error is reported if point ids within a ring are not unique.</value>
  </data>
  <data name="QaMpNonIntersectingRingFootprints_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpNonIntersectingRingFootprints_ResolutionFactor" xml:space="preserve">
    <value>Optional factor to reduce the value of the XY resolution, to find ring footprint intersections that are too small to be detected with the current XY resolution and tolerance values. The factor must be larger or equal to 1. Default value is 1 (no change of the resolution and tolerance). If a value greater than 1 is specified, the XY tolerance is set to 2 * the reduced resolution value.</value>
  </data>
  <data name="QaMpSinglePartFootprint_0" xml:space="preserve">
    <value>Finds multipatch features with a 2D footprint that consists of more than one disjoint part.</value>
  </data>
  <data name="QaMpSinglePartFootprint_multiPatchClass" xml:space="preserve">
    <value>Multipatch feature class</value>
  </data>
  <data name="QaMpSinglePartFootprint_ResolutionFactor" xml:space="preserve">
    <value>Optional factor to reduce the value of the XY resolution, to find disjoint parts that are too small to be detected with the current XY resolution and tolerance values. The factor must be larger or equal to 1. Default value is 1 (no change of the resolution and tolerance). If a value greater than 1 is specified, the XY tolerance is set to 2 * the reduced resolution value.</value>
  </data>
  <data name="QaRowCount_1" xml:space="preserve">
    <value>Determines if the number of rows in a table is within an expected range, defined based on offsets from the row count in one or more reference tables. This can be used to check if a copy / append operation from one or more source tables to a target table was successful.</value>
  </data>
  <data name="QaRowCount_maximumValueOffset" xml:space="preserve">
    <value>The offset to apply to the reference row count to determine the expected maximum row count. This can be a negative value by specifying a leading '-'. The offset can be specified as a percentage of the reference row count, by adding a trailing '%'.

Examples:
"100" (maximum value =reference row count +100)
"-100" (maximum value =reference row count - 100)
"10%" (maximum value = reference row count + 10% of reference row count)
"-10%" (maximum value =reference row count - 10% of reference row count)
"0" (maximum value =reference row count)
undefined: no maximum value specified.

Note that at least one of minimumValueOffset or maximumValueOffset must be specified.</value>
  </data>
  <data name="QaRowCount_minimumValueOffset" xml:space="preserve">
    <value>The offset to apply to the reference row count to determine the expected minimum row count. This can be a negative value by specifying a leading '-'. The offset can be specified as a percentage of the reference row count, by adding a trailing '%'.

Examples:
"100" (minimum value =reference row count +100)
"-100" (minimum value =reference row count - 100)
"10%" (minimum value = reference row count + 10% of reference row count)
"-10%" (minimum value =reference row count - 10% of reference row count)
"0" (minimum value =reference row count)
undefined: no minimum value specified.

Note that at least one of minimumValueOffset or maximumValueOffset must be specified.</value>
  </data>
  <data name="QaRowCount_referenceTables" xml:space="preserve">
    <value>The tables to get the reference row count from, to which the offset specifications will be applied to determine the expected row count range. More than one table can be specified to support scenarios where rows are appended from multiple source tables into a target table.</value>
  </data>
  <data name="QaIsCoveredByOther_CoveringClassTolerances" xml:space="preserve">
    <value>The search tolerance for features in the covering classes to be considered covering. The tolerance is applied as a buffer to the covering geometries when testing covered features.
Can either be empty, have one value or have as many values as there are covering classes.
- If no value is given no tolerance will be applied
- If there is one value this value is applied to all covering classes
- If there are as many values as covering classes each value is applied to the corresponding covering class
</value>
  </data>
  <data name="QaVertexCoincidenceOther_0" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of another feature class.</value>
  </data>
  <data name="QaVertexCoincidenceOther_1" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of a given list of other feature classes.</value>
  </data>
  <data name="QaVertexCoincidenceOther_2" xml:space="preserve">
    <value>Finds vertices for which there is no coincident vertex and/or edge in nearby features of a given list of other feature classes. If an optional constraint is fulfilled for a pair of features, non-coincidence of vertices is allowed for these features.</value>
  </data>
  <data name="QaVertexCoincidenceOther_allowedNonCoincidenceCondition" xml:space="preserve">
    <value>Optional condition on a pair of nearby features. If the condition is defined and fulfilled, non-coincidence of vertices between these features is allowed.
The involved features are aliased using "G1" (feature class) and "G2" (related class).
Example: G1.CountryCode &lt;&gt; G2.CountryCode</value>
  </data>
  <data name="QaVertexCoincidenceOther_CoincidenceTolerance" xml:space="preserve">
    <value>The tolerance for considering a nearby vertex or edge as coincident. To verify for exact topological correctness, a value of 0 should be used (default). However if multiple feature classes are verified, which have differing XY resolutions and/or domains, a larger value (less than the largest of the involved XY resolutions) may have to be used, since coordinates may not be exactly coincident due to offsets in the resolution grids used for storing coordinate values.</value>
  </data>
  <data name="QaVertexCoincidenceOther_EdgeTolerance" xml:space="preserve">
    <value>The search tolerance for nearby edges that are required to be coincident. If an edge is within this search distance from a vertex of the verified feature, but not close enough to it (according to the CoincidenceTolerance), an error is reported. If RequireVertexOn is True, then an error is reported even if the edge is within the CoincidenceTolerance from the verified vertex.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby edges should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidenceOther_featureClass" xml:space="preserve">
    <value>The feature class to check for vertices that lack a coincident vertex and/or edge in nearby features in  'related class'. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidenceOther_featureClasses" xml:space="preserve">
    <value>The feature classes to check for vertices that lack a coincident vertex and/or edge in nearby features in 'related classes'. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidenceOther_Is3D" xml:space="preserve">
    <value>Indicates that the distance between verified vertices and nearby vertices/edges should be calculated as 3D distance. Applicable for feature classes with Z values.</value>
  </data>
  <data name="QaVertexCoincidenceOther_PointTolerance" xml:space="preserve">
    <value>The search tolerance for nearby vertices that are required to be coincident. If a vertex is within this search distance from a vertex of the verified feature, but not coincident with it (according to the CoincidenceTolerance), an error is reported.
- a negative value indicates that the XY tolerance of the verified feature should be used (default)
- a value of 0 indicates that no search for nearby vertices should be performed.
- a positive value is used as search tolerance</value>
  </data>
  <data name="QaVertexCoincidenceOther_relatedClass" xml:space="preserve">
    <value>The feature class to check for vertices that lack a coincident vertex and/or edge in nearby features in  'related class'. All shape types are supported.</value>
  </data>
  <data name="QaVertexCoincidenceOther_relatedClasses" xml:space="preserve">
    <value>The feature classes to search for lacking vertices based on vertices 'featureClasses'.</value>
  </data>
  <data name="QaVertexCoincidenceOther_RequireVertexOnNearbyEdge" xml:space="preserve">
    <value>Indicates if any edge within the EdgeTolerance is required to have a coincident vertex. If True, an error is reported if there is any edge within the EdgeTolerance from the verified vertex, even if the distance from the vertex to the edge is less than or equal the CoincidenceTolerance, as long as there is no coincident vertex on that edge.</value>
  </data>
  <data name="QaVertexCoincidenceOther_Bidirectional" xml:space="preserve">
    <value>Indicates if both vertices in 'featureClass(es)' must have a coincident vertex in 'relatedClass(es)' and vice versa (Bidirectional = true), or if only the vertices in 'featureClass(es)' are required to have a coincident vertex in 'relatedClass(es)', but not the other way around (Bidirectional =false)</value>
  </data>
  <data name="QaPseudoNodes_IgnoreLoopEndpoints" xml:space="preserve">
    <value>Indicates if end points of closed lines which are not connected to another line should be ignored.</value>
  </data>
  <data name="QaValidUrls_MaximumParallelTasks" xml:space="preserve">
    <value>Indicates the maximum number of parallel tasks for validating urls. Default is 1 (no parallel tasks). The actual number of parallel tasks is limited by the number of virtual cores available on the machine. A higher value than the number of virtual cores may be specified, however the number actual parallel tasks will never exceed that limit.</value>
  </data>
  <data name="QaMinSegAngle_AngularUnit" xml:space="preserve">
    <value>Unit of 'limit', default = 'radian'.</value>
  </data>
  <data name="QaMinSegAngle_UseTangents" xml:space="preserve">
    <value>if true: Use angles between segment tangents.
if false: Use vertices to calculate angles.
default = false.</value>
  </data>
  <data name="QaPointNotNear_0" xml:space="preserve">
    <value>Finds points in 'pointClass' that are closer than 'limit' to feature geometries (or geometry components) in 'referenceClass'. </value>
  </data>
  <data name="QaPointNotNear_1" xml:space="preserve">
    <value>Finds points in 'pointClass' that are closer than 'limit' to feature geometries (or geometry components) in 'referenceClasses'.</value>
  </data>
  <data name="QaPointNotNear_GeometryComponents" xml:space="preserve">
    <value>If set, defines which component (entire, border, vertices, end points, start point, end point, centroid, label point, interior vertices) of the reference geometry is checked. If not set, the entire geometry is tested.
If 'GeometryComponents' contains one entry, this component is applied to all reference feature classes. If 'GeometryComponents' contains more than one entry, it must contain exactly the number of feature classes in 'referenceClasses'.</value>
  </data>
  <data name="QaPointNotNear_limit" xml:space="preserve">
    <value>minimum allowed distance</value>
  </data>
  <data name="QaPointNotNear_pointClass" xml:space="preserve">
    <value>Point or line feature class to check. In case of line feature classes, the end points of the lines are tested.</value>
  </data>
  <data name="QaPointNotNear_referenceClass" xml:space="preserve">
    <value>Line or Polygon feature class to check against</value>
  </data>
  <data name="QaPointNotNear_referenceClasses" xml:space="preserve">
    <value>Line or Polygon feature classes to check against</value>
  </data>
  <data name="QaPointNotNear_ValidRelationConstraints" xml:space="preserve">
    <value>If set, defines constraints between a feature of 'pointClass' and a feature of a reference feature class. If this constraint is fulfilled, the distance between the features is not checked against 'limit' and no error is reported.
The involved features are aliased using "G1" and "G2".
Example: G1.Level &lt;&gt; G2.Level.
If 'ValidRelationConstraints' contains one entry, this constraint is applied to all reference feature classes. If 'ValidRelationConstraints' contains more than one entry, it must contain exactly the number of feature classes in 'referenceClasses'.</value>
  </data>
  <data name="QaPointNotNear_MinimumErrorLineLength" xml:space="preserve">
    <value>The minimum length for errors to be reported as connection line between the point and the nearest location on the neighbor feature. For larger values of 'limit', these lines can be used to indicate the corresponding locations that are too close. However, very short lines can be hard to spot, therefore this parameter specifies a lower limit for the length of connection lines, below which the locations are reported as points. 
A negative value indicates, that errors should always be reported as points instead of connection lines.</value>
  </data>
  <data name="QaZDifferenceOther_0" xml:space="preserve">
    <value>Finds features where the Z difference to features from another feature class is less than 'limit'</value>
  </data>
  <data name="QaZDifferenceOther_1" xml:space="preserve">
    <value>Finds features where the Z difference to features from a list of other feature classes is less than 'limit'</value>
  </data>
  <data name="QaZDifferenceOther_featureClass" xml:space="preserve">
    <value>3D feature class to check</value>
  </data>
  <data name="QaZDifferenceOther_featureClasses" xml:space="preserve">
    <value>3D feature classes to check</value>
  </data>
  <data name="QaZDifferenceOther_limit" xml:space="preserve">
    <value>Minimum allowed Z difference</value>
  </data>
  <data name="QaZDifferenceOther_relatedClass" xml:space="preserve">
    <value>3D feature class to compare with</value>
  </data>
  <data name="QaZDifferenceOther_relatedClasses" xml:space="preserve">
    <value>3D feature classes to compare with</value>
  </data>
  <data name="QaZDifferenceOther_zComparisonMethod" xml:space="preserve">
    <value>BoundingBox: check the Z difference between the bounding boxes of features that intersect in 2D
IntersectionPoints: check the Z difference at intersection points, or the Z difference of vertices of the feature class(es) to the plane defined by rings of 2D-intersecting features in the related class(es).</value>
  </data>
  <data name="QaZDifferenceOther_zRelationConstraint" xml:space="preserve">
    <value>Constraint on Z relation of features with 2D intersection.
Upper feature is aliased as "U", lower feature as "L"
Example: U.EdgeLevel &gt; L.EdgeLevel</value>
  </data>
  <data name="QaZDifferenceSelf_1" xml:space="preserve">
    <value>Finds features where the Z difference to another feature within a list of feature classes is less than 'limit'</value>
  </data>
  <data name="QaZDifferenceSelf_featureClass" xml:space="preserve">
    <value>3D feature class to check</value>
  </data>
  <data name="QaCurve_AllowedNonLinearSegmentTypes" xml:space="preserve">
    <value>List of allowed non-linear segment types.</value>
  </data>
  <data name="QaCurve_GroupIssuesBySegmentType" xml:space="preserve">
    <value>If true, create an issue per consecutive segments of the same unallowed segment type.
If false, create an issue per consecutive non-linear segments of any unallowed type.</value>
  </data>
  <data name="QaInteriorRings_IgnoreInnerRingsLargerThan" xml:space="preserve">
    <value>A minimum area for allowed inner rings. If a value &gt; 0 is specified for this parameter, and an inner ring has an area larger than this value, it is ignored (allowed). In this case, it does not count against the 'maximumInteriorRingCount', i.e. that parameter only limits the number of rings that are smaller than the specified area.</value>
  </data>
  <data name="QaInteriorRings_ReportIndividualRings" xml:space="preserve">
    <value>Indicates if rings should be reported as individual errors, or as a multipart error polygon.</value>
  </data>
  <data name="QaInteriorRings_ReportOnlySmallestRingsExceedingMaximumCount" xml:space="preserve">
    <value>If a 'maximumInteriorRingCount' value &gt; 0 is specified, then this indicates if only the smallest unallowed rings exceeding the maximum count should be reported as errors (assuming that the smallest rings are the ones that are incorrect), or if all inner rings (smaller than the area specified for 'IgnoreInnerRingsLargerThan', if specified) should be reported.</value>
  </data>
  <data name="QaFullCoincidence_IgnoreNeighborConditions" xml:space="preserve">
    <value>Optional conditions on a pair of nearby features. If the condition for a given feature pair is defined and fulfilled, the proximity check is not applied to this feature pair.

The verified feature is aliased as "G1", the nearby reference feature as "G2".

Example: G1.CountryCode &lt;&gt; G2.CountryCode

This list may either be empty (no conditions), contain a single condition that is applied for all reference feature classes, or there may be one condition per reference feature class.</value>
  </data>
  <data name="QaNotNear_IgnoreNeighborCondition" xml:space="preserve">
    <value>Optional condition on a pair of nearby features. If the condition is defined and fulfilled, the proximity check is not applied to this feature pair.
The involved features are aliased using "G1" and "G2".
Example: G1.CountryCode &lt;&gt; G2.CountryCode</value>
  </data>
  <data name="QaPartCoincidenceOther_IgnoreNeighborCondition" xml:space="preserve">
    <value>Optional condition on a pair of nearby features. If the condition is defined and fulfilled, the proximity check is not applied to this feature pair.
The involved features are aliased using "G1" and "G2".
Example: G1.CountryCode &lt;&gt; G2.CountryCode</value>
  </data>
  <data name="QaPartCoincidenceSelf_IgnoreNeighborConditions" xml:space="preserve">
    <value>Optional conditions on a pair of nearby features. If the condition for a given feature pair is defined and fulfilled, the proximity check is not applied to this feature pair.

The involved features are aliased using "G1" and "G2".

Example: G1.CountryCode &lt;&gt; G2.CountryCode

If all features are from the same feature class, then this list may contain only one condition (or be empty). For multiple feature classes, either a single condition may be specified that is used for all combinations of features from the individual feature classes, or one condition per possible combination of feature classes can be specified. In this case, the number of conditions must be equal to the square of the number of feature classes. The applicable condition from this list for a pair of features is determined as follows (with 0-based list indexes --&gt; first element = 0):

list index = [feature class list index of feature] * [number of feature classes] +[feature class list index of neighbor feature]

For 2 feature classes, the list of individual conditions must contain 4 elements, and the conditions are used as follows:

0: both features from feature class 0
1: feature class 0 vs. feature class 1
2: feature class 1 vs. feature class 0
3: both features from.feature class 1

or for 3 feature classes, based on just the condition list/feature class list indexes:
(list index: feature class index,feature class index)

0: 0,0
1: 0,1
2: 0,2
3: 1,0
4: 1,1
5: 1,2
6: 2,0
7: 2,1
8: 2,2</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_0" xml:space="preserve">
    <value>Finds polygons that touch the border and have no suitable connecting polygon on the other side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the crossing polygon features are associated to their corresponding border by means of SQL expressions (‘AreaClass1BorderMatchCondition’, ‘AreaClass2BorderMatchCondition’). If the crossing polygon features are also stored in common feature classes, then the polygon feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘CrossingAreaMatchCondition’). Using common feature classes for the border features/crossing polygon features in conjunction with these match conditions allows to verify borders between more than two areas using a single quality condition.

Only polygon features that have at least a partial linear intersection of their boundary with the border geometry of their side are considered as candidates for crossing polygons. The identification of polygons that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a single polygon feature class per side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_1" xml:space="preserve">
    <value>Finds polygons that touch the border and have no suitable connecting polygon on the other side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the crossing polygon features are associated to their corresponding border by means of SQL expressions (‘AreaClass1BorderMatchCondition’, ‘AreaClass2BorderMatchCondition’). If the crossing polygon features are also stored in common feature classes, then the polygon feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘CrossingAreaMatchCondition’). Using common feature classes for the border features/crossing polygon features in conjunction with these match conditions allows to verify borders between more than two areas using a single quality condition.

Only polygon features that have at least a partial linear intersection of their boundary with the border geometry of their side are considered as candidates for crossing polygons. The identification of polygons that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a list of polygon feature classes per side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AreaClass1BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate polygons on side 1 to the corresponding border lines on side 1. This condition is necessary if polygon features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the polygon feature is aliased as AREA, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested polygon feature is treated as a same-side border.

Example: AREA.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AreaClass1BoundingFeatureMatchCondition" xml:space="preserve">
    <value>Optional condition to associate polygons on side 1 to the corresponding 'bounding' features on side 1. This condition may be necessary if polygon features and/or bounding features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the polygon feature is aliased as AREA, and the border feature as BOUNDINGFEATURE. If no condition is specified, any intersecting bounding feature read from the bounding feature class parameter for the same side as the tested polygon feature is treated as applicable for the polygon feature.

Example: AREA.STATE_ID = BOUNDINGFEATURE.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AreaClass2BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate polygons on side 2 to the corresponding border lines on side 2. This condition is necessary if polygon features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the polygon feature is aliased as AREA, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested polygon feature is treated as a same-side border.

Example: AREA.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AreaClass2BoundingFeatureMatchCondition" xml:space="preserve">
    <value>Optional condition to associate polygons on side 2 to the corresponding 'bounding' features on side 2. This condition may be necessary if polygon features and/or bounding features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the polygon feature is aliased as AREA, and the border feature as BOUNDINGFEATURE. If no condition is specified, any intersecting bounding feature read from the bounding feature class parameter for the same side as the tested polygon feature is treated as applicable for the polygon feature.

Example: AREA.STATE_ID = BOUNDINGFEATURE.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_CrossingAreaAttributeConstraint" xml:space="preserve">
    <value>Optional attribute constraint for a pair of polygons touching the border from opposite sides. The polygon features are aliased as AREA1 and AREA2.

Example:
(AREA1.TYPE =AREA2.TYPE) OR (AREA1.TYPE IN (98,99) AND AREA2.TYPE IN (98,99))

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_CrossingAreaEqualAttributeOptions" xml:space="preserve">
    <value>Optional list of comparison options for individual fields specified in 'CrossingAreaEqualAttributes'. Each list entry must start with the field name, followed by a colon (':') and the options for this field. The following options are supported: 

- ignore: allows to ignore characters matching a regular expression in the comparison (removing them from the compared field values). This option is specified in the format ignore=&lt;regular expression&gt;.

- ignoreCondition: allows to ignore specific field values based on an SQL expression. All fields of the compared features can be addressed in the expression. Additionally, the value of the field for which the option applies can be addressed using the alias _VALUE. If the field contains multiple values, or if a preceding 'ignore' option is defined for the same field, then _VALUE contains the parsed single value, which may have been altered by the ignore expression (i.e. characters matching the regular expression are removed). If the expression is fulfilled for a given feature, then the field for which the option is defined is replaced with NULL for the subsequent value comparison.

Examples: 
- for ignoring blanks (e.g. 'A B C' is equivalent to 'ABC'): AREA_NAME:ignore=[ ]
- for ignoring specific values: STATE:ignoreCondition=_VALUE IN ('3000', '3100', '3100') OR ARCHIVED=1</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_CrossingAreaEqualAttributes" xml:space="preserve">
    <value>Optional field names that are required to have equal values for the touching polygon features on opposite sides of the border.
Field names may be separated by ',' or ';' (Note that blanks may not be used to separate field names).
Multi-valued fields based on a separator character (e.g. #) to separate individual values are supported by specifying the separator character for each field (in the format &lt;FIELDNAME&gt;:&lt;separator_character&gt;). In this case, the order of the individual values of a multi-valued field is not significant: field values are considered equal if the sets of individual values are equal (e.g. A#B#C is equivalent to C#B#A, but not A#B or A#B#C#D).

Example: FIELD1,FIELD2:#,FIELD3</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_CrossingAreaMatchCondition" xml:space="preserve">
    <value>The polygon features for opposite sides of the border may be from the same feature class. In this case, a condition can be defined to identify if a polygon feature returned by the spatial search is from the other side. The polygon features to be compared are aliased as AREA1 and AREA2. If no condition is specified, any nearby polygon feature read from the feature class parameter for the other side is treated as a candidate for a valid area continuoation on the other side.

Example: AREA1.STATE_ID &lt;&gt; AREA2.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AllowNoFeatureWithinSearchDistance" xml:space="preserve">
    <value>Indicates if polygons touching the border with no nearby candidate feature on the other side are allowed. Suitable for cases where adjacent polygons on the other side are optional, however any *existing* nearby polygon must match exactly, fulfill attribute constraints etc.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AllowDisjointCandidateFeatureIfBordersAreNotCoincident" xml:space="preserve">
    <value>Indicates if polygon features for which a not exactly adjacent candidate feature exists on the other side should only be reported if the borders are coincident along the section of the polygons where they touch the border.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_IsCrossingAreaAttributeConstraintSymmetric" xml:space="preserve">
    <value>Indicates if the CrossingAreaAttributeConstraint is symmetric, in the sense that the result of the expression will be the same no matter which feature of a crossing polygon feature pair is specified as AREA1 or AREA2 (in cases where features from side 1 and 2 are treated as equivalent). If set to 'False', the constraint expression is evaluated in both directions, and is considered fulfilled if at least one evaluation is fulfilled. This is equivalent to duplicating the specified constraint with inverted AREA1, AREA2 roles and combining both constraints as: (original_constraint) OR (swapped_constraint)

Examples:
- symmetric constraint: AREA1.HEIGHT - AREA2.HEIGHT &gt;= -0.5 AND AREA1.HEIGHT - AREA2.HEIGHT &lt;= 0.5
- asymmetric constraint: (AREA1.TYPE = AREA2.TYPE) OR (AREA1.TYPE = 3 AND AREA2.TYPE IN (3, 6))</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_0" xml:space="preserve">
    <value>Finds sections of polylines that follow along the border and have no suitable coincident polyline on the other side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the bordering polyline features are associated to their corresponding border by means of SQL expressions (‘LineClass1BorderMatchCondition’, ‘LineClass2BorderMatchCondition’). If the bordering polyline features are also stored in common feature classes, then the polyline feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘BorderingLineMatchCondition’). Using common feature classes for the border features/bordering polyline features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only polyline features that have at least a partial linear intersection with the border geometry of their side are considered as candidates for bordering polylines. The identification of polylines that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a single polyline feature class per side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_1" xml:space="preserve">
    <value>Finds sections of polylines that follow along the border and have no suitable coincident polyline on the other side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the bordering polyline features are associated to their corresponding border by means of SQL expressions (‘LineClass1BorderMatchCondition’, ‘LineClass2BorderMatchCondition’). If the bordering polyline features are also stored in common feature classes, then the polyline feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘BorderingLineMatchCondition’). Using common feature classes for the border features/bordering polyline features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only polyline features that have at least a partial linear intersection with the border geometry of their side are considered as candidates for bordering polylines. The identification of polylines that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a list of polyline feature classes per side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_BorderingLineAttributeConstraint" xml:space="preserve">
    <value>Optional attribute constraint for a pair of nearby polylines touching the border from opposite sides. The polyline features are aliased as LINE1 and LINE2.

Example:
(LINE1.TYPE =LINE2.TYPE) OR (LINE1.TYPE IN (98,99) AND LINE2.TYPE IN (98,99))

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_BorderingLineEqualAttributeOptions" xml:space="preserve">
    <value>Optional list of comparison options for individual fields specified in 'BorderingLineEqualAttributes'. Each list entry must start with the field name, followed by a colon (':') and the options for this field. The following options are supported: 

- ignore: allows to ignore characters matching a regular expression in the comparison (removing them from the compared field values). This option is specified in the format ignore=&lt;regular expression&gt;.

- ignoreCondition: allows to ignore specific field values based on an SQL expression. All fields of the compared features can be addressed in the expression. Additionally, the value of the field for which the option applies can be addressed using the alias _VALUE. If the field contains multiple values, or if a preceding 'ignore' option is defined for the same field, then _VALUE contains the parsed single value, which may have been altered by the ignore expression (i.e. characters matching the regular expression are removed). If the expression is fulfilled for a given feature, then the field for which the option is defined is replaced with NULL for the subsequent value comparison.

Examples: 
- for ignoring blanks (e.g. 'A 100' is equivalent to 'A100'): ROUTE_ID:ignore=[ ]
- to only compare national or international route ids (A, B or E followed by a number, allowing for non-numeric suffix in case of 'B'), ignoring blanks also: ROUTE_ID:ignore=^(?![B][ ]?\d+[ ]?[a-zA-Z]*$|[AE][ ]?\d+$).+|[ ]
- for ignoring specific values: STATE:ignoreCondition=_VALUE IN ('3000', '3100', '3100') OR ARCHIVED=1</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_BorderingLineEqualAttributes" xml:space="preserve">
    <value>Optional field names that are required to have equal values for the touching polyline features on opposite sides of the border.
Field names may be separated by ',' or ';' (Note that blanks may not be used to separate field names).
Multi-valued fields based on a separator character (e.g. #) to separate individual values are supported by specifying the separator character for each field (in the format &lt;FIELDNAME&gt;:&lt;separator_character&gt;). In this case, the order of the individual values of a multi-valued field is not significant: field values are considered equal if the sets of individual values are equal (e.g. A#B#C is equivalent to C#B#A, but not A#B or A#B#C#D).

Example: FIELD1,FIELD2:#,FIELD3</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_BorderingLineMatchCondition" xml:space="preserve">
    <value>The polyline features for opposite sides of the border may be from the same feature class. In this case, a condition can be defined to identify if a polyline feature returned by the spatial search is from the other side. The polyline features to be compared are aliased as LINE1 and LINE2. If no condition is specified, any nearby polyline feature read from the feature class parameter for the other side is treated as a candidate for a corresponding polyline on the other side.

Example: LINE1.STATE_ID &lt;&gt; LINE2.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_AllowNonCoincidentEndPointsOnBorder" xml:space="preserve">
    <value>Indicates that end points of bordering lines that touch the interior of an adjacent bordering line on the other side are allowed. If 'False', end points on the border of adjacent bordering lines must be exactly coincident.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_AllowNoFeatureWithinSearchDistance" xml:space="preserve">
    <value>Indicates if polylines with no nearby candidate feature on the other side are allowed. Suitable for cases where coincident polylines on the other side are optional, however any *existing* nearby polylines must match exactly, fulfill attribute constraints etc.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_AllowDisjointCandidateFeatureIfBordersAreNotCoincident" xml:space="preserve">
    <value>Indicates if polyline features for which a not exactly adjacent candidate feature exists on the other side should only be reported if the borders are coincident along the section of the polylines where they touch the border.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_IsBorderingLineAttributeConstraintSymmetric" xml:space="preserve">
    <value>Indicates if the BorderingLineAttributeConstraint is symmetric in the sense that the result of the expression will be the same no matter which feature of a bordering line feature pair is specified as LINE1 or LINE2 (in cases where features from side 1 and 2 are treated as equivalent). If set to 'False', the constraint expression is evaluated in both directions, and is considered fulfilled if at least one evaluation is fulfilled. This is equivalent to duplicating the specified constraint with inverted LINE1, LINE2 roles and combining both constraints as: (original_constraint) OR (swapped_constraint)

Examples:
- symmetric constraint: LINE1.WIDTH - LINE2.WIDTH &gt;= -0.5 AND LINE1.WIDTH - LINE2.WIDTH &lt;= 0.5
- asymmetric constraint: (LINE1.WIDTH_CLASS = LINE2.WIDTH_CLASS) OR (LINE1.WIDTH_CLASS = 3 AND LINE2.WIDTH_CLASS IN (3, 6))</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_LineClass1BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate lines on side 1 to the corresponding border lines on side 1. This condition is necessary if line features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the line feature is aliased as LINE, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested line feature is treated as a same-side border.

Example: LINE.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_LineClass2BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate lines on side 2 to the corresponding border lines on side 2. This condition is necessary if line features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the line feature is aliased as LINE, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested line feature is treated as a same-side border.

Example: LINE.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_0" xml:space="preserve">
    <value>Finds points located on the border which have no coincident corresponding point for the opposite side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the point features are associated to their corresponding border by means of SQL expressions (‘PointClass1BorderMatchCondition’, ‘PointClass2BorderMatchCondition’). If the bordering point features are also stored in common feature classes, then the point feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘BorderingPointMatchCondition’). Using common feature classes for the border features/bordering point features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only point features located exactly on the border geometry of their side are considered as candidates for bordering points. The identification of points that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a single point feature class per side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_1" xml:space="preserve">
    <value>Finds points located on the border which have no coincident corresponding point for the opposite side of the border that fulfills defined attribute matching rules.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the point features are associated to their corresponding border by means of SQL expressions (‘PointClass1BorderMatchCondition’, ‘PointClass2BorderMatchCondition’). If the bordering point features are also stored in common feature classes, then the point feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘BorderingPointMatchCondition’). Using common feature classes for the border features/bordering point features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only point features located exactly on the border geometry of their side are considered as candidates for bordering points. The identification of points that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a list of point feature classes per side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_BorderingPointAttributeConstraint" xml:space="preserve">
    <value>Optional attribute constraint for a pair of bordering points. The point features are aliased as POINT1 and POINT2.

Example:
(POINT1.TYPE = POINT2.TYPE) OR (POINT1.TYPE IN (98,99) AND POINT2.TYPE IN (98,99))

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_BorderingPointEqualAttributeOptions" xml:space="preserve">
    <value>Optional list of comparison options for individual fields specified in 'BorderingPointEqualAttributes'. Each list entry must start with the field name, followed by a colon (':') and the options for this field. The following options are supported: 

- ignore: allows to ignore characters matching a regular expression in the comparison (removing them from the compared field values). This option is specified in the format ignore=&lt;regular expression&gt;.

- ignoreCondition: allows to ignore specific field values based on an SQL expression. All fields of the compared features can be addressed in the expression. Additionally, the value of the field for which the option applies can be addressed using the alias _VALUE. If the field contains multiple values, or if a preceding 'ignore' option is defined for the same field, then _VALUE contains the parsed single value, which may have been altered by the ignore expression (i.e. characters matching the regular expression are removed). If the expression is fulfilled for a given feature, then the field for which the option is defined is replaced with NULL for the subsequent value comparison.

Examples: 
- for ignoring blanks (e.g. 'A B C' is equivalent to 'ABC'): POINT_NAME:ignore=[ ]
- for ignoring specific values: STATE:ignoreCondition=_VALUE IN ('3000', '3100', '3100') OR ARCHIVED=1</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_BorderPointEqualAttributes" xml:space="preserve">
    <value>Optional field names that are required to have equal values for the corresponding point features on opposite sides of the border.
Field names may be separated by ',' or ';' (Note that blanks may not be used to separate field names).
Multi-valued fields based on a separator character (e.g. #) to separate individual values are supported by specifying the separator character for each field (in the format &lt;FIELDNAME&gt;:&lt;separator_character&gt;). In this case, the order of the individual values of a multi-valued field is not significant: field values are considered equal if the sets of individual values are equal (e.g. A#B#C is equivalent to C#B#A, but not A#B or A#B#C#D).

Example: FIELD1,FIELD2:#,FIELD3</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_BorderingPointMatchCondition" xml:space="preserve">
    <value>The point features for opposite sides of the border may be from the same feature class. In this case, a condition can be defined to identify if a point feature returned by the spatial search is from the other side. The point features to be compared are aliased as POINT1 and POINT2. If no condition is specified, any nearby point feature read from the feature class parameter for the other side is treated as a candidate for a corresponding point on the other side.

Example: POINT1.STATE_ID &lt;&gt; POINT2.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_CoincidenceTolerance" xml:space="preserve">
    <value>The XY tolerance for bordering points to be considered coincident. If a negative value is specified, then the XY tolerance of the point feature class is used. Otherwise, the specified value is used.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_AllowNoFeatureWithinSearchDistance" xml:space="preserve">
    <value>Indicates if points with no nearby candidate feature on the other side are allowed. Suitable for cases where coincident points on the other side are optional, however any *existing* nearby points must match exactly, fulfill attribute constraints etc.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_AllowDisjointCandidateFeatureIfBordersAreNotCoincident" xml:space="preserve">
    <value>Indicates if point features for which a not exactly coincident candidate point feature exists on the other side should only be reported if the borders are coincident at the point locations.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_IsBorderingPointAttributeConstraintSymmetric" xml:space="preserve">
    <value>Indicates if the BorderingPointAttributeConstraint is symmetric in the sense that the result of the expression will be the same no matter which feature of a corresponding point pair is specified as POINT1 or POINT2 (in cases where features from side 1 and 2 are treated as equivalent). If set to 'False', the constraint expression is evaluated in both directions, and is considered fulfilled if at least one evaluation is fulfilled. This is equivalent to duplicating the specified constraint with inverted POINT1, POINT2 roles and combining both constraints as: (original_constraint) OR (swapped_constraint)

Examples:
- symmetric constraint: POINT1.HEIGHT - POINT2.HEIGHT &gt;= -0.5 AND POINT1.HEIGHT - POINT2.HEIGHT &lt;= 0.5
- asymmetric constraint: (POINT1.SIZE_CLASS = POINT2.SIZE_CLASS) OR (POINT1.SIZE_CLASS = 3 AND POINT2.SIZE_CLASS IN (3, 6))</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_PointClass1BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate points on side 1 to the corresponding border lines on side 1. This condition is necessary if point features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the point feature is aliased as POINT, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested point feature is treated as a same-side border.

Example: POINT.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_PointClass2BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate points on side 2 to the corresponding border lines on side 2. This condition is necessary if point features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the point feature is aliased as POINT, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested point feature is treated as a same-side border.

Example: POINT.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_0" xml:space="preserve">
    <value>Finds lines that end on the border which have no suitable connecting neighbor line on the other side of the border.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the crossing polyline features are associated to their corresponding border by means of SQL expressions (‘LineClass1BorderMatchCondition’, ‘LineClass2BorderMatchCondition’). If the crossing polyline features are also stored in common feature classes, then the polyline feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘CrossingLineMatchCondition’). Using common feature classes for the border features/crossing polyline features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only polyline features that have at least one end point located exactly on the border geometry of their side are considered as candidates for crossing polylines. The identification of polyline end points that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a single polyline feature class per side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_1" xml:space="preserve">
    <value>Finds lines that end on the border which have no suitable connecting neighbor line on the other side of the border.

Different border representations may be used for the respective sides, i.e. the borders are not required to be exactly coincident for this test to be applicable.

The border features may be stored either in two separate border feature classes, or in a common border feature class containing the borders for different areas. When using a common border feature class, the crossing polyline features are associated to their corresponding border by means of SQL expressions (‘LineClass1BorderMatchCondition’, ‘LineClass2BorderMatchCondition’). If the crossing polyline features are also stored in common feature classes, then the polyline feature pairs belonging to opposite sides of the border are also identified by an SQL expression (‘CrossingLineMatchCondition’). Using common feature classes for the border features/crossing polyline features in conjunction with the match conditions allows to verify borders between more than two areas using a single quality condition.

Only polyline features that have at least one end point located exactly on the border geometry of their side are considered as candidates for crossing polylines. The identification of polyline end points that are close to, but not exactly snapped to border geometries is possible using proximity tests.

Based on a list of polyline feature classes per side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_CoincidenceTolerance" xml:space="preserve">
    <value>The XY tolerance for line end points to be considered connected. If a negative value is specified, then the XY tolerance of the line feature class is used. Otherwise, the specified value is used.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_CrossingLineAttributeConstraint" xml:space="preserve">
    <value>Optional attribute constraint for a pair of crossing lines. The line features are aliased as LINE1 and LINE2.

Example:
(LINE1.WIDTH_CLASS = LINE2.WIDTH_CLASS) OR (LINE1.WIDTH_CLASS = 3 AND LINE2.WIDTH_CLASS IN (3, 6))

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_CrossingLineEqualAttributeOptions" xml:space="preserve">
    <value>Optional list of comparison options for individual fields specified in 'CrossingLineEqualAttributes'. Each list entry must start with the field name, followed by a colon (':') and the options for this field. The following options are supported: 

- ignore: allows to ignore characters matching a regular expression in the comparison (removing them from the compared field values). This option is specified in the format ignore=&lt;regular expression&gt;.

- ignoreCondition: allows to ignore specific field values based on an SQL expression. All fields of the compared features can be addressed in the expression. Additionally, the value of the field for which the option applies can be addressed using the alias _VALUE. If the field contains multiple values, or if a preceding 'ignore' option is defined for the same field, then _VALUE contains the parsed single value, which may have been altered by the ignore expression (i.e. characters matching the regular expression are removed). If the expression is fulfilled for a given feature, then the field for which the option is defined is replaced with NULL for the subsequent value comparison.

Examples: 
- for ignoring blanks (e.g. 'A 100' is equivalent to 'A100'): ROUTE_ID:ignore=[ ]
- to only compare national or international route ids (A, B or E followed by a number, allowing for non-numeric suffix in case of 'B'), ignoring blanks also: ROUTE_ID:ignore=^(?![B][ ]?\d+[ ]?[a-zA-Z]*$|[AE][ ]?\d+$).+|[ ]
- for ignoring specific values: STATE:ignoreCondition=_VALUE IN ('3000', '3100', '3100') OR ARCHIVED=1</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_CrossingLineEqualAttributes" xml:space="preserve">
    <value>Optional field names that are required to have equal values for the crossing line features on opposite sides of the border.
Field names may be separated by ',' or ';' (Note that blanks may not be used to separate field names).
Multi-valued fields based on a separator character (e.g. #) to separate individual values are supported by specifying the separator character for each field (in the format &lt;FIELDNAME&gt;:&lt;separator_character&gt;). In this case, the order of the individual values of a multi-valued field is not significant: field values are considered equal if the sets of individual values are equal (e.g. A#B#C is equivalent to C#B#A, but not A#B or A#B#C#D).

Example: FIELD1,FIELD2:#,FIELD3</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_CrossingLineMatchCondition" xml:space="preserve">
    <value>The line features for opposite sides of the border may be from the same feature class. In this case, a condition can be defined to identify if a line feature returned by the spatial search is from the other side. The line features to be compared are aliased as LINE1 and LINE2. If no condition is specified, any nearby line feature read from the feature class parameter for the other side is treated as a candidate for a valid line continuation on the other side.

Example: LINE1.STATE_ID &lt;&gt; LINE2.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_IgnoreAttributeConstraintsIfThreeOrMoreConnected" xml:space="preserve">
    <value>Indicates if attribute constraints should be ignored if more than two crossing lines are connected in one point on the border</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_AllowEndPointsConnectingToInteriorOfValidNeighborLine" xml:space="preserve">
    <value>Indicates if line end points on the border that do not connect to a neighbor line end point, but to the interior of a valid neighbor line, are allowed. The connection is only allowed if the attribute constraints are fulfilled with the neighbor line.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_IgnoreEndPointsOfBorderingLines" xml:space="preserve">
    <value>Indicates if end points of lines whose last segment follows along the border line should be ignored (in cases where the same lines are also checked with the test for bordering lines, to avoid reporting attribute constraint violations twice).</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_IgnoreNeighborLinesWithBorderConnectionOutsideSearchDistance" xml:space="preserve">
    <value>Indicates if neighbor lines that pass within the search distance from the end point of the tested line, but whose end point connection to the border is farther away than the search distance, should be ignored (i.e., not treated as 'candidates' for a connection).</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_AllowNoFeatureWithinSearchDistance" xml:space="preserve">
    <value>Indicates if lines with no nearby candidate feature on the other side are allowed. Suitable for cases where connections on the other side are optional, however any *existing* connections must match exactly, fulfill attribute constraints etc.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_AllowNoFeatureWithinSearchDistanceIfConnectedOnSameSide" xml:space="preserve">
    <value>Indicates if if lines with no nearby candidate feature on the other side are allowed if the end point on the border is connected to another feature on the same side. If 'AllowNoFeatureWithinSearchDistance' is true, then this parameter has no effect, since missing candidate features are generally allowed.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_AllowDisjointCandidateFeatureIfBordersAreNotCoincident" xml:space="preserve">
    <value>Indicates if line end points for which a not exactly connected candidate feature exists on the other side should only be reported if the borders are coincident at the border connections of the two line features.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_IsCrossingLineAttributeConstraintSymmetric" xml:space="preserve">
    <value>Indicates if the CrossingLineAttributeConstraint is symmetric in the sense that the result of the expression will be the same no matter which feature of a crossing line feature pair is specified as LINE1 or LINE2 (in cases where features from side 1 and 2 are treated as equivalent). If set to 'False', the constraint expression is evaluated in both directions, and is considered fulfilled if at least one evaluation is fulfilled. This is equivalent to duplicating the specified constraint with inverted LINE1, LINE2 roles and combining both constraints as: (original_constraint) OR (swapped_constraint)

Examples:
- symmetric constraint: LINE1.WIDTH - LINE2.WIDTH &gt;= -0.5 AND LINE1.WIDTH - LINE2.WIDTH &lt;= 0.5
- asymmetric constraint: (LINE1.WIDTH_CLASS = LINE2.WIDTH_CLASS) OR (LINE1.WIDTH_CLASS = 3 AND LINE2.WIDTH_CLASS IN (3, 6))</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_LineClass1BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate lines on side 1 to the corresponding border lines on side 1. This condition is necessary if line features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the line feature is aliased as LINE, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested line feature is treated as a same-side border.

Example: LINE.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_LineClass2BorderMatchCondition" xml:space="preserve">
    <value>Optional condition to associate lines on side 2 to the corresponding border lines on side 2. This condition is necessary if line features and/or border features for both sides are stored in the same respective feature classes (i.e. no separate feature classes for opposite sides of the border). In the condition expression, the line feature is aliased as LINE, and the border feature as BORDER. If no condition is specified, any nearby border feature read from the border feature class parameter for the same side as the tested line feature is treated as a same-side border.

Example: LINE.STATE_ID = BORDER.STATE_ID

See syntax documentation in SQLSyntax_en.pdf</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_MaximumEndPointConnectionDistance" xml:space="preserve">
    <value>Maximum distance for considering line end points connecting to the border as possible matches. If the end points are farther away than this distance (but the neighbor feature is close enough to be a candidate), the reported issue indicates this (in the issue description and the issue code, and by creating an issue geometry based on the nearest location along the neighbor line instead of the two border connection points). A value &lt;= 0 is interpreted as unlimited, i.e. the reported issue is always based on the nearest border connections of nearby lines.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_MinimumErrorConnectionLineLength" xml:space="preserve">
    <value>Controls the type of issue geometry for connecting border connection end points of nearby lines. If the distance between the points is smaller than this value, the issue geometry is a multipoint geometry containing the two points. Otherwise, a polyline connecting the two points is created. This distance allows to avoid the creation of very short line geometries that would no longer be displayed at relevant map scales.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_areaClass1" xml:space="preserve">
    <value>Polygon feature class containing the polygons on side 1 to check for the existence of suitable adjacent neighbor polygons on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_areaClass2" xml:space="preserve">
    <value>Polygon feature class containing the polygons on side 2 to check for the existence of suitable adjacent neighbor polygons on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_areaClasses1" xml:space="preserve">
    <value>Polygon feature classes containing the polygons on side 1 to check for the existence of suitable adjacent neighbor polygons on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_areaClasses2" xml:space="preserve">
    <value>Polygon feature classes containing the polygons on side 2 to check for the existence of suitable adjacent neighbor polygons on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_borderClass1" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 1</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_borderClass2" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 2</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_boundingClasses1" xml:space="preserve">
    <value>List of optional feature classes that indicate valid situations where a polygon feature on side 1 does not have a continuation on the other side of the border. If the section of a polygon feature that touches its border has no adjacent polygon feature on the other side, but intersects one of the features from the 'bounding' classes, no issue is reported.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_boundingClasses2" xml:space="preserve">
    <value>List of optional feature classes that indicate valid situations where a polygon feature on side 2 does not have a continuation on the other side of the border. If the section of a polygon feature that touches its border has no adjacent polygon feature on the other side, but intersects one of the features from the 'bounding' classes, no issue is reported.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_searchDistance" xml:space="preserve">
    <value>The maximum distance for searching candidate neighbor polygon features on the other side of the border. Only polygon features that touch their border are taken into account as potential candidates.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_borderClass1" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 1</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_borderClass2" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 2</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_searchDistance" xml:space="preserve">
    <value>The maximum distance for searching candidate neighbor polyline features on the other side of the border. Only polyline features that touch their border are taken into account as potential candidates.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_lineClass1" xml:space="preserve">
    <value>Polyline feature class containing the polylines on side 1 to check for existence of adjacent neighbor polylines on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_lineClass2" xml:space="preserve">
    <value>Polyline feature class containing the polylines on side 2 to check for existence of adjacent neighbor polylines on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_lineClasses1" xml:space="preserve">
    <value>Polyline feature classes containing the polylines on side 1 to check for existence of adjacent neighbor polylines on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_lineClasses2" xml:space="preserve">
    <value>Polyline feature classes containing the polylines on side 2 to check for existence of adjacent neighbor polylines on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_borderClass1" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 1</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_borderClass2" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 2</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_pointClass1" xml:space="preserve">
    <value>Point feature class containing the points on side 1 to check for existence of coincident neighbor points on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_pointClass2" xml:space="preserve">
    <value>Point feature class containing the points on side 2 to check for existence of coincident neighbor points on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_pointClasses1" xml:space="preserve">
    <value>Point feature classes containing the points on side 1 to check for existence of coincident neighbor points on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_pointClasses2" xml:space="preserve">
    <value>Point feature classes containing the points on side 2 to check for existence of coincident neighbor points on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_searchDistance" xml:space="preserve">
    <value>The maximum distance for searching candidate point features on the other side of the border. Only point features that are located on their border are taken into account as potential candidates.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_borderClass1" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 1.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_borderClass2" xml:space="preserve">
    <value>Polyline or polygon feature class containing the border geometry on side 2.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_searchDistance" xml:space="preserve">
    <value>The maximum distance for searching candidate neighbor line features on the other side of the border. Only line features that have at least one end point located on their border are taken into account as potential candidates.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_lineClass1" xml:space="preserve">
    <value>Polyline feature class containing the lines on side 1 to check for connections to suitable neighbor lines on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_lineClass2" xml:space="preserve">
    <value>Polyline feature class containing the lines on side 2 to check for connections to suitable neighbor lines on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_lineClasses1" xml:space="preserve">
    <value>Polyline feature classes containing the lines on side 1 to check for connections to suitable neighbor lines on the other side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_lineClasses2" xml:space="preserve">
    <value>Polyline feature class containing the lines on side 2 to check for connections to suitable neighbor lines on the other side.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_AllowDisjointCandidateFeatureIfAttributeConstraintsAreFulfilled" xml:space="preserve">
    <value>Indicates if polyline features for which a not exactly adjacent candidate feature exists on the other side should only be reported if the attribute constraints are not fulfilled with the candidate feature.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_AllowDisjointCandidateFeatureIfAttributeConstraintsAreFulfilled" xml:space="preserve">
    <value>Indicates if point features for which a not exactly coincident candidate point feature exists on the other side should only be reported if the attribute constraints are not fulfilled with the candidate feature.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_AllowDisjointCandidateFeatureIfAttributeConstraintsAreFulfilled" xml:space="preserve">
    <value>Indicates if polygon features for which a not exactly adjacent candidate feature exists on the other side should only be reported if the attribute constraints are not fulfilled with the candidate feature.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_AllowDisjointCandidateFeatureIfAttributeConstraintsAreFulfilled" xml:space="preserve">
    <value>Indicates if line end points for which a not exactly connected candidate feature exists on the other side should only be reported if the attribute constraints are not fulfilled with the candidate feature.</value>
  </data>
  <data name="QaPartCoincidenceOther_4" xml:space="preserve">
    <value>Find line sections longer than a specified minimum length in 'featureClass', that lie nearer than 'near' to lines in 'reference' but are not coincident. The minimum length can be defined separately for line pairs that are connected ('connectedMinLength') or disjoint ('disjointMinLength'). A coincidence tolerance can be specified to indicate a maximum allowed offset between the lines at which they are still considered to be coincident.

Remark: All feature classes in 'featureClass' and 'reference' must have the same spatial reference.</value>
  </data>
  <data name="QaPartCoincidenceSelf_6" xml:space="preserve">
    <value>Find line sections longer than a specified minimum length in 'featureClasses', where 2 non-coincident lines lie nearer than 'near', but are not coincident. The minimum length can be defined separately for line pairs that are connected ('connectedMinLength') or disjoint ('disjointMinLength'). A coincidence tolerance can be specified to indicate a maximum allowed offset between the lines at which they are still considered to be coincident.

Remark: All feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaPointNotNear_AllowCoincidentPoints" xml:space="preserve">
    <value>Indicates that points coincident with a reference feature (or a geometry component thereof) are allowed. The maximum XY tolerance of the point feature class and the reference feature class is used to determine coincidence.</value>
  </data>
  <data name="QaNodeLineCoincidence_CoincidenceTolerance" xml:space="preserve">
    <value>The tolerance for nodes to be considered coincident with nearby lines. If a negative value is specified, then the XY tolerance of the node feature class is used. Otherwise, the specified value is used.</value>
  </data>
  <data name="QaInteriorIntersectsOther_ValidIntersectionGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid intersection geometries. The constraint can be based on the following geometry properties:

- $Area - the geometry area (0 for points and polylines)
- $Length - the length of the geometry (perimeter length in case of polygons; 0 for point)
- $VertexCount - the number of vertices of the geometry
- $SliverRatio - the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon. NULL for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)
- $PartCount - the number of geometry parts (paths for polylines, rings - both exterior and interior - for polygons)
- $IsMultipart - indicates if the geometry consists of multiple parts (rings or paths). In case of polygons, only True if there are multiple exterior rings
- $ExteriorRingCount - the number of exterior rings in the polygon
- $InteriorRingCount - the number of interior rings in the polygon

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10
  $Length &gt; 10 OR $PartCount &gt; 1

If both an attribute comparison constraint and an intersection geometry constraint are defined, then the intersection is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaInteriorIntersectsSelf_ValidIntersectionGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid intersection geometries. The constraint can be based on the following geometry properties:

- $Area - the geometry area (0 for points and polylines)
- $Length - the length of the geometry (perimeter length in case of polygons; 0 for points)
- $VertexCount - the number of vertices of the geometry
- $SliverRatio - the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon. NULL for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)
- $PartCount - the number of geometry parts (paths for polylines, rings - both exterior and interior - for polygons)
- $IsMultipart - indicates if the geometry consists of multiple parts (rings or paths). In case of polygons, only True if there are multiple exterior rings
- $ExteriorRingCount - the number of exterior rings in the polygon
- $InteriorRingCount - the number of interior rings in the polygon

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10
  $Length &gt; 10 OR $PartCount &gt; 1

If both an attribute comparison constraint and an intersection geometry constraint are defined, then the intersection is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaLineGroupConstraints_0" xml:space="preserve">
    <value>Find errors in checking if connected polylines of 'networkFeatureClasses' with same attributes related to 'groupBy' meet the conditions defined by the parameters</value>
  </data>
  <data name="QaLineGroupConstraints_groupBy" xml:space="preserve">
    <value>a list of all field names that define a key. Features with the same key are tested to meet the conditions</value>
  </data>
  <data name="QaLineGroupConstraints_minGap" xml:space="preserve">
    <value>Find all endpoints closer than 'minGap' to other connected lines of the same 'groupBy'-key.

If 'MinGapToSameGroupCovered' &gt; 0, 'MinGapToSameGroupAtFork' &gt; 0, and/or 'MinGapToSameGroupAtForkCovered' &gt; 0, this value is only checked at gaps, that do not fulfill the constraints for the corresponding setting. I.e., if 'MinGapToSameGroupAtFork' &gt; 0, 'minGap' is only checked at gaps, that do not start at a fork.</value>
  </data>
  <data name="QaLineGroupConstraints_minGroupLength" xml:space="preserve">
    <value>Find all connected lines where the sum of the lengths are shorter than minGroupLength</value>
  </data>
  <data name="QaLineGroupConstraints_minDangleLength" xml:space="preserve">
    <value>Find all dangles of connected lines where the sum of the lengths are shorter than 'minDangleLength'. A dangle is any part of the group from a junction with 3 or more lines to an endpoint of the group.

If 'MinDangleLengthContinued' &gt; 0, 'MinDangleLengthAtFork' &gt; 0, and/or 'MinDangleLengthAtForkContinued' &gt; 0, this value is only checked at dangles, that do not fulfill the constraints for the corresponding settings. I.e. if 'MinDangleLengthAtFork' &gt;0, 'minDangleLength' is only checked at dangles, that do not end at a fork.</value>
  </data>
  <data name="QaLineGroupConstraints_networkFeatureClasses" xml:space="preserve">
    <value>featureclasses to be tested.</value>
  </data>
  <data name="QaLineGroupConstraints_GroupConditions" xml:space="preserve">
    <value>Only groups that fulfill 'GroupConditions' are tested.</value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToOtherGroupType" xml:space="preserve">
    <value>Find all endpoints closer than 'MinGapToOtherGroup' to other connected lines of a different 'groupBy'-key.

If 'MinGapToOtherGroupAtFork' &gt;0, this value is only checked, if the gap does not start at a fork.</value>
  </data>
  <data name="QaLineGroupConstraints_ValueSeparator" xml:space="preserve">
    <value>An optional separator for storing multiple group identifiers in the same field (e.g. E100#E200)</value>
  </data>
  <data name="QaLineGroupConstraints_MinDangleLengthAtForkContinued" xml:space="preserve">
    <value>Minimum allowed dangle length, when the dangle end is at a fork and is connected to at least one other group.</value>
  </data>
  <data name="QaLineGroupConstraints_MinDangleLengthAtFork" xml:space="preserve">
    <value>Minimum allowed dangle length, when the dangle end is at a fork.

If 'MinDangleLengthAtForkContinued' &gt; 0, this value is only checked, when the dangle end is at a fork, but is not connected to any other group.</value>
  </data>
  <data name="QaLineGroupConstraints_MinDangleLengthContinued" xml:space="preserve">
    <value>Minimum allowed dangle length, when the dangle end is connected to another group. 

If 'MinDangleLengthAtForkContinued' &gt; 0, this value is only checked, when the dangle is connected to at least one other group, but does not end at a fork.</value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToOtherGroupTypeAtFork" xml:space="preserve">
    <value>Minimum allowed gap to another group, when the gap starts at a fork.</value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToSameGroupTypeAtFork" xml:space="preserve">
    <value>Minimum allowed gap to a group of the same group type, when the gap starts at a fork.

If 'MinGapToSameGroupAtForkCovered' &gt; 0, this value is only used for gaps, that are not completely covered by other groups.</value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToSameGroupTypeAtForkCovered" xml:space="preserve">
    <value>Minimum allowed gap to a group of the same group type, when the gap starts at a fork and is fully covered by other groups</value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToSameGroupTypeCovered" xml:space="preserve">
    <value>Minimum allowed gap to a group of the same group type, when the entire gap is fully covered by other groups.

If 'MinGapToSameGroupAtForkCovered' &gt; 0, this value is only used for gaps, that do not start at a fork.</value>
  </data>
  <data name="QaMonotonicZ_0" xml:space="preserve">
    <value>Finds non-monotonic sequences in Z values</value>
  </data>
  <data name="QaMonotonicZ_AllowConstantValues" xml:space="preserve">
    <value>Indicates if constant Z values are not to be treated as errors. Default is True.</value>
  </data>
  <data name="QaMonotonicZ_ExpectedMonotonicity" xml:space="preserve">
    <value>The expected direction of monotonic change of the sequence of Z values along the line feature. By default, the sequence of Z values runs from the start point to the end point of the feature. By specifying a FlipExpression, this ordering can be inverted based on the value of one or more attributes.

- MonotonicityDirection.Any: the expected direction of monotonic change is defined by the Z values of the start/end points of the line feature: if the Z value of the start point is higher than the Z value of end point, then the Z values are expected to monotonically decrease from start to end (and vice versa). This is the default.
- MonotonicityDirection.Increasing: Z values are expected to monotonically increase along the feature (start to end, possible inverted based on FlipExpression)
- MonotonicityDirection.Decreasing: Z values are expected to monotonically decrease along the feature (start to end, possible inverted based on FlipExpression)</value>
  </data>
  <data name="QaMonotonicZ_FlipExpression" xml:space="preserve">
    <value>Expression to evaluate if feature needs to be flipped for monotonicity evaluation. If the expression returns True, then the sequence of Z values is reversed.</value>
  </data>
  <data name="QaMonotonicZ_lineClass" xml:space="preserve">
    <value>Line feature class</value>
  </data>
  <data name="QaSurfacePipe_2" xml:space="preserve">
    <value>Finds all line segments in 'featureClass' that differ more than 'limit' from 'raster'
Remark: The feature classes in 'featureClass' and 'raster' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfacePipe_raster" xml:space="preserve">
    <value>raster to compare</value>
  </data>
  <data name="QaSurfaceVertex_2" xml:space="preserve">
    <value>Finds all points or vertices in 'featureClass' that differ more than 'limit' from 'raster'

Remark: The feature classes in 'featureClass' and 'raster' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfaceVertex_raster" xml:space="preserve">
    <value>raster to compare</value>
  </data>
  <data name="QaSurfacePipe_4" xml:space="preserve">
    <value>Finds all line segments in 'featureClass' that differ more than 'limit' from 'rasterMosaic'

Remark: The feature classes in 'featureClass' and 'rasterMosaic' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfacePipe_mosaic" xml:space="preserve">
    <value>Raster mosaic that provides the surface to compare</value>
  </data>
  <data name="QaSurfaceVertex_4" xml:space="preserve">
    <value>Finds all points or vertices in 'featureClass' that differ more than 'limit' from 'rasterMosaic'

Remark: The feature classes in 'featureClass' and 'rasterMosaic' must have the same spatial reference.</value>
  </data>
  <data name="QaSurfaceVertex_mosaic" xml:space="preserve">
    <value>Raster mosaic that provides the surface to compare</value>
  </data>
  <data name="QaLineConnectionFieldValues_allowedPointsExpressions" xml:space="preserve">
    <value>Expression to identify points in 'pointClasses' that are considered valid regardless of their values of the 'pointFields' field name or expression. There must be either a single allowPointExpressions value in the list which is valid for all feature classes in 'pointClasses', or there must be one entry in 'allowedPointsExpressions' per entry in 'pointClasses' and the two lists must be sorted in equal order.</value>
  </data>
  <data name="QaLineConnectionFieldValues_pointClasses" xml:space="preserve">
    <value>Point featureClasses</value>
  </data>
  <data name="QaLineConnectionFieldValues_pointFields" xml:space="preserve">
    <value>Fields of 'pointClasses' to use for checking the specified constraint. There must be either a single point field value in the list which is valid for all feature classes in 'pointClasses', or there must be one entry in 'pointFields' per entry in 'pointClasses' and the two lists must be sorted in equal order.</value>
  </data>
  <data name="QaLineConnectionFieldValues_4" xml:space="preserve">
    <value>Checks constraints for the distinct values of fields from connected lines at a location.</value>
  </data>
  <data name="QaVertexCoincidence_ZCoincidenceTolerance" xml:space="preserve">
    <value>Tolerance below which Z values of two coincident vertices are considered as equal/coincident.
 
Note: 'ZCoincidenceTolerance' is only used if 'ZTolerance' is not set to 0.

'ZCoincidenceTolerance' &lt; 0: Use the maximum Z tolerance of the involved feature classes
'ZCoincidenceTolerance' == 0 (default value): Z values must be exactly equal to be considered coincident
'ZCoincidenceTolerance' &gt; 0: Use the specified value to determine equality/coincidence of Z values</value>
  </data>
  <data name="QaVertexCoincidence_ZTolerance" xml:space="preserve">
    <value>The Z search distance within which coincident vertices/edges should have corresponding Z values.

if 'ZTolerance' = 0 (default) : Z values of vertices/edges are not compared

if 'ZTolerance' &gt; 0 :
- any Z difference between two vertices that is larger than this tolerance is ignored (-&gt; it is considered a deliberate Z offset, no error)
- any Z difference between two vertices that is smaller than this tolerance, but not coincident (as defined by 'ZCoincidenceTolerance') is reported

if 'ZTolerance' &lt; 0:
- any Z difference between two vertices that is larger than the coincidence tolerance (defined by 'ZCoincidenceTolerance') is reported</value>
  </data>
  <data name="QaRepresentationConstraints_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' whose 'representation' does not conform to specified constraints</value>
  </data>
  <data name="QaRepresentationConstraints_AllowExplicitFieldOverrides" xml:space="preserve">
    <value>If 'AllowPropertyOverrides' is false, with true, allows explicit field overrides (any property mapped to a field except visibility)</value>
  </data>
  <data name="QaRepresentationConstraints_AllowFreeRepresentation" xml:space="preserve">
    <value>Specifies if free representations are allowed</value>
  </data>
  <data name="QaRepresentationConstraints_AllowInvalidRuleID" xml:space="preserve">
    <value>Specifies if invalid representation rules (Rule IDs) are allowed</value>
  </data>
  <data name="QaRepresentationConstraints_AllowInvisibleRepresentation" xml:space="preserve">
    <value>Specifies if invisible representations are allowed</value>
  </data>
  <data name="QaRepresentationConstraints_AllowPropertyOverrides" xml:space="preserve">
    <value>Specifies if representation property overrides are allowed</value>
  </data>
  <data name="QaRepresentationConstraints_AllowShapeOverride" xml:space="preserve">
    <value>Specifies if representation shape overrides are allowed</value>
  </data>
  <data name="QaRepresentationConstraints_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaRepresentationConstraints_representation" xml:space="preserve">
    <value>feature class representation</value>
  </data>
  <data name="QaRepresentationConstraints_ValidPropertyOverrides" xml:space="preserve">
    <value>List of valid property overrides.
A symbol property can be defined with the syntax: RuleID{value}#{Path}#{GraphicAttribute} where {Path} can be specified using:

Effects[#]             global geometric effect, indexing is zero-based
Layers[#]              hint: only BasicMarkerSymbols have layer-level graphic attrs
Layers[#].FillPattern  assume layer is a fill symbol and get its FillPattern
Layers[#].LineStroke   assume layer is a line symbol and get its Stroke
Layers[#].MarkerPlacement assume layer is a marker symbol and get its MarkerPlacement
Layers[#].Effects[#]   local geometric effect, indexing is zero-based

- The first index for both Layers[#] and Effects[#] is zero.
- Layers are counted from the bottom up, that is, Layers[0] is the one drawn first; in the ArcGIS user interface, this corresponds to the bottom-most tab.
- Effects are counted from the top down, that is, Effects[0] is the one that appears in the ArcGIS user interface on the top (and it's the one that's applied first)

Examples:
RuleID6#Layers[0]#Angle
RuleID6#Layers[1].LineStroke#Width</value>
  </data>
  <data name="QaIsCoveredByOther_7" xml:space="preserve">
    <value>Finds all features in 'covered' for which the specified geometry components are not sufficiently covered by the specified geometry component of features in 'covering', within an (optional) area of interest defined by polygons from 'areaOfInterestClasses'. An allowed uncovered percentage may be specified.

The following geometry components are supported:

- EntireGeometry: the original feature geometry
- Boundary: supported for polygons and polylines. For polylines, the boundary consists of the start/end points of all parts. For polygons, it corresponds to the outlines of all polygon rings.
- Vertices: supported for polygons, polylines, multipatches and multiparts. The vertices of the geometry.
- LineEndPoints: supported for polylines. The start and end point of the entire polyline, i.e. the start point of the first path and the end point of the last path.
- LineStartPoint: supported for polylines. The start point of the entire polyline, i.e. the start point of the first path.
- LineEndPoint: supported for polylines. The end point of the entire polyline, i.e. the end point of the last path.

The number of geometry components in the list must be either 0 (in which case 'EntireGeometry' is used as default), 1 (in which case that component is used for all feature classes in the list) or equal to the number of feature classes. In that case, the components are assigned to the feature classes by their index position in the list.</value>
  </data>
  <data name="QaIsCoveredByOther_areaOfInterestClasses" xml:space="preserve">
    <value>Optional list of polygon feature classes defining an area of interest. Uncovered geometry parts outside a defined area of interest are ignored.</value>
  </data>
  <data name="QaUnique_tables" xml:space="preserve">
    <value>tables to check for overall uniqueness of field values</value>
  </data>
  <data name="QaUnique_1" xml:space="preserve">
    <value>Finds rows in 'tables' for which the values in the field(s) defined by 'uniques' are not unique across all tables</value>
  </data>
  <data name="QaUnique_uniques" xml:space="preserve">
    <value>List of unique constraints for the tables. There may be either a single definition applicable to all tables, or one entry per table if field names are different for different tables. Each constraint definition consists of one or more field names. If the combination of values from more than one field name must be unique, then the field names must be separated by ",". Note that an index on the first unique attribute should exist if the total row count is large (otherwise the test may be slow if applied to a subset of the data, e.g. a spatial query to a feature class)</value>
  </data>
  <data name="QaGeometryConstraint_0" xml:space="preserve">
    <value>Finds all features in 'featureClass' whose geometry (or geometry parts) do not fulfill 'geometryConstraint'</value>
  </data>
  <data name="QaGeometryConstraint_featureClass" xml:space="preserve">
    <value>feature class</value>
  </data>
  <data name="QaGeometryConstraint_geometryConstraint" xml:space="preserve">
    <value>Constraint for valid geometries or geometry parts. The constraint can be based on the following geometry properties:

- $Area (double): the geometry area for polygons and multipatches (0 for points, multipoints and polylines)
- $Length (double): the length of the geometry (perimeter length in case of polygons and multipatches; 0 for points and multipoints)
- $VertexCount (integer): the number of vertices of the geometry
- $SliverRatio (double): the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon or multipatch. NULL for points, multipoints and polylines
- $Dimension (double): the geometry dimension (points/multipoints: 0; lines/paths: 1; polygons/multpatches/rings: 2; triangulation-based multipatch parts: 2.5)
- $EllipticArcCount (integer): the number of elliptic arcs
- $CircularArcCount (integer): the number of circular arcs
- $BezierCount (integer): the number of Bezier segments
- $LinearSegmentCount (integer): the number of linear segments
- $NonLinearSegmentCount (integer): the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount (integer): the total number of segments
- $IsClosed (boolean): for polylines, polygons, rings and paths, indicates if the geometry is closed. NULL for all other geometry types
- $XMin (double): the minimum X/easting coordinate
- $YMin (double): the minimum Y/northing coordinate
- $XMax (double): the maximum X/easting coordinate
- $YMax (double): the maximum Y/northing coordinate
- $ZMin (double): the minimum Z value (NULL if the geometry has no Z values)
- $ZMax (double): the maximum Z value (NULL if the geometry has no Z values)
- $MMin (double): the minimum M value (NULL if the geometry has no M values)
- $MMax (double): the maximum M value (NULL if the geometry has no M values)
- $UndefinedMValueCount (integer): the number of vertices with undefined (NaN) M in the geometry
- $ControlPointCount (integer): the number of control points (vertices with ID != 0) in the geometry (same as PointIdCount)
- $PointIdAware(bool): indicates if geometry is pointId aware
- $PointIdMin (integer): the minimum value of the point ids 
- $PointIdMax (integer): the maximum value of the point ids 
- $PointIdCount (integer): the number of control points (vertices with ID != 0) in the geometry (same as ControlPointCount)

For use on entire feature geometries (i.e. perPart = False):

- $PartCount (integer): the number of geometry parts (points for multipoints, paths for polylines, rings - both exterior and interior - for polygons, rings and triangulated parts for multipatches)
- $IsMultipart (boolean): indicates if the geometry consists of multiple parts (rings or paths). In case of polygons, only True if there are multiple exterior rings
- $ExteriorRingCount (integer): the number of exterior rings in the polygon or multipatch
- $InteriorRingCount (integer): the number of interior rings in the polygon or multipatch

For use on geometry parts (i.e. perPart = True):

- $IsExteriorRing (boolean): indicates if the geometry part is an exterior ring
- $IsInteriorRing (boolean): indicates if the geometry part is an interior ring

For use on multipatch geometries:

- $RingCount (integer): the number of rings in the multipatch
- $TriangleFanCount (integer): the number of triangle fans in the multipatch
- $TriangleStripCount (integer): the number of triangle strips in the multipatch
- $TrianglesPatchCount (integer): the number of patches of triangles in the multipatch

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10
  $Length &gt; 10 OR $PartCount &gt; 1
  NOT ($IsClosed AND $EllipticArcCount = 1 AND $SegmentCount = 1)</value>
  </data>
  <data name="QaGeometryConstraint_perPart" xml:space="preserve">
    <value>Indicates if the geometry constraint is checked separately for each part in case of multipart geometries (true) or for the entire feature (false)</value>
  </data>
  <data name="QaPointNotNear_2" xml:space="preserve">
    <value>Finds points in 'pointClass' that are closer to feature geometries (or geometry components) in 'referenceClasses' than the sum of distances derived from attribute expressions for the point feature and a reference feature.</value>
  </data>
  <data name="QaPointNotNear_searchDistance" xml:space="preserve">
    <value>The maximum search distance for relevant reference features. Should be large enough to contain all actual distances calculated by adding the values of the attribute expressions for point and reference feature pairs.</value>
  </data>
  <data name="QaPointNotNear_pointDistanceExpression" xml:space="preserve">
    <value>SQL expression for calculating the contribution of the point feature to the total allowed minimum distance between point and reference feature.</value>
  </data>
  <data name="QaPointNotNear_referenceDistanceExpressions" xml:space="preserve">
    <value>SQL expressions for calculating the contribution of a reference feature to the total allowed minimum distance between point and reference feature. The number of expressions must be either equal to the number of reference feature classes (in which case the expressions are associated with the reference feature classes by their list index), or there can be exactly one expression which is used for all specified reference feature classes.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_ReportIndividualAttributeConstraintViolations" xml:space="preserve">
    <value>Indicates if attribute constraint violations should be reported as individual issues (true), or combined as one issue per feature pair (false). Default is false.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_ReportIndividualAttributeConstraintViolations" xml:space="preserve">
    <value>Indicates if attribute constraint violations should be reported as individual issues (true), or combined as one issue per feature pair (false). Default is false.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_ReportIndividualAttributeConstraintViolations" xml:space="preserve">
    <value>Indicates if attribute constraint violations should be reported as individual issues (true), or combined as one issue per feature pair (false). Default is false.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_ReportIndividualAttributeConstraintViolations" xml:space="preserve">
    <value>Indicates if attribute constraint violations should be reported as individual issues (true), or combined as one issue per feature pair (false). Default is false.</value>
  </data>
  <data name="QaGroupConnected_RecheckMultiplePartIssues" xml:space="preserve">
    <value>Indicates that any 'Multiple Parts' issues are rechecked at the end of the verification, this time involving *all* line features that match the filter expression, to find additional connections between parts. This verification includes features that would normally be excluded due to the violation of stop conditions, or due to custom filter mechanisms (e.g. area-dependent quality specifications).

If true, all line features are re-read and processed at the end of the quality verification if any 'Multiple Parts' issues were identified within the test area.</value>
  </data>
  <data name="QaGroupConnected_CompleteGroupsOutsideTestArea" xml:space="preserve">
    <value>Indicates if line groups that were found in the test perimeter should be checked for their connectivity *outside* of the test area also:

- false (default): Do not check outside of test area. Optimistic assumption: All connected groups leaving the tested area are assumed to be connected. 

- true: Find errors for groups existing within the test area in the entire extent of the data and report those errors intersecting the test area.
This option includes reading of all features from 'polylineClasses', also outside the test area.
Remark: if 'errorReporting' is set to 'ReferToFirstPart', this value is not used and the found errors are reported with the 'ShortestGaps' option. </value>
  </data>
  <data name="QaLineGroupConstraints_MinGapToSameGroup" xml:space="preserve">
    <value>Minimum allowed gap to another feature within the same connected group</value>
  </data>
  <data name="QaIsCoveredByOther_ValidUncoveredGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid uncovered geometries. The constraint can be based on the following geometry properties:

- $Area - the geometry area (0 for points and polylines)
- $Length - the length of the geometry (perimeter length in case of polygons; 0 for points)
- $VertexCount - the number of vertices of the geometry
- $SliverRatio - the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon. NULL for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10</value>
  </data>
  <data name="QaTouchesOther_ValidTouchGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid "touch" geometries (i.e. the geometry along which two features touch). The constraint can be based on the following geometry properties:

- $Length - the length of the geometry (perimeter length in case of polygons; 0 for points)
- $VertexCount - the number of vertices of the geometry
for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

If both an attribute comparison constraint and an touch geometry constraint are defined, then the "touch" is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaTouchesSelf_ValidTouchGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid "touch" geometries (i.e. the geometry along which two features touch). The constraint can be based on the following geometry properties:

- $Length - the length of the geometry (perimeter length in case of polygons; 0 for points)
- $VertexCount - the number of vertices of the geometry
for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

If both an attribute comparison constraint and an touch geometry constraint are defined, then the "touch" is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaVertexCoincidence_ReportCoordinates" xml:space="preserve">
    <value>Indicates if vertex coordinate values should be included in the issue description</value>
  </data>
  <data name="QaRegularExpression_FieldListType" xml:space="preserve">
    <value>Specifies how the specified field(s) should be interpreted:
- RelevantFields: the specified fields are the ones to be verified.
- IgnoredFields: all editable text fields *except* the specified fields will be verified.</value>
  </data>
  <data name="QaIntersectsOther_ReportIntersectionsAsMultipart" xml:space="preserve">
    <value>Indicates that multiple intersections between two features should be reported as one error with multipart geometry. Otherwise, individual errors are reported for every intersection area.</value>
  </data>
  <data name="QaIntersectsOther_ValidIntersectionGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid intersection geometries. The constraint can be based on the following geometry properties:

- $Area - the geometry area (0 for points and polylines)
- $Length - the length of the geometry (perimeter length in case of polygons; 0 for point)
- $VertexCount - the number of vertices of the geometry
- $SliverRatio - the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon. NULL for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)
- $PartCount - the number of geometry parts (paths for polylines, rings - both exterior and interior - for polygons)
- $IsMultipart - indicates if the geometry consists of multiple parts (rings or paths). In case of polygons, only True if there are multiple exterior rings
- $ExteriorRingCount - the number of exterior rings in the polygon
- $InteriorRingCount - the number of interior rings in the polygon

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10
  $Length &gt; 10 OR $PartCount &gt; 1

If both an attribute comparison constraint and an intersection geometry constraint are defined, then the intersection is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaIntersectsSelf_ReportIntersectionsAsMultipart" xml:space="preserve">
    <value>Indicates that multiple intersections between two features should be reported as one error with multipart geometry. Otherwise, individual errors are reported for every intersection area.</value>
  </data>
  <data name="QaIntersectsSelf_ValidIntersectionGeometryConstraint" xml:space="preserve">
    <value>Constraint for valid intersection geometries. The constraint can be based on the following geometry properties:

- $Area - the geometry area (0 for points and polylines)
- $Length - the length of the geometry (perimeter length in case of polygons; 0 for point)
- $VertexCount - the number of vertices of the geometry
- $SliverRatio - the ratio of (perimeter*perimeter) / area, expressing the elongation of a polygon. NULL for all geometry types except polygons
- $Dimension - the geometry dimension (points: 0; lines: 1; polygons: 2)
- $EllipticArcCount - the number of elliptic arcs
- $CircularArcCount - the number of circular arcs
- $BezierCount - the number of Bezier segments
- $LinearSegmentCount - the number of linear segments
- $NonLinearSegmentCount - the number of non-linear segments (i.e. circular and elliptic arcs, bezier segments) that exist in the geometry
- $SegmentCount - the total number of segments
- $IsClosed - for polylines and polygons, indicates if the geometry is closed. NULL for all other geometry types
- $XMin - the minimum X/easting coordinate
- $YMin - the minimum Y/northing coordinate
- $XMax - the maximum X/easting coordinate
- $YMax - the maximum Y/northing coordinate
- $ZMin - the minimum Z value (NULL if the geometry has no Z values)
- $ZMax - the maximum Z value (NULL if the geometry has no Z values)
- $MMin - the minimum M value (NULL if the geometry has no M values)
- $MMax - the maximum M value (NULL if the geometry has no M values)
- $PartCount - the number of geometry parts (paths for polylines, rings - both exterior and interior - for polygons)
- $IsMultipart - indicates if the geometry consists of multiple parts (rings or paths). In case of polygons, only True if there are multiple exterior rings
- $ExteriorRingCount - the number of exterior rings in the polygon
- $InteriorRingCount - the number of interior rings in the polygon

These properties can be used in a WHERE-clause like expression. If the expression is fulfilled, then no error is reported.

Examples:

  $SliverRatio &lt; 50 OR $Area &gt; 10
  $Area &lt; 5 AND $VertexCount &lt; 10
  $Length &gt; 10 OR $PartCount &gt; 1

If both an attribute comparison constraint and an intersection geometry constraint are defined, then the intersection is considered valid if at least one of them is fulfilled.</value>
  </data>
  <data name="QaMustIntersectOther_0" xml:space="preserve">
    <value>Finds features that don't intersect any other feature in another feature class</value>
  </data>
  <data name="QaMustIntersectOther_featureClass" xml:space="preserve">
    <value>Point, line or polygon feature class</value>
  </data>
  <data name="QaMustIntersectOther_featureClasses" xml:space="preserve">
    <value>Point, line or polygon feature classes</value>
  </data>
  <data name="QaMustIntersectOther_otherFeatureClass" xml:space="preserve">
    <value>Point, line or polygon feature class to be searched for intersecting features</value>
  </data>
  <data name="QaMustIntersectOther_otherFeatureClasses" xml:space="preserve">
    <value>Point, line or polygon feature classes to be searched for intersecting features</value>
  </data>
  <data name="QaMustIntersectOther_relevantRelationCondition" xml:space="preserve">
    <value>Condition on a pair of intersecting features. The pair only counts as intersecting if the condition is either undefined or fulfilled.
The feature to be tested is aliased using "G1". The intersected ("other") feature is aliased using "G2".</value>
  </data>
  <data name="QaMustIntesectOther_1" xml:space="preserve">
    <value>Finds features in a list of feature classes that don't intersect any other feature in another list of feature classes</value>
  </data>
  <data name="QaContainedPointsCount_PolylineUsage" xml:space="preserve">
    <value>Defines the handling if 'polygonClass' is polyline featureclass
-asIs : use polyline as polyline, check the count for points lying on the polyline 
-asPolygonIfClosedElseAsPolyline : if the line is closed, check the count of points lying within the polygon with line as boundary, else check the count of points lying on the line
-asPolygonIfClosedElseReportIssue : if the line is closed, check the count of points lying within the polygon with line as boundary, else report an issue
-asPolygonIfClosedElseIgnore : if the line is closed, check the count of points lying within the polygon with line as boundary, else ignore the feature
</value>
  </data>
  <data name="QaPointNotNear_referenceFlipExpressions" xml:space="preserve">
    <value>SQL expressions to flip the right side of the reference feature. This parameter is only used if 'ReferenceRightSideDistances' is defined.
The number of expressions must be either equal to the number of reference feature classes (in which case the expressions are associated with the reference feature classes by their list index), or there can be exactly one expression which is used for all specified reference feature classes.</value>
  </data>
  <data name="QaPointNotNear_referenceRightSideDistances" xml:space="preserve">
    <value>SQL expressions for calculating the contribution of a reference feature to the total allowed minimum distance between point and reference feature, if the point lies on the right side of the reference feature. If the point lies on the left side of the feature, 'referenceDistanceExpressions' is used if defined, otherwise 'searchDistance'.
This parameter is only used for: 
-polygon features and 'GeometryComponents' equal to EntireFeature or Border
-polyline features and 'GeometryComponents' equal to EntireFeature. 
The number of expressions must be either equal to the number of reference feature classes (in which case the expressions are associated with the reference feature classes by their list index), or there can be exactly one expression which is used for all specified reference feature classes.</value>
  </data>
  <data name="QaPointNotNear_3" xml:space="preserve">
    <value>Finds points in 'pointClass' that are closer to feature geometries (or geometry components) in 'referenceClasses' than the sum of distances derived from attribute expressions for the point feature and a reference feature. The reference feature distances can be defined for both sides of line features or polygon boundaries, with the option to swap left / right sides (as defined by the line direction) based on an attribute expression or constant.</value>
  </data>
  <data name="QaZDifferenceOther_IgnoreNonCoplanarReferenceRings" xml:space="preserve">
    <value>For zComparisonMethod 'IntersectionPoints' and UseDistanceFromReferenceRingPlane =True: indicates if non-coplanar rings should be ignored, i.e. not reported. If 'False' (default), such rings are reported as errors.</value>
  </data>
  <data name="QaZDifferenceOther_MaximumZDifferenceExpression" xml:space="preserve">
    <value>Optional expression to calculate the maximum Z difference based on attributes of the lower/upper features. The lower feature can be addressed as 'L', the upper feature as 'U'.</value>
  </data>
  <data name="QaZDifferenceOther_MinimumZDifferenceExpression" xml:space="preserve">
    <value>Optional expression to calculate the minimum Z difference based on attributes of the lower/upper features. The lower feature can be addressed as 'L', the upper feature as 'U'. If defined, this overrides the value of 'limit'</value>
  </data>
  <data name="QaZDifferenceOther_ReferenceRingPlaneCoplanarityTolerance" xml:space="preserve">
    <value>For zComparisonMethod 'IntersectionPoints' and UseDistanceFromReferenceRingPlane =True: indicates the coplanarity tolerance, i.e. the maximum allowed distance of individual ring vertices from the regression plane through all ring vertices for the ring to be considered planar. The Z difference to non-planar rings is not checked.</value>
  </data>
  <data name="QaZDifferenceOther_RelevantRelationCondition" xml:space="preserve">
    <value>Optional condition that, if defined, must be fulfilled for a pair of features to check the Z differences between them.</value>
  </data>
  <data name="QaZDifferenceOther_UseDistanceFromReferenceRingPlane" xml:space="preserve">
    <value>Indicates that the Z distance between vertices of the input feature class(es) and the planes of intersecting rings of features from the related class(es) is verified. Only relevant for zComparisonMethod "</value>
  </data>
  <data name="QaMpFootprintHoles_ReportVerticalPatchesNotCompletelyWithinFootprint" xml:space="preserve">
    <value>Indicates if vertical patches that fall partly outside the multipatch footprint are reported</value>
  </data>
  <data name="QaIntersectsSelf_GeometryComponents" xml:space="preserve">
    <value>The geometry component to consider for the intersection.
Can either be empty, have one value or have as many values as there are feature classes.
- If no value is given, the entire geometry is used for all feature classes
- If there is one value this value is applied to all feature classes
- If there are as many values as feature classes each value is applied to the corresponding feature class at the same position in the list</value>
  </data>
  <data name="QaMustIntersectOther_1" xml:space="preserve">
    <value>Finds features that don't intersect any feature in a list of other feature classes</value>
  </data>
  <data name="QaGdbRelease_table" xml:space="preserve">
    <value>table to check</value>
  </data>
  <data name="QaGroupConstraints_minDistinctCount" xml:space="preserve">
    <value>The minimum number of distinct values returned from 'distinctExpression', per group value defined by 'groupByExpression'</value>
  </data>
  <data name="QaLineIntersectZ_MaximumZDifferenceExpression" xml:space="preserve">
    <value>The maximally allowed z-Difference as (feature-dependent)expression
Upper feature is aliased as "U", lower feature as "L"
Example: U.ZDiff + L.ZDiff</value>
  </data>
  <data name="QaLineIntersectZ_MinimumZDifferenceExpression" xml:space="preserve">
    <value>The minimally allowed z-Difference as (feature-dependent)expression
Upper feature is aliased as "U", lower feature as "L"
Example: U.ZDiff + L.ZDiff</value>
  </data>
  <data name="QaNotNear_JunctionCoincidenceTolerance" xml:space="preserve">
    <value>If set, the tolerance that 2 junction points are considered equal. If not set: tolerance of 'featureClass'.</value>
  </data>
  <data name="QaPartCoincidenceSelf_7" xml:space="preserve">
    <value>Find line sections longer than a specified minimum length in 'featureClasses', where 2 non-coincident lines lie nearer than 'near', but are not coincident. The minimum length can be defined separately for line pairs that are connected ('connectedMinLengthExpressions') or disjoint ('disjointMinLengthExpressions'). A coincidence tolerance can be specified to indicate a maximum allowed offset between the lines at which they are still considered to be coincident.

Remark: All feature classes in 'featureClasses' must have the same spatial reference.</value>
  </data>
  <data name="QaSchemaSpatialReference_2" xml:space="preserve">
    <value>Checks if the spatial reference of 'featureClass' is exactly (including domain, tolerance and resolution) equal to the spatial reference of 'referenceFeatureClass'.</value>
  </data>
  <data name="QaSchemaSpatialReference_3" xml:space="preserve">
    <value>Checks if the spatial reference of 'featureClass' is exactly (including domain, tolerance and resolution) equal to the spatial reference defined in 'spatialReferenceXml' string.</value>
  </data>
  <data name="QaZDifferenceOther_2" xml:space="preserve">
    <value>Finds features where the Z difference to another feature is not between 'minimumZDifference' and 'maximumZDifference'</value>
  </data>
  <data name="QaZDifferenceOther_3" xml:space="preserve">
    <value>Finds features where the Z difference to features from a list of other feature classes is not between 'minimumZDifference' and 'maximumZDifference'</value>
  </data>
  <data name="QaZDifferenceOther_maximumZDifference" xml:space="preserve">
    <value>maximum allowed Z-Difference. Remark: If 'MaximumZDifferenceExpression' is set, this value is not used.</value>
  </data>
  <data name="QaZDifferenceOther_minimumZDifference" xml:space="preserve">
    <value>minimum allowed Z-Difference. Remark: If 'MinimumZDifferenceExpression' is set, this value is not used.</value>
  </data>
  <data name="QaZDifferenceSelf_2" xml:space="preserve">
    <value>Finds features where the Z difference to another feature is not between 'minimumZDifference' and 'maximumZDifference'</value>
  </data>
  <data name="QaZDifferenceSelf_3" xml:space="preserve">
    <value>Finds features where the Z difference to another feature within a list of feature classes is not between 'minimumZDifference' and 'maximumZDifference'</value>
  </data>
  <data name="QaZDifferenceSelf_maximumZDifference" xml:space="preserve">
    <value>maximum allowed Z-Difference. Remark: If 'MaximumZDifferenceExpression' is set, this value is not used.</value>
  </data>
  <data name="QaZDifferenceSelf_minimumZDifference" xml:space="preserve">
    <value>minimum allowed Z-Difference. Remark: If 'MinimumZDifferenceExpression' is set, this value is not used.</value>
  </data>
  <data name="QaPseudoNodes_ignoreFieldLists" xml:space="preserve">
    <value>fields that are not checked for equality (not editable fields are ignored by default).
For each feature class in 'polylineClasses', the ignore field list must be defined as a string of fields separated by ','.
The sort order must correspond with 'polylineClasses'.</value>
  </data>
  <data name="QaSchemaFieldPropertiesFromTable_0" xml:space="preserve">
    <value>Verifies that fields have expected properties based on a list of field specifications defined in another table. The field specifications table can be filtered to a subset of rows relevant for the verified table.</value>
  </data>
  <data name="QaSchemaFieldPropertiesFromTable_fieldSpecificationsTable" xml:space="preserve">
    <value>The table that contains the list of field specifications.</value>
  </data>
  <data name="QaSchemaFieldPropertiesFromTable_matchAliasName" xml:space="preserve">
    <value>Indicates if a field specification is looked up by alias name also.</value>
  </data>
  <data name="QaSchemaFieldPropertiesFromTable_table" xml:space="preserve">
    <value>The table to check the field properties in.</value>
  </data>
  <data name="QaLineIntersectAngle_AngularUnit" xml:space="preserve">
    <value>Unit of 'limit', default = 'radian'.</value>
  </data>
  <data name="QaMinAngle_AngularUnit" xml:space="preserve">
    <value>Unit of 'limit', default = 'radian'.</value>
  </data>
  <data name="QaSmooth_AngularUnit" xml:space="preserve">
    <value>Unit of 'limit', default = 'radian'.</value>
  </data>
  <data name="QaMaxSlope_AngularUnit" xml:space="preserve">
    <value>Unit of 'limit', default = 'radian'.</value>
  </data>
  <data name="QaAttributeDependency_0" xml:space="preserve">
    <value>Find rows in 'table' that do not have a match in 'mappings'</value>
  </data>
  <data name="QaAttributeDependency_mappings" xml:space="preserve">
    <value>string representations of source values and target values</value>
  </data>
  <data name="QaAttributeDependency_sourceFields" xml:space="preserve">
    <value>fields holding source values</value>
  </data>
  <data name="QaAttributeDependency_table" xml:space="preserve">
    <value>table</value>
  </data>
  <data name="QaAttributeDependency_targetFields" xml:space="preserve">
    <value>fields holding target values</value>
  </data>
  <data name="QaExportTables_0" xml:space="preserve">
    <value>Export 'tables' to a newly created file geodatabase</value>
  </data>
  <data name="QaExportTables_tables" xml:space="preserve">
    <value>tables to export.
Tables can be normal tables or transformers.
Each table will be exported to a separate table. The name of the created table corresponds to the name of the source table.
If severale source tables have the same name, a number is added at the end of the exported table in order to have a unique name.</value>
  </data>
  <data name="QaExportTables_fileGdbPath" xml:space="preserve">
    <value>Path  to the newly created file geodatabase.
The path can contain one * as placeholder for a number to ensure that the path does not already exist.
If the path already exists (only possible if no * in 'fgdbPath'), it will be deleted. 
If the path is locked, i.e. because it belongs to a used file geodatabase, an error occurs. </value>
  </data>
  <data name="QaExportTables_ExportTileIds" xml:space="preserve">
    <value>Add a field to each exported table, which contains the id of tile the exported row belongs to.
Remarks: A source row may be exported several times with different tile ids.</value>
  </data>
  <data name="QaExportTables_ExportTiles" xml:space="preserve">
    <value>If true: Create a feature class which contains the processed tiles</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareXYDomainOrigin" xml:space="preserve">
    <value>Compare the xMins and yMins of the XY-Domains</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareZDomainOrigin" xml:space="preserve">
    <value>Compare the zMins of the Z-Domains</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareMDomainOrigin" xml:space="preserve">
    <value>Compare the mMins of the M-Domains</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareMResolution" xml:space="preserve">
    <value>Compare the m-Resolutions of the spatial references</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareXYResolution" xml:space="preserve">
    <value>Compare the xy-Resolutions of the spatial references</value>
  </data>
  <data name="QaSchemaSpatialReference_CompareZResolution" xml:space="preserve">
    <value>Compare the z-Resolutions of the spatial references</value>
  </data>
  <data name="QaSchemaSpatialReference_compareXYPrecision" xml:space="preserve">
    <value>Compare XY-Domain and XY-Resolution of the spatial references. If any value is different, an error is reported. If you want to compare only the XY-Domain or XY-Resolution, use the optional parameters CompareXYDomainOrigin or CompareXYResolution</value>
  </data>
</root>
