<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="QaSliverPolygon_Message" xml:space="preserve">
    <value>{0} ring classified as sliver (area: {1}; perimeter * perimeter / area: {2}; perimeter: {3})</value>
    <comment>0: interior or exterior, 1: area value, 2: perimeter * perimeter / area value, 3:  perimeter value</comment>
  </data>
  <data name="QaSchemaFieldAliases_NotUnique" xml:space="preserve">
    <value>Alias name '{0}' in table '{1}' is not unique. The following fields have the same alias name: {2}</value>
    <comment>0: value of alias name, 1: name of table, 2: field names</comment>
  </data>
  <data name="QaSchemaFieldAliases_NoAliasName" xml:space="preserve">
    <value>Field '{0}' has no alias name</value>
    <comment>0: field name</comment>
  </data>
  <data name="QaSchemaFieldAliases_MustBeEqualToFieldName" xml:space="preserve">
    <value>Alias name '{0}' must be equal to field name for system field '{1}'</value>
    <comment>0: alias name, 1: field name </comment>
  </data>
  <data name="SchemaTestUtils_LengthLessThanMinimum" xml:space="preserve">
    <value>Length of {0} is less than minimum length {1}: {2}</value>
    <comment>0: property name, 1: minimum length, 2: actual length</comment>
  </data>
  <data name="SchemaTestUtils_LengthGreaterThanMaximum" xml:space="preserve">
    <value>Length of {0} is greater than maximum length {1}: {2}</value>
    <comment>0: property name, 1: maximum length, 2: actual length</comment>
  </data>
  <data name="SchemaTestUtils_CaseAllUppercase" xml:space="preserve">
    <value>{0} must be all uppercase: {1}</value>
    <comment>0: property name, 1: not properly formatted text</comment>
  </data>
  <data name="SchemaTestUtils_CaseAllLowercase" xml:space="preserve">
    <value>{0} must be all lowercase: {1}</value>
    <comment>0: property name, 1: not properly formatted text</comment>
  </data>
  <data name="SchemaTestUtils_CaseMixedCase" xml:space="preserve">
    <value>{0} must be mixed case: {1}</value>
    <comment>0: property name, 1: not properly formatted text</comment>
  </data>
  <data name="SchemaTestUtils_CaseNotAllUppercase" xml:space="preserve">
    <value>{0} must not be all-upper case: {1}</value>
    <comment>0: property name, 1: not properly formatted text</comment>
  </data>
  <data name="SchemaTestUtils_CaseNotAllLowercase" xml:space="preserve">
    <value>{0} must not be all-lower case: {1}</value>
    <comment>0: property name, 1: not properly formatted text</comment>
  </data>
  <data name="QaSchemaFieldAliases_FieldNameCase" xml:space="preserve">
    <value>Field alias name '{0}' (field '{1}'): {2}</value>
    <comment>0: alias name, 1: field name, 2: case error message (see SchemaTestUtils_Case*)</comment>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_DomainDescriptionInvalidLength" xml:space="preserve">
    <value>Domain '{0}': {1} ('{2}')</value>
    <comment>0: domain name, 1: error message (see SchemaTestUtils_LengthGreaterThanMaximum or SchemaTestUtils_LengthLessThanMinimum), 2: domain description</comment>
  </data>
  <data name="QaSchemaFieldDomainDescriptions_DomainDescriptionNotUnique" xml:space="preserve">
    <value>Domain description '{0}' is not unique. The following domains have the same description: {1}</value>
    <comment>0: domain description, 1: domain names</comment>
  </data>
  <data name="QaSchemaFieldNames_FieldNamesSubstringNotUnique" xml:space="preserve">
    <value>The following field names are not unique on the first {0} characters: {1}</value>
    <comment>0: number of characters, 1: field names</comment>
  </data>
  <data name="QaSchemaSpatialReference_CoordinateSystemDifferent" xml:space="preserve">
    <value>Coordinate system is different (expected: {0} actual: {1}); </value>
    <comment>0: expected spatial reference alias, 0: actual spatial reference alias</comment>
  </data>
  <data name="QaSchemaSpatialReference_VerticalCoordinateSystemDifferent" xml:space="preserve">
    <value>Vertical coordinate system is different (expected: {0} actual: {1}); </value>
    <comment>0: expected vertical coordinate system name, 1: actual vertical coordinate system name	</comment>
  </data>
  <data name="QaSchemaSpatialReference_XYPrecision" xml:space="preserve">
    <value>XMin: {0} YMin: {1} XMax: {2} YMax: {3} XY Resolution: {4}</value>
    <comment>0: minimum X value, 1: minimum Y value, 2: maximum X value, 3: maximum Y value, XY resolution</comment>
  </data>
  <data name="QaSchemaSpatialReference_XYPrecisionDifferent" xml:space="preserve">
    <value>XY precision is different (expected: {0} actual: {1}); </value>
    <comment>0: expected XY precision (see QaSchemaSpatialReference_XYPrecision or QaSchemaSpatialReference_NotDefined), 1: actual XY precision (see QaSchemaSpatialReference_XYPrecision or QaSchemaSpatialReference_NotDefined)</comment>
  </data>
  <data name="QaSchemaSpatialReference_ZPrecision" xml:space="preserve">
    <value>ZMin: {0} ZMax: {1} Z Resolution: {2}</value>
    <comment>0: minimum Z value, 1: maximum Z value, 2: Z resolution</comment>
  </data>
  <data name="QaSchemaSpatialReference_ZDomainOrPrecisionDifferent" xml:space="preserve">
    <value>Z domain/precision is different (expected: {0} actual: {1}); </value>
    <comment>0: description of expected Z precision (see QaSchemaSpatialReference_ZPrecision or QaSchemaSpatialReference_NotDefined), 1: description of actual Z precision (see QaSchemaSpatialReference_ZPrecision or QaSchemaSpatialReference_NotDefined)</comment>
  </data>
  <data name="QaSchemaSpatialReference_MPrecision" xml:space="preserve">
    <value>MMin: {0} MMax: {1} M Resolution: {2}</value>
    <comment>0: minimum M value, 1: maximum M value, 2: M Resolution</comment>
  </data>
  <data name="QaSchemaSpatialReference_NotDefined" xml:space="preserve">
    <value>&lt;not defined&gt;</value>
  </data>
  <data name="QaSchemaSpatialReference_MDomainOrPrecisionDifferent" xml:space="preserve">
    <value>M domain/precision is different (expected: {0} actual: {1}); </value>
    <comment>0: description of M precision (see QaSchemaSpatialReference_MPrecision or QaSchemaSpatialReference_NotDefined), 1: description of M precision (see QaSchemaSpatialReference_MPrecision or QaSchemaSpatialReference_NotDefined)	</comment>
  </data>
  <data name="QaSchemaSpatialReference_XYToleranceDifferent" xml:space="preserve">
    <value>XY tolerance is different (expected: {0} actual: {1}); </value>
    <comment>0: expected tolerance, 1: actual tolerance</comment>
  </data>
  <data name="QaSchemaSpatialReference_ZToleranceDifferent" xml:space="preserve">
    <value>Z tolerance is different (expected: {0} actual: {1}); </value>
    <comment>0: expected Z tolerance, 1: actual Z tolerance</comment>
  </data>
  <data name="QaSchemaSpatialReference_MToleranceDifferent" xml:space="preserve">
    <value>M tolerance is different (expected: {0} actual: {1}); </value>
    <comment>0: expected M tolerance, 1: actual M tolerance</comment>
  </data>
  <data name="QaTrimmedTextFields_InvalidStringValue" xml:space="preserve">
    <value>Invalid string value in field {0}: {1} ({2})</value>
    <comment>0: field name, 1: value, 2: error message</comment>
  </data>
  <data name="QaTrimmedTextFields_ValueContainsOnlyBlanks" xml:space="preserve">
    <value>The value in field {0} contains only blanks ({1} blank{2})</value>
    <comment>0: field name, 1: number of blanks, 2: s when plural</comment>
  </data>
  <data name="QaTrimmedTextFields_ValueHasTrailingBlank" xml:space="preserve">
    <value>The value in field {0} has {1} trailing blank{2}</value>
    <comment>0: field name, 1: number of blanks, 2: s when plural	</comment>
  </data>
  <data name="QaTrimmedTextFields_ValueHasLeadingBlank" xml:space="preserve">
    <value>The value in field {0} has {1} leading blank{2}</value>
    <comment>0: field name, 1: number of blanks, 2: s when plural</comment>
  </data>
  <data name="QaTrimmedTextFields_ValueHasLeadingAndTrailingBlanks" xml:space="preserve">
    <value>The value in field {0} has both leading and trailing blanks ({1} blanks)</value>
    <comment>0: field name, 1: number of blanks</comment>
  </data>
  <data name="QaSchemaFieldAliases_EqualsFieldName" xml:space="preserve">
    <value>Alias name '{0}' must be different from field name '{1}'</value>
    <comment>0: alias name, 1: field name</comment>
  </data>
  <data name="QaSchemaFieldAliases_EqualsFieldNameExceptCase" xml:space="preserve">
    <value>Alias name '{0}' must not differ only in character case from field name '{1}'</value>
    <comment>0: alias name, 1: field name</comment>
  </data>
  <data name="QaEdgeMatchCrossingLines_NoMatch_NoCandidate" xml:space="preserve">
    <value>No nearby neighbor feature connected to the border exists.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_NoMatch_NoCandidate_ConnectedOnSameSide" xml:space="preserve">
    <value>No nearby neighbor feature connected to the border exists. The end point connects to another feature on the same side.</value>
  </data>
  <data name="QaEdgeMatchCrossingLines_NoMatch_CandidateExists" xml:space="preserve">
    <value>No exact match. Nearby feature connected to the border exists, nearest end point on border: {0}.</value>
    <comment>0: distance to nearest end point</comment>
  </data>
  <data name="QaEdgeMatchCrossingLines_NoMatch_CandidateExists_EndPointOutsideTolerance" xml:space="preserve">
    <value>No exact match. Nearby feature connected to the border exists, nearest end point on border: {0} (too far). Distance to neighbor line: {1}.</value>
    <comment>0: distance to nearest end point, 1: distance to neighbor line</comment>
  </data>
  <data name="QaEdgeMatchCrossingLines_BordersNotCoincident" xml:space="preserve">
    <value>Borders are not coincident.</value>
  </data>
  <data name="EdgeMatchUtils_AttributeConstraints_ValuesNotEqual" xml:space="preserve">
    <value>Values are not equal ({0})</value>
    <comment>0: non-equal field values string</comment>
  </data>
  <data name="EdgeMatchUtils_AttributeConstraints_ConstraintNotFulfilled" xml:space="preserve">
    <value>Constraint is not fulfilled ({0})</value>
    <comment>0: constraint message</comment>
  </data>
  <data name="QaEdgeMatchCrossingAreas_NoMatch_NoCandidate" xml:space="preserve">
    <value>No nearby neighbor feature connected to the border exists.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_PartlyOutsideVerifiedExtent" xml:space="preserve">
    <value>The border line is partly outside the verified extent.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_NoMatch_CandidateExists" xml:space="preserve">
    <value>No exact match. A nearby neighbor feature connected to the border exists. Borders are not coincident.</value>
  </data>
  <data name="QaEdgeMatchCrossingAreas_Match_ConstraintsNotFulfilled" xml:space="preserve">
    <value>A matching neighbor feature exists (common boundary length: {0}). {1}.</value>
    <comment>0: length of common boundary, 1: constraint message</comment>
  </data>
  <data name="QaEdgeMatchBorderingLines_Match_ConstraintsNotFulfilled" xml:space="preserve">
    <value>A matching neighbor feature exists (common boundary length: {0}). {1}.</value>
    <comment>0: length of common boundary, 1: constraint message</comment>
  </data>
  <data name="QaEdgeMatchBorderingLines_NoMatch_CandidateExists" xml:space="preserve">
    <value>No exact match. A nearby neighbor feature connected to the border exists. The borders are not coincident where the lines touch their border.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_NoMatch_NoCandidate" xml:space="preserve">
    <value>No nearby neighbor feature connected to the border exists.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_PartlyOutsideVerifiedExtent" xml:space="preserve">
    <value>The border line is partly outside the verified extent.</value>
  </data>
  <data name="QaEdgeMatchBorderingLines_Match_EndPointNotCoincident" xml:space="preserve">
    <value>A matching neighbor feature exists, but a line end point is not coincident.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_NoMatch_NoCandidate" xml:space="preserve">
    <value>No neighboring border point found within search distance.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_BordersNotCoincident" xml:space="preserve">
    <value>Borders are not coincident.</value>
  </data>
  <data name="QaEdgeMatchBorderingPoints_NoMatch_CandidateExists" xml:space="preserve">
    <value>No exact match. A nearby neighbor feature connected to the border exists (distance: {0}).</value>
    <comment>0: distance to neighbor feature</comment>
  </data>
  <data name="VertexCoincidenceChecker_NearbyVertexNotCoincident_SameFeature" xml:space="preserve">
    <value>Nearby vertex on same feature is not coincident (distance: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_NearbyVertexNotCoincident_DifferentFeature" xml:space="preserve">
    <value>Nearby vertex is not coincident (distance: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_NearbyEdgeNotPassingThroughVertex_SameFeature" xml:space="preserve">
    <value>Nearby edge on same feature does not pass through vertex (distance to edge: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_NearbyEdgeNotPassingThroughVertex_DifferentFeature" xml:space="preserve">
    <value>Nearby edge does not pass through vertex (distance to edge: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_NoVertexOnNearbyEdge_SameFeature" xml:space="preserve">
    <value>Nearby edge on same feature does not have a coincident vertex (distance to edge: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_NoVertexOnNearbyEdge_DifferentFeature" xml:space="preserve">
    <value>Nearby edge does not have a coincident vertex (distance to edge: {0})</value>
  </data>
  <data name="QaFullCoincidence_PartNotNearReference" xml:space="preserve">
    <value>Part not near reference</value>
  </data>
  <data name="QaNearCoincidenceBase_NearlyCoincidentSection_Short" xml:space="preserve">
    <value>Part near {0} &gt; {1}</value>
    <comment>0: length of error geometry, 1: minLength value</comment>
  </data>
  <data name="QaNearCoincidenceBase_NearlyCoincidentSection_Extended_Base" xml:space="preserve">
    <value>Part within near distance of {0} is {1} long (&gt; {2})</value>
    <comment>0: near distance, 1: length, 2: minLength</comment>
  </data>
  <data name="QaNearCoincidenceBase_NearlyCoincidentSection_Extended_DisjointPaths" xml:space="preserve">
    <value>; the closest distance is {0}</value>
    <comment>0: closest distance between disjoint paths</comment>
  </data>
  <data name="QaNearCoincidenceBase_NearlyCoincidentSection_Extended_ConnectedPaths" xml:space="preserve">
    <value>; the paths are connected</value>
  </data>
  <data name="QaSimpleGeometry_Null" xml:space="preserve">
    <value>Geometry is null</value>
  </data>
  <data name="QaSimpleGeometry_Empty" xml:space="preserve">
    <value>Geometry is empty</value>
  </data>
  <data name="VertexCoincidenceChecker_ZDifference_CoincidentEdge_DifferentFeature" xml:space="preserve">
    <value>Z of coincident point on edge differs (Z difference: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_ZDifference_CoincidentEdge_SameFeature" xml:space="preserve">
    <value>Z of coincident point on edge of same feature differs (Z difference: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_ZDifference_CoincidentVertex_DifferentFeature" xml:space="preserve">
    <value>Z of coincident vertex differs (Z difference: {0})</value>
  </data>
  <data name="VertexCoincidenceChecker_ZDifference_CoincidentVertex_SameFeature" xml:space="preserve">
    <value>Z of coincident vertex on same feature differs (Z difference: {0})</value>
  </data>
  <data name="QaGeometryConstraint_ConstraintNotFulfilled_ForShapePart" xml:space="preserve">
    <value>Constraint is not fulfilled for geometry part: {0} ({1})</value>
    <comment>{0}: constraint
{1}: constraint values</comment>
  </data>
  <data name="QaGeometryConstraint_QaGeometryConstraint_ConstraintNotFulfilled_ForShape" xml:space="preserve">
    <value>Constraint is not fulfilled for shape: {0} ({1})</value>
    <comment>{0}: constraint
{1}: constraint values</comment>
  </data>
  <data name="QaTopoNotNear_InconsistentLineSymbolEnd" xml:space="preserve">
    <value>Inconsistent line symbol end (end segment is too short compared to the symbol width)</value>
  </data>
  <data name="QaNoGaps_GapFound" xml:space="preserve">
    <value>Gap found ( area: </value>
  </data>
  <data name="QaNoGaps_SliverParameters" xml:space="preserve">
    <value>; perimeter * perimeter / area: {0}; perimeter: {1}</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_Crossing" xml:space="preserve">
    <value>Part within near distance is {0} long (&gt;= {1}); the paths are crossing but not connected</value>
    <comment>0: part length
1: maximum allowed length</comment>
  </data>
  <data name="QaTopoNotNear_ShortSubpart" xml:space="preserve">
    <value>Feature with unconnected ends is too short: {0}</value>
    <comment>0: formatted value comparison (length &lt; minimum length)</comment>
  </data>
  <data name="QaTopoNotNear_CoincidentSectionFound" xml:space="preserve">
    <value>Coincident section found</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_Connected_Loop" xml:space="preserve">
    <value>Connected segments within near distance form a loop</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_Connected_Loop_WithinNear" xml:space="preserve">
    <value>Connected segments form a loop and are within near distance to other connected segments</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_WithinNear_Connected" xml:space="preserve">
    <value>Segments are fully within near distance of other segments to which they are connected</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_Connected" xml:space="preserve">
    <value>Part within near distance is {0} long (&gt;= {1}); the paths are connected</value>
    <comment>0: part length
1: maximum allowed length</comment>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_WithinNear" xml:space="preserve">
    <value>Segments are fully within near distance of other segments</value>
  </data>
  <data name="QaTopoNotNear_NearlyCoincidentSection_Disjoint" xml:space="preserve">
    <value>Part within near distance is {0} long (&gt;= {1}); the paths are disjoint</value>
    <comment>0: part length
1: maximum allowed length</comment>
  </data>
  <data name="VertexCoincidenceChecker_NearbyEdgeNotPassingThroughVertex_ReportCoordinatesSuffix" xml:space="preserve">
    <value>. Vertex: {0}, {1}</value>
  </data>
  <data name="VertexCoincidenceChecker_NoVertexOnNearbyEdge_ReportCoordinatesSuffix" xml:space="preserve">
    <value>. Vertex: {0}, {1}</value>
  </data>
  <data name="VertexCoincidenceChecker_NearbyVertexNotCoincident_ReportCoordinatesSuffix" xml:space="preserve">
    <value>. Vertex: {0}, {1}; nearby vertex: {2}, {3}</value>
  </data>
  <data name="QaSchemaSpatialReference_XYDomainOriginDifferent" xml:space="preserve">
    <value>XY Domain Origin is different (expected: {0} actual: {1}); </value>
  </data>
  <data name="QaSchemaSpatialReference_MDomainOriginDifferent" xml:space="preserve">
    <value>M Domain Origin is different (expected: {0} actual: {1}); </value>
  </data>
  <data name="QaSchemaSpatialReference_ZDomainOriginDifferent" xml:space="preserve">
    <value>Z Domain Origin is different (expected: {0} actual: {1}); </value>
  </data>
  <data name="QaSchemaSpatialReference_MResolutionDifferent" xml:space="preserve">
    <value>M Resolution is different (expected: {0} actual: {1}); </value>
  </data>
  <data name="QaSchemaSpatialReference_XYResolutionDifferent" xml:space="preserve">
    <value>XY Resolution is different (expected: {0} actual: {1}); </value>
  </data>
  <data name="QaSchemaSpatialReference_ZResolutionDifferent" xml:space="preserve">
    <value>Z Resolution is different (expected: {0} actual: {1}); </value>
  </data>
</root>
